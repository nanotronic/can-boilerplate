{
  "version": 3,
  "file": "/Volumes/Storage 2000/Work Production/_Clients/_Personal/can-boilerplate/bin/app.js",
  "sources": [
    "assets/js/almond.js",
    "assets/js/amd/jquery-2.0.3.js",
    "assets/js/amd/can/util/can.js",
    "assets/js/amd/can/util/array/each.js",
    "assets/js/amd/can/util/inserted.js",
    "assets/js/amd/can/util/event.js",
    "assets/js/amd/can/util/jquery.js",
    "assets/js/amd/can/util/library.js",
    "assets/js/amd/can/util/bind.js",
    "assets/js/amd/can/util/string.js",
    "assets/js/amd/can/construct.js",
    "assets/js/amd/can/util/batch.js",
    "assets/js/amd/can/map.js",
    "assets/js/amd/can/util/string/deparam.js",
    "assets/js/amd/can/route.js",
    "assets/js/amd/can/control.js",
    "assets/js/amd/can/control/route.js",
    "assets/js/amd/can/list.js",
    "assets/js/amd/can/model.js",
    "assets/js/amd/can/view.js",
    "assets/js/amd/can/compute.js",
    "assets/js/amd/can/view/scope.js",
    "assets/js/amd/can/view/elements.js",
    "assets/js/amd/can/view/scanner.js",
    "assets/js/amd/can/view/node_lists.js",
    "assets/js/amd/can/view/live.js",
    "assets/js/amd/can/view/render.js",
    "assets/js/amd/can/view/mustache.js",
    "assets/js/amd/can/observe.js",
    "assets/js/amd/can/view/bindings.js",
    "assets/js/amd/can/component.js",
    "assets/js/amd/can.js",
    "assets/js/amd/can/route/pushstate.js",
    "../bin/app.templates.js",
    "components/app/app.js",
    "init.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7nRA,AD8nRA;AC7nRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA,ADwCA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA,AD+DA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA,ADYA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9MA,AD+MA;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrOA,ADsOA;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1hCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA,AD+DA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACroBA,ADsoBA;ACroBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACn2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1hCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9kDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChsBA,ADisBA;AChsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1bA,AD2bA;AC1bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtrBA,ADurBA;ACtrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzPA,AD0PA;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACngBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjRA,ADkRA;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5kEA,AD6kEA;AC5kEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjOA,ADkOA;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpRA,ADqRA;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzIA,AD0IA;ACzIA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\n * almond 0.2.7 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"assets/js/almond\", function(){});\n",
    "\n/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// Support: IE9\n\t// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n\tcore_strundefined = typeof undefined,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tlocation = window.location,\n\tdocument = window.document,\n\tdocElem = document.documentElement,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {},\n\n\t// List of deleted data cache ids, so we can reuse them\n\tcore_deletedIds = [],\n\n\tcore_version = \"2.0.3\",\n\n\t// Save a reference to some core methods\n\tcore_concat = core_deletedIds.concat,\n\tcore_push = core_deletedIds.push,\n\tcore_slice = core_deletedIds.slice,\n\tcore_indexOf = core_deletedIds.indexOf,\n\tcore_toString = class2type.toString,\n\tcore_hasOwn = class2type.hasOwnProperty,\n\tcore_trim = core_version.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n\t// Used for splitting on whitespace\n\tcore_rnotwhite = /\\S+/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t},\n\n\t// The ready event handler and self cleanup method\n\tcompleted = function() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\t\tjQuery.ready();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: core_version,\n\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn String( obj );\n\t\t}\n\t\t// Support: Safari <= 5.1 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: Firefox <20\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n\t\ttry {\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!core_hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\t\tif ( scripts ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t},\n\n\tparseJSON: JSON.parse,\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\ttrim: function( text ) {\n\t\treturn text == null ? \"\" : core_trim.call( text );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : core_indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn core_concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: Date.now,\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\t// Note: this method belongs to the css module but it's needed here for the support module.\n\t// If support gets modularized, this method should be moved back to the css module.\n\tswap: function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || type !== \"function\" &&\n\t\t( length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n/*!\n * Sizzle CSS Selector Engine v1.9.4-pre\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-06-03\n */\n(function( window, undefined ) {\n\nvar i,\n\tsupport,\n\tcachedruns,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\toutermostContext,\n\tsortInput,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\thasDuplicate = false,\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trsibling = new RegExp( whitespace + \"*[+~]\" ),\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\t// BMP codepoint\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar doc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent.attachEvent && parent !== parent.top ) {\n\t\tparent.attachEvent( \"onbeforeunload\", function() {\n\t\t\tsetDocument();\n\t\t});\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\n\t\t\t// Support: Opera 10-12/IE8\n\t\t\t// ^= $= *= and empty values\n\t\t\t// Should not select anything\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type attribute is restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"t\", \"\" );\n\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = docElem.compareDocumentPosition ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\n\n\t\tif ( compare ) {\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t}\n\n\t\t// Not directly comparable, sort on existence of method\n\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\t} else if ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val === undefined ?\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull :\n\t\tval;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\tfor ( ; (node = elem[i]); i++ ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (see #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] && match[4] !== undefined ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\t\t\t//   not comment, processing instructions, or others\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( tokens = [] );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar data, cache, outerCache,\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\t\t\t\t\t\t\t\treturn data === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t// A counter to specify which element is currently being matched\n\tvar matcherCachedRuns = 0,\n\t\tbySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tsetMatched = [],\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\toutermost = expandContext != null,\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\tcachedruns = matcherCachedRuns;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector )\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn (val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\telem[ name ] === true ? name.toLowerCase() : null;\n\t\t}\n\t});\n}\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function( support ) {\n\tvar input = document.createElement(\"input\"),\n\t\tfragment = document.createDocumentFragment(),\n\t\tdiv = document.createElement(\"div\"),\n\t\tselect = document.createElement(\"select\"),\n\t\topt = select.appendChild( document.createElement(\"option\") );\n\n\t// Finish early in limited environments\n\tif ( !input.type ) {\n\t\treturn support;\n\t}\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Will be defined later\n\tsupport.reliableMarginRight = true;\n\tsupport.boxSizingReliable = true;\n\tsupport.pixelPosition = false;\n\n\t// Make sure checked status is properly cloned\n\t// Support: IE9, IE10\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement(\"input\");\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"checked\", \"t\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tfragment.appendChild( input );\n\n\t// Support: Safari 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: Firefox, Chrome, Safari\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, marginDiv,\n\t\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[ 0 ];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\t// Check box-sizing and margin behavior.\n\t\tbody.appendChild( container ).appendChild( div );\n\t\tdiv.innerHTML = \"\";\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\";\n\n\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\n\t\t// with some non-1 values of body zoom, ticket #13543\n\t\tjQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\n\t\t\tsupport.boxSizing = div.offsetWidth === 4;\n\t\t});\n\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tbody.removeChild( container );\n\t});\n\n\treturn support;\n})( {} );\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar data_user, data_priv,\n\trbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\n\nData.accepts = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType ?\n\t\towner.nodeType === 1 || owner.nodeType === 9 : true;\n};\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( core_rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\n\n// These may be used throughout the jQuery core codebase\ndata_user = new Data();\ndata_priv = new Data();\n\n\njQuery.extend({\n\tacceptData: Data.accepts,\n\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar attrs, name,\n\t\t\telem = this[ 0 ],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\tattrs = elem.attributes;\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\t\t\t\t\t\tname = attrs[ i ].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? JSON.parse( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook,\n\trclass = /[\\t\\r\\n\\f]/g,\n\trreturn = /\\r/g,\n\trfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = jQuery.trim( cur );\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( core_rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\n\n\tjQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar fn = jQuery.expr.attrHandle[ name ],\n\t\t\tret = isXML ?\n\t\t\t\tundefined :\n\t\t\t\t/* jshint eqeqeq: false */\n\t\t\t\t// Temporarily disable this handler to check existence\n\t\t\t\t(jQuery.expr.attrHandle[ name ] = undefined) !=\n\t\t\t\t\tgetter( elem, name, isXML ) ?\n\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\n\t\t// Restore handler\n\t\tjQuery.expr.attrHandle[ name ] = fn;\n\n\t\treturn ret;\n\t};\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !jQuery.support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\nvar rkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = core_slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\nvar isSimple = /^.[^:#\\[\\.,]*$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = ( rneedsContext.test( selectors ) || typeof selectors !== \"string\" ) ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tcur = matched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn core_indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn core_indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( jQuery.unique(all) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\nvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar\n\t\t\t// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\n\t\t\targs = jQuery.map( this, function( elem ) {\n\t\t\t\treturn [ elem.nextSibling, elem.parentNode ];\n\t\t\t}),\n\t\t\ti = 0;\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\tvar next = args[ i++ ],\n\t\t\t\tparent = args[ i++ ];\n\n\t\t\tif ( parent ) {\n\t\t\t\t// Don't use the snapshot next if it has moved (#13810)\n\t\t\t\tif ( next && next.parentNode !== parent ) {\n\t\t\t\t\tnext = this.nextSibling;\n\t\t\t\t}\n\t\t\t\tjQuery( this ).remove();\n\t\t\t\tparent.insertBefore( elem, next );\n\t\t\t}\n\t\t// Allow new content to include elements from the context set\n\t\t}, true );\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn i ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback, allowIntersection ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = core_concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback, allowIntersection );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Hope ajax is available...\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because core_push.apply(_, arraylike) throws\n\t\t\tcore_push.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\ti = 0,\n\t\t\tl = elems.length,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [];\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, events, type, key, j,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( Data.accepts( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tevents = Object.keys( data.events || {} );\n\t\t\t\t\tif ( events.length ) {\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t},\n\n\t_evalUrl: function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t}\n});\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar l = elems.length,\n\t\ti = 0;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\nvar curCSS, iframe,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = { BODY: \"block\" },\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\t// isHidden might be called from jQuery#filter function;\n\t// in that case, element will be second argument\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nfunction getStyles( elem ) {\n\treturn window.getComputedStyle( elem, null );\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\ncurCSS = function( elem, name, _computed ) {\n\tvar width, minWidth, maxWidth,\n\t\tcomputed = _computed || getStyles( elem ),\n\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\t\tstyle = elem.style;\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: Safari 5.1\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe ||\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\t\t\t).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\telem.remove();\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\t// Support: Android 2.3\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\t\tcomputed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\tajax_nonce = jQuery.now(),\n\n\tajax_rquery = /\\?/,\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\tjQuery.fn[ type ] = function( fn ){\n\t\treturn this.on( type, fn );\n\t};\n});\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrSupported = jQuery.ajaxSettings.xhr(),\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t// Support: IE9\n\t// We need to keep track of outbound xhr and abort them manually\n\t// because IE is not smart enough to do it all by itself\n\txhrId = 0,\n\txhrCallbacks = {};\n\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t\txhrCallbacks = undefined;\n\t});\n}\n\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\njQuery.support.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i, id,\n\t\t\t\t\txhr = options.xhr();\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file protocol always yields status 0, assume 404\n\t\t\t\t\t\t\t\t\txhr.status || 404,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// #11426: When requesting binary data, IE9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[( id = xhrId++ )] = callback(\"abort\");\n\t\t\t\t// Do send the request\n\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) ) {\n\t\tjQuery.fx.start();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar docElem, win,\n\t\telem = this[ 0 ],\n\t\tbox = { top: 0, left: 0 },\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure it's not a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn box;\n\t}\n\n\t// If we don't have gBCR, just use 0,0 rather than error\n\t// BlackBerry 5, iOS 3 (original iPhone)\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\t\tbox = elem.getBoundingClientRect();\n\t}\n\twin = getWindow( doc );\n\treturn {\n\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t};\n};\n\njQuery.offset = {\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n// })();\nif ( typeof module === \"object\" && module && typeof module.exports === \"object\" ) {\n\t// Expose jQuery as module.exports in loaders that implement the Node\n\t// module pattern (including browserify). Do not create the global, since\n\t// the user will be storing it themselves locally, and globals are frowned\n\t// upon in the Node module world.\n\tmodule.exports = jQuery;\n} else {\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\tif ( typeof define === \"function\" && define.amd ) {\n\t\tdefine( \"jquery\", [], function () { return jQuery; } );\n\t}\n}\n\n// If there is a window object, that at least has a document property,\n// define jQuery and $ identifiers\nif ( typeof window === \"object\" && typeof window.document === \"object\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n})( window );\n",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/can',[],function(){\n\tvar can = window.can || {};\n\tif(typeof GLOBALCAN === 'undefined' || GLOBALCAN !== false) {\n\t\twindow.can = can;\n\t}\n\n\tcan.isDeferred = function( obj ) {\n\t\tvar isFunction = this.isFunction;\n\t\t// Returns `true` if something looks like a deferred.\n\t\treturn obj && isFunction(obj.then) && isFunction(obj.pipe);\n\t};\n\t\n\tvar cid = 0;\n\tcan.cid = function(object, name){\n\t\tif(object._cid){\n\t\t\treturn object._cid\n\t\t} else{\n\t\t\treturn object._cid = (name ||\"\" ) + (++cid)\n\t\t}\n\t}\n\tcan.VERSION = '2.0.4';\n\t\n\tcan.simpleExtend = function(d, s){\n\t\tfor(var prop in s){\n\t\t\td[prop] = s[prop]\n\t\t}\n\t\treturn d;\n\t}\n\t\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/array/each',[\"can/util/can\"], function (can) {\n\tcan.each = function (elements, callback, context) {\n\t\tvar i = 0, key;\n\t\tif (elements) {\n\t\t\tif (typeof elements.length === 'number' && elements.pop) {\n\t\t\t\tif ( elements.attr ) {\n\t\t\t\t\telements.attr('length');\n\t\t\t\t}\n\t\t\t\tfor (key = elements.length; i < key; i++) {\n\t\t\t\t\tif (callback.call(context || elements[i], elements[i], i, elements) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\telse if(elements.hasOwnProperty) {\n\t\t\t\tif(can.Map && elements instanceof can.Map) {\n\t\t\t\t\tcan.__reading && can.__reading(elements, '__keys');\n\t\t\t\t\telements = elements.__get()\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (key in elements) {\n\t\t\t\t\tif(elements.hasOwnProperty(key)) {\n\t\t\t\t\t\tif (callback.call(context || elements[key], elements[key], key, elements) === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t};\n\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/inserted',[\"can/util/can\"], function (can) {\n\t// Given a list of elements, check if they are in the dom, if they \n\t// are in the dom, trigger inserted on them.\n\tcan.inserted = function(elems){\n\t\t// prevent mutations from changing the looping\n\t\telems = can.makeArray(elems);\n\t\tvar inDocument = false,\n\t\t\tchecked = false,\n\t\t\tchildren;\n\t\tfor ( var i = 0, elem; (elem = elems[i]) !== undefined; i++ ) {\n\t\t\tif( !inDocument ) {\n\t\t\t\tif( elem.getElementsByTagName ){\n\t\t\t\t\tif( can.has( can.$(document) , elem ).length ) {\n\t\t\t\t\t\tinDocument = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(inDocument && elem.getElementsByTagName){\n\t\t\t\tchildren = can.makeArray( elem.getElementsByTagName(\"*\") );\n\t\t\t\tcan.trigger(elem,\"inserted\",[],false);\n\t\t\t\tfor ( var j = 0, child; (child = children[j]) !== undefined; j++ ) {\n\t\t\t\t\t// Trigger the destroyed event\n\t\t\t\t\tcan.trigger(child,\"inserted\",[],false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tcan.appendChild = function(el, child){\n\t\tif(child.nodeType === 11){\n\t\t\tvar children = can.makeArray(child.childNodes);\n\t\t} else {\n\t\t\tvar children = [child]\n\t\t}\n\t\tel.appendChild(child);\n\t\tcan.inserted(children)\n\t}\n\tcan.insertBefore = function(el, child, ref){\n\t\tif(child.nodeType === 11){\n\t\t\tvar children = can.makeArray(child.childNodes);\n\t\t} else {\n\t\t\tvar children = [child];\n\t\t}\n\t\tel.insertBefore(child, ref);\n\t\tcan.inserted(children)\n\t}\n\t\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/event',[\"can/util/can\"], function(can){\n\n\n\n\t// event.js\n\t// ---------\n\t// _Basic event wrapper._\ncan.addEvent = function( event, fn ) {\n\tvar allEvents = this.__bindEvents || (this.__bindEvents = {}),\n\t\teventList = allEvents[event] || (allEvents[event] = []);\n\t\n\teventList.push({\n\t\thandler: fn,\n\t\tname: event\n\t});\n\treturn this;\n};\n\n// can.listenTo works without knowing how bind works\n// the API was heavily influenced by BackboneJS: \n// http://backbonejs.org/\ncan.listenTo = function(other, event, handler){\n\t\n\t\n\tvar idedEvents = this.__listenToEvents;\n\tif(!idedEvents){\n\t\tidedEvents = this.__listenToEvents = {};\n\t}\n\tvar otherId = can.cid(other);\n\tvar othersEvents = idedEvents[otherId];\n\tif(!othersEvents){\n\t\tothersEvents = idedEvents[otherId] = {\n\t\t\tobj: other,\n\t\t\tevents: {}\n\t\t};\n\t}\n\tvar eventsEvents = othersEvents.events[event]\n\tif(!eventsEvents){\n\t\teventsEvents = othersEvents.events[event] = []\n\t}\n\teventsEvents.push(handler);\n\tcan.bind.call(other, event, handler);\n}\n\ncan.stopListening = function(other, event, handler){\n\tvar idedEvents = this.__listenToEvents,\n\t\titerIdedEvents = idedEvents,\n\t\ti = 0;\n\tif(!idedEvents) {\n\t\treturn this;\n\t}\n\tif( other ) {\n\t\tvar othercid = can.cid(other);\n\t\t(iterIdedEvents = {})[othercid] = idedEvents[othercid];\n\t\t// you might be trying to listen to something that is not there\n\t\tif(!idedEvents[othercid]){\n\t\t\treturn this;\n\t\t}\n\t}\n\t\n\t\n\tfor(var cid in iterIdedEvents) {\n\t\tvar othersEvents = iterIdedEvents[cid],\n\t\t\teventsEvents;\n\t\tother = idedEvents[cid].obj;\n\t\tif( ! event ) {\n\t\t\teventsEvents = othersEvents.events;\n\t\t} else {\n\t\t\t(eventsEvents = {})[event] = othersEvents.events[event]\n\t\t}\n\t\tfor(var eventName in eventsEvents) {\n\t\t\tvar handlers = eventsEvents[eventName] || [];\n\t\t\ti = 0;\n\t\t\twhile(i < handlers.length){\n\t\t\t\tif( (handler && handler === handlers[i]) || (! handler ) ) {\n\t\t\t\t\tcan.unbind.call(other, eventName, handlers[i])\n\t\t\t\t\thandlers.splice(i, 1);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no more handlers?\n\t\t\tif( !handlers.length ){\n\t\t\t\tdelete othersEvents.events[eventName]\n\t\t\t}\n\t\t}\n\t\tif( can.isEmptyObject(othersEvents.events )){\n\t\t\tdelete idedEvents[cid]\n\t\t}\n\t}\n\treturn this;\n}\n\ncan.removeEvent = function(event, fn){\n\tif(!this.__bindEvents){\n\t\treturn this;\n\t}\n\t\n\tvar events = this.__bindEvents[event] || [],\n\t\ti =0,\n\t\tev,\n\t\tisFunction = typeof fn == 'function';\n\t\t\n\twhile(i < events.length){\n\t\tev = events[i]\n\t\tif( (isFunction && ev.handler === fn) || (!isFunction && ev.cid === fn ) ) {\n\t\t\tevents.splice(i, 1);\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\t\n\t\n\t\n\treturn this;\n};\n\ncan.dispatch = function(event, args){\n\tif(!this.__bindEvents){\n\t\treturn;\n\t}\n\tif(typeof event == \"string\"){\n\t\tevent = {type: event}\n\t}\n\tvar eventName = event.type,\n\t\thandlers = (this.__bindEvents[eventName] || []).slice(0),\n\t\targs = [event].concat(args||[]),\n\t\tev;\n\t\n\tfor(var i =0, len = handlers.length; i < len; i++) {\t\n\t\tev = handlers[i];\n\t\tev.handler.apply(this, args);\n\t}\n}\n\nreturn can;\n\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/jquery',[\"jquery\", \"can/util/can\", \"can/util/array/each\", \"can/util/inserted\", \"can/util/event\"], function($, can) {\n\tvar isBindableElement = function(node){\n\t\t//console.log((node.nodeName && (node.nodeType == 1 || node.nodeType == 9) || node === window))\n\t\treturn (node.nodeName && (node.nodeType == 1 || node.nodeType == 9) || node == window);\n\t};\n\n\t// _jQuery node list._\n\t$.extend( can, $, {\n\t\ttrigger: function( obj, event, args ) {\n\t\t\tif(obj.nodeName || obj === window) {\n\t\t\t\t$.event.trigger( event, args, obj, true );\n\t\t\t} else if ( obj.trigger ) {\n\t\t\t\tobj.trigger( event, args );\n\t\t\t} else {\n\t\t\t\tif(typeof event === 'string'){\n\t\t\t\t\tevent = {type: event}\n\t\t\t\t}\n\t\t\t\tevent.target = event.target || obj;\n\t\t\t\tcan.dispatch.call(obj, event, args);\n\t\t\t}\n\t\t},\n\t\taddEvent: can.addEvent,\n\t\tremoveEvent: can.removeEvent,\n\t\t// jquery caches fragments, we always needs a new one\n\t\tbuildFragment : function(elems, context){\n\t\t\tvar oldFragment = $.buildFragment,\n\t\t\t\tret;\n\n\t\t\telems = [elems];\n\t\t\t// Set context per 1.8 logic\n\t\t\tcontext = context || document;\n\t\t\tcontext = !context.nodeType && context[0] || context;\n\t\t\tcontext = context.ownerDocument || context;\n\n\t\t\tret = oldFragment.call( jQuery, elems, context);\n\n\t\t\treturn ret.cacheable ? $.clone(ret.fragment) : ret.fragment || ret;\n\t\t},\n\t\t$: $,\n\t\teach: can.each,\n\t\tbind: function( ev, cb){\n\t\t\t// If we can bind to it...\n\t\t\tif(this.bind && this.bind !== can.bind){\n\t\t\t\tthis.bind(ev, cb)\n\t\t\t} else if(isBindableElement(this)) {\n\t\t\t\t$.event.add(this, ev, cb);\n\t\t\t} else {\n\t\t\t\t// Make it bind-able...\n\t\t\t\tcan.addEvent.call(this, ev, cb)\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tunbind: function(ev, cb){\n\t\t\t// If we can bind to it...\n\t\t\tif(this.unbind && this.unbind !== can.unbind){\n\t\t\t\tthis.unbind(ev, cb)\n\t\t\t} else if(isBindableElement(this)) {\n\t\t\t\t$.event.remove(this, ev, cb);\n\t\t\t} else {\n\t\t\t\t// Make it bind-able...\n\t\t\t\tcan.removeEvent.call(this, ev, cb)\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tdelegate: function(selector, ev , cb){\n\t\t\tif(this.delegate) {\n\t\t\t\tthis.delegate(selector, ev , cb)\n\t\t\t}\n\t\t\t else if(isBindableElement(this)) {\n\t\t\t\t$(this).delegate(selector, ev, cb)\n\t\t\t} else {\n\t\t\t\t// make it bind-able ...\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tundelegate: function(selector, ev , cb){\n\t\t\tif(this.undelegate) {\n\t\t\t\tthis.undelegate(selector, ev , cb)\n\t\t\t}\n\t\t\t else if(isBindableElement(this)) {\n\t\t\t\t$(this).undelegate(selector, ev, cb)\n\t\t\t} else {\n\t\t\t\t// make it bind-able ...\n\t\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tproxy: function(fn, context){\n\t\t\treturn function(){\n\t\t\t\treturn fn.apply(context, arguments)\n\t\t\t}\n\t\t}\n\t});\n\n\t// Wrap binding functions.\n\t/*$.each(['bind','unbind','undelegate','delegate'],function(i,func){\n\t\tcan[func] = function(){\n\t\t\tvar t = this[func] ? this : $([this]);\n\t\t\tt[func].apply(t, arguments);\n\t\t\treturn this;\n\t\t};\n\t});*/\n\n\t// Aliases\n\tcan.on = can.bind;\n\tcan.off = can.unbind;\n\n\t// Wrap modifier functions.\n\t$.each([\"append\",\"filter\",\"addClass\",\"remove\",\"data\",\"get\",\"has\"], function(i,name){\n\t\tcan[name] = function(wrapped){\n\t\t\treturn wrapped[name].apply(wrapped, can.makeArray(arguments).slice(1));\n\t\t};\n\t});\n\n\t// Memory safe destruction.\n\tvar oldClean = $.cleanData;\n\n\t$.cleanData = function( elems ) {\n\t\t$.each( elems, function( i, elem ) {\n\t\t\tif ( elem ) {\n\t\t\t\tcan.trigger(elem,\"removed\",[],false);\n\t\t\t}\n\t\t});\n\t\toldClean(elems);\n\t};\n\t\n\tvar oldDomManip = $.fn.domManip,\n\t\tcbIndex;\n\t\n\t// feature detect which domManip we are using\n\t$.fn.domManip = function(args, cb1, cb2){\n\t\tfor(var i = 1; i< arguments.length; i++){\n\t\t\tif(typeof arguments[i] === \"function\"){\n\t\t\t\tcbIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn oldDomManip.apply(this, arguments)\n\t}\n\t$(document.createElement(\"div\")).append(document.createElement(\"div\"))\n\t\n\t$.fn.domManip = (cbIndex == 2 ? \n\t\tfunction(args, table, callback){\n\t\t\treturn oldDomManip.call(this,args,table, function(elem){\n\t\t\t\tif(elem.nodeType === 11){\n\t\t\t\t\tvar elems = can.makeArray(elem.childNodes);\n\t\t\t\t}\n\t\t\t\tvar ret = callback.apply(this, arguments);\n\t\t\t\tcan.inserted(elems ? elems : [elem]);\n\t\t\t\treturn ret;\n\t\t\t})\n\t\t} :\n\t\tfunction(args, callback){\n\t\t\treturn oldDomManip.call(this,args,function(elem){\n\t\t\t\tif(elem.nodeType === 11){\n\t\t\t\t\tvar elems = can.makeArray(elem.childNodes);\n\t\t\t\t}\n\t\t\t\tvar ret = callback.apply(this, arguments);\n\t\t\t\tcan.inserted(elems ? elems : [elem]);\n\t\t\t\treturn ret;\n\t\t\t})\n\t\t})\n\n\n\t$.event.special.inserted = {};\n\t$.event.special.removed = {};\n\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/library',[\"can/util/jquery\"], function(can) {\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/bind',[\"can/util/library\"], function(can){\n\t\n\t/**\n\t * @typedef {{bind:function():*,unbind:function():*}} can/util/bind\n\t * \n\t * Provides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\n\t * when the first bind happens and.  `unbind()` calls `this._bindteardown` when there\n\t * are no more event handlers.\n\t * \n\t */\n\t// ## Bind helpers\n\tcan.bindAndSetup = function() {\n\t\t// Add the event to this object\n\t\tcan.addEvent.apply(this, arguments);\n\t\t// If not initializing, and the first binding\n\t\t// call bindsetup if the function exists.\n\t\tif(!this._init){\n\t\t\tif(!this._bindings ){\n\t\t\t\tthis._bindings = 1;\n\t\t\t\t// setup live-binding\n\t\t\t\tthis._bindsetup && this._bindsetup();\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tthis._bindings++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn this;\n\t};\n\n\tcan.unbindAndTeardown = function(ev, handler) {\n\t\t// Remove the event handler\n\t\tcan.removeEvent.apply(this, arguments);\n\n\t\tif(this._bindings == null) {\n\t\t\tthis._bindings = 0;\n\t\t} else {\n\t\t\tthis._bindings--;\n\t\t}\n\t\t// If there are no longer any bindings and\n\t\t// there is a bindteardown method, call it.\n\t\tif(!this._bindings){\n\t\t\tthis._bindteardown && this._bindteardown();\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn can;\n\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/string',[\"can/util/library\"], function (can) {\n\t// ##string.js\n\t// _Miscellaneous string utility functions._  \n\n\t// Several of the methods in this plugin use code adapated from Prototype\n\t// Prototype JavaScript framework, version 1.6.0.1.\n\t// © 2005-2007 Sam Stephenson\n\tvar strUndHash = /_|-/,\n\t\tstrColons = /\\=\\=/,\n\t\tstrWords = /([A-Z]+)([A-Z][a-z])/g,\n\t\tstrLowUp = /([a-z\\d])([A-Z])/g,\n\t\tstrDash = /([a-z\\d])([A-Z])/g,\n\t\tstrReplacer = /\\{([^\\}]+)\\}/g,\n\t\tstrQuote = /\"/g,\n\t\tstrSingleQuote = /'/g,\n\t\tstrHyphenMatch = /-+(.)?/g,\n\t\tstrCamelMatch = /[a-z][A-Z]/g,\n\t// Returns the `prop` property from `obj`.\n\t// If `add` is true and `prop` doesn't exist in `obj`, create it as an\n\t// empty object.\n\t\tgetNext = function (obj, prop, add) {\n\t\t\tvar result = obj[prop];\n\n\t\t\tif (result === undefined && add === true) { result = obj[prop] = {} }\n\t\t\treturn result\n\t\t},\n\n\t// Returns `true` if the object can have properties (no `null`s).\n\t\tisContainer = function (current) {\n\t\t\treturn (/^f|^o/).test(typeof current);\n\t\t},\n\t\tconvertBadValues = function(content) {\n\t\t\t// Convert bad values into empty strings\n\t\t\tvar isInvalid = content === null || content === undefined || (isNaN(content) && (\"\" + content === 'NaN'));\n\t\t\treturn ( \"\" + ( isInvalid ? '' : content ) )\n\t\t};\n\n\tcan.extend(can, {\n\t\t// Escapes strings for HTML.\n\t\tesc: function (content) {\n\t\t\treturn convertBadValues(content)\n\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t.replace(/</g, '&lt;')\n\t\t\t\t.replace(/>/g, '&gt;')\n\t\t\t\t.replace(strQuote, '&#34;')\n\t\t\t\t.replace(strSingleQuote, \"&#39;\");\n\t\t},\n\n\t\tgetObject: function (name, roots, add) {\n\n\t\t\t// The parts of the name we are looking up\n\t\t\t// `['App','Models','Recipe']`\n\t\t\tvar parts = name ? name.split('.') : [],\n\t\t\t\tlength = parts.length,\n\t\t\t\tcurrent,\n\t\t\t\tr = 0,\n\t\t\t\ti, container, rootsLength;\n\n\t\t\t// Make sure roots is an `array`.\n\t\t\troots = can.isArray(roots) ? roots : [roots || window];\n\n\t\t\trootsLength = roots.length\n\n\t\t\tif (!length) {\n\t\t\t\treturn roots[0];\n\t\t\t}\n\n\t\t\t// For each root, mark it as current.\n\t\t\tfor (r; r < rootsLength; r++) {\n\t\t\t\tcurrent = roots[r];\n\t\t\t\tcontainer = undefined;\n\n\t\t\t\t// Walk current to the 2nd to last object or until there\n\t\t\t\t// is not a container.\n\t\t\t\tfor (i = 0; i < length && isContainer(current); i++) {\n\t\t\t\t\tcontainer = current;\n\t\t\t\t\tcurrent = getNext(container, parts[i]);\n\t\t\t\t}\n\n\t\t\t\t// If we found property break cycle\n\t\t\t\tif (container !== undefined && current !== undefined) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove property from found container\n\t\t\tif (add === false && current !== undefined) {\n\t\t\t\tdelete container[parts[i - 1]]\n\t\t\t}\n\n\t\t\t// When adding property add it to the first root\n\t\t\tif (add === true && current === undefined) {\n\t\t\t\tcurrent = roots[0]\n\n\t\t\t\tfor (i = 0; i < length && isContainer(current); i++) {\n\t\t\t\t\tcurrent = getNext(current, parts[i], true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn current;\n\t\t},\n\t\t// Capitalizes a string.\n\t\t/**\n\t\t * @function can.capitalize\n\t\t * @parent can.util\n\t\t * @description Capitalize the first letter of a string.\n\t\t * @signature `can.capitalize(str)`\n\t\t * @param {String} str The string to capitalize.\n\t\t * @return {String} The string with the first letter capitalized.\n\t\t *\n\t\t *        can.capitalize('candy is fun!'); //-> Returns: 'Candy is fun!'\n\t\t *\n\t\t */\n\t\tcapitalize: function (s, cache) {\n\t\t\t// Used to make newId.\n\t\t\treturn s.charAt(0).toUpperCase() + s.slice(1);\n\t\t},\n\n\t\t/**\n\t\t * @function can.camelize\n\t\t * @parent can.util\n\t\t * @description Takes a hyphenated string and converts it to a camelCase string..\n\t\t * @signature `can.camelize(str)`\n\t\t * @param {String} str The string to camelCase.\n\t\t * @return {String} The camelCased string.\n\t\t *\n\t\t *        can.camelize('array-count'); //-> 'arrayCount'\n\t\t *\n\t\t */\n\t\tcamelize: function(str){ \n\t\t\treturn convertBadValues(str).replace(strHyphenMatch, function(match, chr){ \n\t\t\t\treturn chr ? chr.toUpperCase() : '' \n\t\t\t}) \n\t\t},\n\n\t\t/**\n\t\t * @function can.hyphenate\n\t\t * @parent can.util\n\t\t * @description Hypenates a camelCase string, and makes it lower case.\n\t\t * @signature `can.capitalize(str)`\n\t\t * @param {String} str The camelCase string to hyphenate.\n\t\t * @return {String} The hyphenated string.\n\t\t *\n\t\t *        can.hyphenate('fooBarBaz'); //-> 'foo-bar-baz'\n\t\t *\n\t\t */\n\t\thyphenate: function(str) {\n\t\t\treturn convertBadValues(str).replace(strCamelMatch, function(str, offset) {\n\t\t\t\treturn str.charAt(0) + '-' + str.charAt(1).toLowerCase();\n\t\t\t});\n\t\t},\n\n\t\t// Underscores a string.\n\t\tunderscore: function (s) {\n\t\t\treturn s\n\t\t\t\t.replace(strColons, '/')\n\t\t\t\t.replace(strWords, '$1_$2')\n\t\t\t\t.replace(strLowUp, '$1_$2')\n\t\t\t\t.replace(strDash, '_')\n\t\t\t\t.toLowerCase();\n\t\t},\n\t\t// Micro-templating.\n\t\t/**\n\t\t */\n\t\tsub: function (str, data, remove) {\n\t\t\tvar obs = [];\n\n\t\t\tstr = str || '';\n\n\t\t\tobs.push(str.replace(strReplacer, function (whole, inside) {\n\n\t\t\t\t// Convert inside to type.\n\t\t\t\tvar ob = can.getObject(inside, data, remove === true ? false : undefined);\n\n\t\t\t\tif (ob === undefined || ob === null) {\n\t\t\t\t\tobs = null;\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\n\t\t\t\t// If a container, push into objs (which will return objects found).\n\t\t\t\tif (isContainer(ob) && obs) {\n\t\t\t\t\tobs.push(ob);\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\n\t\t\t\treturn \"\" + ob;\n\t\t\t}));\n\n\t\t\treturn obs === null ? obs : (obs.length <= 1 ? obs[0] : obs);\n\t\t},\n\n\t\t// These regex's are used throughout the rest of can, so let's make\n\t\t// them available.\n\t\treplacer: strReplacer,\n\t\tundHash: strUndHash\n\t});\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/construct',[\"can/util/string\"], function(can) {\n\n\t// ## construct.js\n\t// `can.Construct`  \n\t// _This is a modified version of\n\t// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).  \n\t// It provides class level inheritance and callbacks._\n\t\n\t// A private flag used to initialize a new class instance without\n\t// initializing it's bindings.\n\tvar initializing = 0;\n\n\t/** \n\t * @add can.Construct\n\t */\n\tcan.Construct = function() {\n\t\tif (arguments.length) {\n\t\t\treturn can.Construct.extend.apply(can.Construct, arguments);\n\t\t}\n\t};\n\n\t/**\n\t * @static\n\t */\n\tcan.extend(can.Construct, {\n\t\t/**\n\t\t * @property {Boolean} can.Construct.constructorExtends constructorExtends\n\t\t * @parent can.Construct.static\n\t\t * \n\t\t * @description\n\t\t * \n\t\t * Toggles the behavior of a constructor function called\n\t\t * without `new` to extend the constructor function or\n\t\t * create a new instance.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * If `constructorExtends` is:\n\t\t * \n\t\t *  - `true` - the constructor extends\n\t\t *  - `false` - a new instance of the constructor is created\n\t\t * \n\t\t * For 1.1, `constructorExtends` defaults to true. For\n\t\t * 1.2, `constructorExtends` will default to false.\n\t\t */\n\t\tconstructorExtends: true,\n\t\t/**\n\t\t * @function can.Construct.newInstance newInstance\n\t\t * @parent can.Construct.static\n\t\t * \n\t\t * @description Returns an instance of `can.Construct`. This method\n\t\t * can be overridden to return a cached instance.\n\t\t * \n\t\t * @signature `can.Construct.newInstance([...args])`\n\t\t * \n\t\t * @param {*} [args] arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\n\t\t * that if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\n\t\t * instead.\n\t\t * @return {class} instance of the class\n\t\t *\n\t\t * @body\n\t\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t\t * __new__ operator.\n\t\t * \n\t\t * ## Example\n\t\t * \n\t\t * The following creates a `Person` Construct and then creates a new instance of Person,\n\t\t * using `apply` on newInstance to pass arbitrary parameters.\n\t\t * \n\t\t * @codestart\n\t\t * var Person = can.Construct.extend({\n\t\t *   init : function(first, middle, last) {\n\t\t *     this.first = first;\n\t\t *     this.middle = middle;\n\t\t *     this.last = last;\n\t\t *   }\n\t\t * });\n\t\t * \n\t\t * var args = [\"Justin\",\"Barry\",\"Meyer\"],\n\t\t *     justin = new Person.newInstance.apply(null, args);\n\t\t * @codeend\n\t\t */\n\t\tnewInstance: function() {\n\t\t\t// Get a raw instance object (`init` is not called).\n\t\t\tvar inst = this.instance(),\n\t\t\t\targ = arguments,\n\t\t\t\targs;\n\t\t\t\t\n\t\t\t// Call `setup` if there is a `setup`\n\t\t\tif ( inst.setup ) {\n\t\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\t}\n\n\t\t\t// Call `init` if there is an `init`  \n\t\t\t// If `setup` returned `args`, use those as the arguments\n\t\t\tif ( inst.init ) {\n\t\t\t\tinst.init.apply(inst, args || arguments);\n\t\t\t}\n\n\t\t\treturn inst;\n\t\t},\n\t\t// Overwrites an object with methods. Used in the `super` plugin.\n\t\t// `newProps` - New properties to add.  \n\t\t// `oldProps` - Where the old properties might be (used with `super`).  \n\t\t// `addTo` - What we are adding to.\n\t\t_inherit: function( newProps, oldProps, addTo ) {\n\t\t\tcan.extend(addTo || newProps, newProps || {})\n\t\t},\n\t\t// used for overwriting a single property.\n\t\t// this should be used for patching other objects\n\t\t// the super plugin overwrites this\n\t\t_overwrite : function(what, oldProps, propName, val){\n\t\t\twhat[propName] = val;\n\t\t},\n\t\t// Set `defaults` as the merger of the parent `defaults` and this \n\t\t// object's `defaults`. If you overwrite this method, make sure to\n\t\t// include option merging logic.\n\t\t/**\n\t\t * @function can.Construct.setup setup\n\t\t * @parent can.Construct.static\n\t\t * \n\t\t * @description Perform initialization logic for a constructor function.\n\t\t * \n\t\t * @signature `can.Construct.setup(base, fullName, staticProps, protoProps)`\n\t\t * \n\t\t * A static `setup` method provides inheritable setup functionality\n\t\t * for a Constructor function. The following example\n\t\t * creates a Group constructor function.  Any constructor\n\t\t * functions that inherit from Group will be added to \n\t\t * `Group.childGroups`.\n\t\t * \n\t\t * \n\t\t *     Group = can.Construct.extend({\n\t\t *       setup: function(Construct, fullName, staticProps, protoProps){\n\t\t *         this.childGroups = [];\n\t\t *         if(Construct !== can.Construct){\n\t\t *           this.childGroups(Construct)\n\t\t *         }\n\t\t *         Construct.setup.apply(this, arguments)\n\t\t *       }   \n\t\t *     },{})\n\t\t *     var Flock = Group.extend(...)\n\t\t *     Group.childGroups[0] //-> Flock\n\t\t * \n\t\t * @param {constructor} base The base constructor that is being inherited from.\n\t\t * @param {String} fullName The name of the new constructor.\n\t\t * @param {Object} staticProps The static properties of the new constructor.\n\t\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t\t *\n\t\t * @body\n\t\t * The static `setup` method is called immediately after a constructor \n\t\t * function is created and \n\t\t * set to inherit from its base constructor. It is useful for setting up \n\t\t * additional inheritance work.\n\t\t * Do not confuse this with the prototype `[can.Construct::setup]` method.\n\t\t * \n\t\t * ## Setup Extends Defaults\n\t\t * \n\t\t * Setup deeply extends the static `defaults` property of the base constructor with \n\t\t * properties of the inheriting constructor.  For example:\n\t\t * \n\t\t * @codestart\n\t\t * Parent = can.Construct.extend({\n\t\t *   defaults : {\n\t\t *     parentProp: 'foo'\n\t\t *   }\n\t\t * },{})\n\t\t * \n\t\t * Child = Parent.extend({\n\t\t *   defaults : {\n\t\t *     childProp : 'bar'\n\t\t *   }\n\t\t * },{}\n\t\t *     \n\t\t * Child.defaults // {parentProp: 'foo', 'childProp': 'bar'}\n\t\t * @codeend\n\t\t * \n\t\t * ## Example\n\t\t * \n\t\t * This `Parent` class adds a reference to its base class to itself, and\n\t\t * so do all the classes that inherit from it.\n\t\t * \n\t\t * @codestart\n\t\t * Parent = can.Construct.extend({\n\t\t *   setup : function(base, fullName, staticProps, protoProps){\n\t\t *     this.base = base;\n\t\t * \n\t\t *     // call base functionality\n\t\t *     can.Construct.setup.apply(this, arguments)\n\t\t *   }\n\t\t * },{});\n\t\t * \n\t\t * Parent.base; // can.Construct\n\t\t *     \n\t\t * Child = Parent({});\n\t\t * \n\t\t * Child.base; // Parent\n\t\t * @codeend\n\t\t */\n\t\tsetup: function( base, fullName ) {\n\t\t\tthis.defaults = can.extend(true,{}, base.defaults, this.defaults);\n\t\t},\n\t\t// Create's a new `class` instance without initializing by setting the\n\t\t// `initializing` flag.\n\t\tinstance: function() {\n\n\t\t\t// Prevents running `init`.\n\t\t\tinitializing = 1;\n\n\t\t\tvar inst = new this();\n\n\t\t\t// Allow running `init`.\n\t\t\tinitializing = 0;\n\n\t\t\treturn inst;\n\t\t},\n\t\t// Extends classes.\n\t\t/**\n\t\t * @function can.Construct.extend extend\n\t\t * @parent can.Construct.static\n\t\t * \n\t\t * @signature `can.Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t\t * \n\t\t * Extends `can.Construct`, or constructor functions derived from `can.Construct`, \n\t\t * to create a new constructor function. Example:\n\t\t * \n\t\t *     Animal = can.Construct.extend({\n\t\t *       sayHi: function(){\n\t\t *         console.log(\"hi\")\n\t\t *       }\n\t\t *     })\n\t\t *     var animal = new Animal()\n\t\t *     animal.sayHi();\n\t\t * \n\t\t * @param {String} [name] Creates the necessary properties and \n\t\t * objects that point from the `window` to the created constructor function. The following:\n\t\t * \n\t\t *     can.Construct.extend(\"company.project.Constructor\",{})\n\t\t *     \n\t\t * creates a `company` object on window if it does not find one, a \n\t\t * `project` object on `company` if it does not find one, and it will set the\n\t\t * `Constructor` property on the `project` object to point to the constructor function.\n\t\t * \n\t\t * Finally, it sets \"company.project.Constructor\" as [can.Construct.fullName fullName]\n\t\t * and \"Constructor\" as [can.Construct.shortName shortName].\n\t\t * \n\t\t * @param {Object} [staticProperties] Properties that are added the constructor \n\t\t * function directly. For example:\n\t\t * \n\t\t *     Animal = can.Construct.extend({\n\t\t *       findAll: function(){\n\t\t *         return can.ajax({url: \"/animals\"})\n\t\t *       }\n\t\t *     },{});\n\t\t *     \n\t\t *     Animal.findAll().then(function(json){ ... })\n\t\t * \n\t\t * The [can.Construct.setup static setup] method can be used to \n\t\t * specify inheritable behavior when a Constructor function is created.\n\t\t * \n\t\t * @param {Object} instanceProperties Properties that belong to \n\t\t * instances made with the constructor. These properties are added to the\n\t\t * constructor's `prototype` object. Example:\n\t\t * \n\t\t *     Animal = can.Construct.extend({\n\t\t *       init: function(name){\n\t\t *         this.name = name;\n\t\t *       },\n\t\t *       sayHi: function(){\n\t\t *         console.log(this.name,\"says hi\")\n\t\t *       }\n\t\t *     })\n\t\t *     var animal = new Animal()\n\t\t *     animal.sayHi();\n\t\t * \n\t\t * The [can.Construct::init init] and [can.Construct::setup setup] properties\n\t\t * are used for initialization.\n\t\t * \n\t\t * @return {function} The constructor function.\n\t\t * \n\t\t */\n\t\textend: function( fullName, klass, proto ) {\n\t\t\t// Figure out what was passed and normalize it.\n\t\t\tif ( typeof fullName != 'string' ) {\n\t\t\t\tproto = klass;\n\t\t\t\tklass = fullName;\n\t\t\t\tfullName = null;\n\t\t\t}\n\n\t\t\tif ( ! proto ) {\n\t\t\t\tproto = klass;\n\t\t\t\tklass = null;\n\t\t\t}\n\t\t\tproto = proto || {};\n\n\t\t\tvar _super_class = this,\n\t\t\t\t_super = this.prototype,\n\t\t\t\tname, shortName, namespace, prototype;\n\n\t\t\t// Instantiate a base class (but only create the instance,\n\t\t\t// don't run the init constructor).\n\t\t\tprototype = this.instance();\n\t\t\t\n\t\t\t// Copy the properties over onto the new prototype.\n\t\t\tcan.Construct._inherit(proto, _super, prototype);\n\n\t\t\t// The dummy class constructor.\n\t\t\tfunction Constructor() {\n\t\t\t\t// All construction is actually done in the init method.\n\t\t\t\tif ( ! initializing ) {\n\t\t\t\t\treturn this.constructor !== Constructor && arguments.length && Constructor.constructorExtends?\n\t\t\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\t\t\targuments.callee.extend.apply(arguments.callee, arguments) :\n\t\t\t\t\t\t// We are being called with `new`.\n\t\t\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\t\tfor ( name in _super_class ) {\n\t\t\t\tif ( _super_class.hasOwnProperty(name) ) {\n\t\t\t\t\tConstructor[name] = _super_class[name];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy new static properties on class.\n\t\t\tcan.Construct._inherit(klass, _super_class, Constructor);\n\n\t\t\t// Setup namespaces.\n\t\t\tif ( fullName ) {\n\n\t\t\t\tvar parts = fullName.split('.'),\n\t\t\t\t\tshortName = parts.pop(),\n\t\t\t\t\tcurrent = can.getObject(parts.join('.'), window, true),\n\t\t\t\t\tnamespace = current,\n\t\t\t\t\t_fullName = can.underscore(fullName.replace(/\\./g, \"_\")),\n\t\t\t\t\t_shortName = can.underscore(shortName);\n\n\t\t\t\n\t\t\t\t\n\t\t\t\tcurrent[shortName] = Constructor;\n\t\t\t}\n\n\t\t\t// Set things that shouldn't be overwritten.\n\t\t\tcan.extend(Constructor, {\n\t\t\t\tconstructor: Constructor,\n\t\t\t\tprototype: prototype,\n\t\t\t\t/**\n\t\t\t\t * @property {String} can.Construct.namespace namespace\n\t\t\t\t * @parent can.Construct.static\n\t\t\t\t *\n\t\t\t\t * The `namespace` property returns the namespace your constructor is in.\n\t\t\t\t * This provides a way organize code and ensure globally unique types. The\n\t\t\t\t * `namespace` is the [can.Construct.fullName fullName] you passed without the [can.Construct.shortName shortName].\n\t\t\t\t * \n\t\t\t\t * @codestart\n\t\t\t\t * can.Construct(\"MyApplication.MyConstructor\",{},{});\n\t\t\t\t * MyApplication.MyConstructor.namespace // \"MyApplication\"\n\t\t\t\t * MyApplication.MyConstructor.shortName // \"MyConstructor\"\n\t\t\t\t * MyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"\n\t\t\t\t * @codeend\n\t\t\t\t */\n\t\t\t\tnamespace: namespace,\n\t\t\t\t/**\n\t\t\t\t * @property {String} can.Construct.shortName shortName\n\t\t\t\t * @parent can.Construct.static\n\t\t\t\t *\n\t\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t\t * name you passed without the [can.Construct.namespace namespace].\n\t\t\t\t * \n\t\t\t\t * @codestart\n\t\t\t\t * can.Construct(\"MyApplication.MyConstructor\",{},{});\n\t\t\t\t * MyApplication.MyConstructor.namespace // \"MyApplication\"\n\t\t\t\t * MyApplication.MyConstructor.shortName // \"MyConstructor\"\n\t\t\t\t * MyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"\n\t\t\t\t * @codeend\n\t\t\t\t */\n\t\t\t\t_shortName : _shortName,\n\t\t\t\t/**\n\t\t\t\t * @property {String} can.Construct.fullName fullName\n\t\t\t\t * @parent can.Construct.static\n\t\t\t\t *\n\t\t\t\t * If you pass a name when creating a Construct, the `fullName` property will be set to\n\t\t\t\t * the name you passed. The `fullName` consists of the [can.Construct.namespace namespace] and \n\t\t\t\t * the [can.Construct.shortName shortName].\n\t\t\t\t * \n\t\t\t\t * @codestart\n\t\t\t\t * can.Construct(\"MyApplication.MyConstructor\",{},{});\n\t\t\t\t * MyApplication.MyConstructor.namespace // \"MyApplication\"\n\t\t\t\t * MyApplication.MyConstructor.shortName // \"MyConstructor\"\n\t\t\t\t * MyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"\n\t\t\t\t * @codeend\n\t\t\t\t */\n\t\t\t\tfullName: fullName,\n\t\t\t\t_fullName: _fullName\n\t\t\t});\n\n\t\t\t// Dojo and YUI extend undefined\n\t\t\tif(shortName !== undefined) {\n\t\t\t\tConstructor.shortName = shortName;\n\t\t\t}\n\n\t\t\t// Make sure our prototype looks nice.\n\t\t\tConstructor.prototype.constructor = Constructor;\n\n\t\t\t\n\t\t\t// Call the class `setup` and `init`\n\t\t\tvar t = [_super_class].concat(can.makeArray(arguments)),\n\t\t\t\targs = Constructor.setup.apply(Constructor, t );\n\t\t\t\n\t\t\tif ( Constructor.init ) {\n\t\t\t\tConstructor.init.apply(Constructor, args || t );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @prototype\n\t\t\t */\n\t\t\treturn Constructor;\n\n\t\t\t\n\t\t\t\n\t\t\t//  \n\t\t\t/**\n\t\t\t * @property {Object} can.Construct.prototype.constructor constructor\n\t\t\t * @parent can.Construct.prototype\n\t\t\t *\n\t\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t\t * the constructor's static properties from an instance.\n\t\t\t * \n\t\t\t * ## Example\n\t\t\t * \n\t\t\t * This can.Construct has a static counter that counts how many instances have been created:\n\t\t\t *\n\t\t\t * @codestart\n\t\t\t * can.Construct.extend(\"Counter\", {\n\t\t\t *     count: 0\n\t\t\t * }, {\n\t\t\t *     init: function() {\n\t\t\t *         this.constructor.count++;\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * \n\t\t\t * new Counter();\n\t\t\t * Counter.count; // 1\n\t\t\t * @codeend \n\t\t\t */\n\t\t}\n\n\t});\n\t/** \n\t * @function can.Construct.prototype.setup setup\n\t * @parent can.Construct.prototype\n\t * \n\t * @signature `construct.setup(...args)`\n\t * \n\t * A setup function for the instantiation of a constructor function.\n\t * \n\t * @param {*} args The arguments passed to the constructor.\n\t * \n\t * @return {Array|undefined} If an array is returned, the array's items are passed as\n\t * arguments to [can.Construct::init init]. The following example always makes \n\t * sure that init is called with a jQuery wrapped element:\n\t * \n\t *     WidgetFactory = can.Construct.extend({\n\t *         setup: function(element){\n\t *             return [$(element)]\n\t *         }\n\t *     })\n\t *     \n\t *     MyWidget = WidgetFactory.extend({\n\t *         init: function($el){\n\t *             $el.html(\"My Widget!!\")\n\t *         }\n\t *     })\n\t * \n\t * Otherwise, the arguments to the\n\t * constructor are passed to [can.Construct::init] and the return value of `setup` is discarded.\n\t * \n\t * @body\n\t * \n\t * ## Deciding between `setup` and `init`\n\t * \n\t * \n\t * Usually, you should use [can.Construct::init init] to do your constructor function's initialization.\n\t * Use `setup` instead for:\n\t * \n\t *   - initialization code that you want to run before the inheriting constructor's \n\t *     `init` method is called.\n\t *   - initialization code that should run whether or not inheriting constructors\n\t *     call their base's `init` methods.\n\t *   - modifying the arguments that will get passed to `init`.\n\t * \n\t * ## Example\n\t * \n\t * This code is a simplified version of the code in [can.Control]'s setup\n\t * method. It converts the first argument to a jQuery collection and\n\t * extends the controller's defaults with the options that were passed.\n\t * \n\t * \n\t *     can.Control = can.Construct.extend({\n\t *         setup: function(domElement, rawOptions) {\n\t *             // set up this.element\n\t *             this.element = $(domElement);\n\t *         \n\t *             // set up this.options\n\t *             this.options = can.extend({},\n\t *                                   this.constructor.defaults,\n\t *                                   rawOptions\n\t *                                  );\n\t * \n\t *             // pass this.element and this.options to init.\n\t *             return [this.element, this.options];        \n\t *         }\n\t *     });\n\t * \n\t */\n\tcan.Construct.prototype.setup = function(){};\n\t/** \n\t * @function can.Construct.prototype.init init\n\t * @parent can.Construct.prototype\n\t * \n\t * @description Called when a new instance of a can.Construct is created.\n\t * \n\t * @signature `construct.init(...args)`\n\t * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can.Construct::setup])\n\t * \n\t * @body\n\t * If a prototype `init` method is provided, it is called when a new Construct is created,\n\t * after [can.Construct::setup]. The `init` method is where the bulk of your initialization code\n\t * should go, and a common thing to do in `init` is to save the arguments passed into the constructor.\n\t * \n\t * ## Examples\n\t * \n\t * First, we'll make a Person constructor that has a first and last name:\n\t *\n\t * @codestart\n\t * var Person = can.Construct.extend({\n\t *     init: function(first, last) {\n\t *         this.first = first;\n\t *         this.last  = last;\n\t *     }\n\t * });\n\t * \n\t * var justin = new Person(\"Justin\", \"Meyer\");\n\t * justin.first; // \"Justin\"\n\t * justin.last; // \"Meyer\"\n\t * @codeend\n\t * \n\t * Then we'll extend Person into Programmer and add a favorite language:\n\t * \n\t * @codestart\n\t * var Programmer = Person.extend({\n\t *     init: function(first, last, language) {\n\t *         // call base's init\n\t *         Person.prototype.init.apply(this, arguments);\n\t *\n\t *         // other initialization code\n\t *         this.language = language;\n\t *     },\n\t *     bio: function() {\n\t *         return \"Hi! I'm \"\" + this.first + \" \" + this.last +\n\t *             \" and I write \" + this.language + \".\";\n\t *     }\n\t * });\n\t * \n\t * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n\t * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n\t * @codeend\n\t * \n\t * ## Modified Arguments\n\t * \n\t * [can.Construct::setup] is able to modify the arguments passed to `init`.\n\t * If you aren't receiving the exact arguments as those passed to `new Construct(args)`,\n\t * check to make sure that they aren't being changed by `setup` somewhere along \n\t * the inheritance chain.\n\t */\n\tcan.Construct.prototype.init = function(){};\n\n\t\n\treturn can.Construct;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/batch',[\"can/util/can\"], function(can){\n\t\n\t\t// Which batch of events this is for -- might not want to send multiple\n\t\t// messages on the same batch.  This is mostly for event delegation.\n\tvar\tbatchNum = 1,\n\t\t// how many times has start been called without a stop\n\t\ttransactions = 0,\n\t\t// an array of events within a transaction\n\t\tbatchEvents = [],\n\t\tstopCallbacks = [];\n\t\n\t\n\tcan.batch = {\n\t\t/**\n\t\t * @function can.batch.start\n\t\t * @parent can.batch\n\t\t * @description Begin an event batch.\n\t\t * \n\t\t * @signature `can.batch.start([batchStopHandler])`\n\t\t * \n\t\t * @param {Function} [batchStopHandler] a callback that gets called after all batched events have been called\n\t\t *\n\t\t * @body\n\t\t * `can.batch.start` causes can.Map to begin an event batch. Until `[can.batch.stop]` is called, any\n\t\t * events that would result from calls to `[can.Map::attr attr]` are held back from firing. If you have\n\t\t * lots of changes to make to can.Maps, batching them together can help performance &emdash; especially if\n\t\t * those can.Maps are live-bound to the DOM.\n\t\t *\n\t\t * In this example, you can see how the _first_ and _change_ events are not fired (and their handlers\n\t\t * are not called) until `can.batch.stop` is called.\n\t\t *\n\t\t * @codestart\n\t\t * var person = new can.Map({\n\t\t *     first: 'Alexis',\n\t\t *     last: 'Abril'\n\t\t * });\n\t\t *\n\t\t * person.bind('first', function() {\n\t\t *     console.log(\"First name changed.\"\");\n\t\t * }).bind('change', function() {\n\t\t *     console.log(\"Something changed.\");\n\t\t * });\n\t\t * \n\t\t * can.batch.start();\n\t\t * person.attr('first', 'Alex');\n\t\t * console.log('Still in the batch.');\n\t\t * can.batch.stop();\n\t\t * \n\t\t * // the log has:\n\t\t * // Still in the batch.\n\t\t * // First name changed.\n\t\t * // Something changed.\n\t\t * @codeend\n\t\t *\n\t\t * You can also pass a callback to `can.batch.start` which will be called after all the events have\n\t\t * been fired:\n\t\t * @codestart\n\t\t * can.batch.start(function() {\n\t\t *     console.log('The batch is over.');\n\t\t * });\n\t\t * person.attr('first', 'Izzy');\n\t\t * console.log('Still in the batch.');\n\t\t * can.batch.stop();\n\t\t * \n\t\t * // The console has:\n\t\t * // Still in the batch.\n\t\t * // First name changed.\n\t\t * // Something changed.\n\t\t * // The batch is over.\n\t\t * @codeend\n\t\t *\n\t\t * ## Calling `can.batch.start` multiple times\n\t\t * \n\t\t * If you call `can.batch.start` more than once, `can.batch.stop` needs to be called\n\t\t * the same number of times before any batched events will fire. For ways\n\t\t * to circumvent this process, see [can.batch.stop].\n\t\t *\n\t\t * Here is an example that demonstrates how events are affected by calling\n\t\t * `can.batch.start` multiple times.\n\t\t * \n\t\t * @codestart\n\t\t * var addPeople = function(observable) {\n\t\t *     can.batch.start();\n\t\t *     observable.attr('a', 'Alice');\n\t\t *     observable.attr('b', 'Bob');\n\t\t *     observable.attr('e', 'Eve');\n\t\t *     can.batch.stop();\n\t\t * };\n\t\t *\n\t\t * // In a completely different place:\n\t\t * var list = new can.Map();\n\t\t * list.bind('change', function() {\n\t\t *     console.log('The list changed.');\n\t\t * });\n\t\t *\n\t\t * can.batch.start();\n\t\t * addPeople(list);\n\t\t * console.log('Still in the batch.');\n\t\t *\n\t\t * // Here, the console has:\n\t\t * // Still in the batch.\n\t\t * \n\t\t * can.batch.stop();\n\t\t * \n\t\t * // Here, the console has:\n\t\t * // Still in the batch.\n\t\t * // The list changed.\n\t\t * // The list changed.\n\t\t * // The list changed.\n\t\t * @codeend\n\t\t */\n\t\tstart: function( batchStopHandler ) {\n\t\t\ttransactions++;\n\t\t\tbatchStopHandler && stopCallbacks.push(batchStopHandler);\n\t\t},\n\t\t/**\n\t\t * @function can.batch.stop\n\t\t * @parent can.batch\n\t\t * @description End an event batch.\n\t\t * @signature `can.batch.stop([force[, callStart]])`\n\t\t * @param {bool} [force=false] whether to stop batching events immediately\n\t\t * @param {bool} [callStart=false] whether to call `[can.batch.start can.batch.start]` after firing batched events\n\t\t * \n\t\t * @body\n\t\t * `can.batch.stop` matches an earlier `[can.batch.start]` call. If `can.batch.stop` has been\n\t\t * called as many times as `can.batch.start` (or if _force_ is true), all batched events will be\n\t\t * fired and any callbacks passed to `can.batch.start` since the beginning of the batch will be\n\t\t * called. If _force and _callStart_ are both true, a new batch will be started when all\n\t\t * the events and callbacks have been fired.\n\t\t *\n\t\t * See `[can.batch.start]` for examples of `can.batch.start` and `can.batch.stop` in normal use.\n\t\t * \n\t\t * In this example, the batch is forceably ended in the `addPeople` function.\n\t\t * @codestart\n\t\t * var addPeople = function(observable) {\n\t\t *     can.batch.start();\n\t\t *     observable.attr('a', 'Alice');\n\t\t *     observable.attr('b', 'Bob');\n\t\t *     observable.attr('e', 'Eve');\n\t\t *     can.batch.stop(true);\n\t\t * };\n\t\t *\n\t\t * // In a completely different place:\n\t\t * var list = new can.Map();\n\t\t * list.bind('change', function() {\n\t\t *     console.log('The list changed.');\n\t\t * });\n\t\t *\n\t\t * can.batch.start();\n\t\t * addPeople(list);\n\t\t * console.log('Still in the batch.');\n\t\t *\n\t\t * // Here, the console has:\n\t\t * // Still in the batch.\n\t\t * \n\t\t * can.batch.stop();\n\t\t * \n\t\t * // Here, the console has:\n\t\t * // The list changed.\n\t\t * // The list changed.\n\t\t * // The list changed.\n\t\t * // Still in the batch.\n\t\t * @codeend\n\t\t */\n\t\tstop: function(force, callStart){\n\t\t\tif(force){\n\t\t\t\ttransactions = 0;\n\t\t\t} else {\n\t\t\t\ttransactions--;\n\t\t\t}\n\t\t\t\n\t\t\tif(transactions == 0){\n\t\t\t\tvar items = batchEvents.slice(0),\n\t\t\t\t\tcallbacks = stopCallbacks.slice(0);\n\t\t\t\tbatchEvents= [];\n\t\t\t\tstopCallbacks = [];\n\t\t\t\tbatchNum++;\n\t\t\t\tcallStart && can.batch.start();\n\t\t\t\tcan.each(items, function( args ) {\n\t\t\t\t\tcan.trigger.apply(can, args);\n\t\t\t\t});\n\t\t\t\tcan.each(callbacks, function( cb ) {\n\t\t\t\t\tcb();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.batch.trigger\n\t\t * @parent can.batch\n\t\t * @description Trigger an event to be added to the current batch.\n\t\t * @signature `can.batch.trigger(item, event [, args])`\n\t\t * @param {can.Map} item the target of the event\n\t\t * @param {String|{type: String}} event the type of event, or an event object with a type given\n\t\t * @param {Array} [args] the parameters to trigger the event with.\n\t\t * \n\t\t * @body\n\t\t * If events are currently being batched, calling `can.batch.trigger` adds an event\n\t\t * to the batch. If events are not currently being batched, the event is triggered\n\t\t * immediately.\n\t\t */\n\t\ttrigger: function( item, event, args ) {\n\t\t\t// Don't send events if initalizing.\n\t\t\tif ( ! item._init) {\n\t\t\t\tif (transactions == 0 ) {\n\t\t\t\t\treturn can.trigger(item, event, args);\n\t\t\t\t} else {\n\t\t\t\t\tevent = typeof event === \"string\" ?\n\t\t\t\t\t\t{ type: event } : \n\t\t\t\t\t\tevent;\n\t\t\t\t\tevent.batchNum = batchNum;\n\t\t\t\t\tbatchEvents.push([\n\t\t\t\t\titem,\n\t\t\t\t\tevent, \n\t\t\t\t\targs ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/map',[\"can/util/library\", \"can/util/bind\", \"can/construct\", \"can/util/batch\"], function(can, bind) {\n\t// ## map.js  \n\t// `can.Map`  \n\t// _Provides the observable pattern for JavaScript Objects._  \n\t//  \n\t\t// Removes all listeners.\n\tvar\tbindToChildAndBubbleToParent = function(child, prop, parent){\n\t\t\tcan.listenTo.call(parent,child,\"change\", function( /* ev, attr */ ) {\n\t\t\t\t// `batchTrigger` the type on this...\n\t\t\t\tvar args = can.makeArray(arguments),\n\t\t\t\t\tev = args.shift();\n\t\t\t\t\targs[0] = (prop === \"*\" ? \n\t\t\t\t\t\t[ parent.indexOf( child ), args[0]] :\n\t\t\t\t\t\t[ prop, args[0]] ).join(\".\");\n\n\t\t\t\t// track objects dispatched on this map\t\t\n\t\t\t\tev.triggeredNS = ev.triggeredNS || {};\n\n\t\t\t\t// if it has already been dispatched exit\n\t\t\t\tif (ev.triggeredNS[parent._cid]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tev.triggeredNS[parent._cid] = true;\n\t\t\t\t// send change event with modified attr to parent\t\n\t\t\t\tcan.trigger(parent, ev, args);\n\t\t\t\t// send modified attr event to parent\n\t\t\t\t//can.trigger(parent, args[0], args);\n\t\t\t});\n\t\t},\n\t\t// An `id` to track events for a given map.\n\t\tobserveId = 0,\n\t\tattrParts = function(attr, keepKey) {\n\t\t\tif(keepKey) {\n\t\t\t\treturn [attr];\n\t\t\t}\n\t\t\treturn can.isArray(attr) ? attr : (\"\"+attr).split(\".\");\n\t\t},\n\t\tmakeBindSetup = function(wildcard){\n\t\t\treturn function(){\n\t\t\t\tvar parent = this;\n\t\t\t\tthis._each(function(child, prop){\n\t\t\t\t\tif(child && child.bind){\n\t\t\t\t\t\tbindToChildAndBubbleToParent(child, wildcard || prop, parent)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t};\n\t\t},\n\t\t// A map that temporarily houses a reference \n\t\t// to maps that have already been made for a plain ole JS object\n\t\tmadeMap = null,\n\t\tteardownMap = function(){\n\t\t\tfor(var cid in madeMap){\n\t\t\t\tif(madeMap[cid].added) {\n\t\t\t\t\tdelete madeMap[cid].obj._cid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmadeMap = null;\n\t\t},\n\t\tgetMapFromObject = function(obj){\n\t\t\treturn madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance\n\t\t};\n\t\t\n\t/**\n\t * @add can.Map\n\t */\n\t//\n\tvar Map = can.Map = can.Construct.extend( {\n\t/**\n\t * @static\n\t */\n\t\tsetup: function(){\n\n\t\t\tcan.Construct.setup.apply( this, arguments );\n\t\t\t\n\t\t\t\n\t\t\tif(can.Map){\n\t\t\t\tif(!this.defaults){\n\t\t\t\t\tthis.defaults = {};\n\t\t\t\t}\n\t\t\t\t// a list of the compute properties\n\t\t\t\tthis._computes = [];\n\t\t\t\tfor(var prop in this.prototype){\n\t\t\t\t\tif(typeof this.prototype[prop] !== \"function\"){\n\t\t\t\t\t\tthis.defaults[prop] = this.prototype[prop];\n\t\t\t\t\t} else if(this.prototype[prop].isComputed) {\n\t\t\t\t\t\tthis._computes.push(prop)\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if we inerit from can.Map, but not can.List\n\t\t\tif(can.List && !(this.prototype instanceof can.List) ){\n\t\t\t\tthis.List = Map.List({ Map : this }, {});\n\t\t\t}\n\t\n\t\t},\n\t\t_computes: [],\n\t\t// keep so it can be overwritten\n\t\tbind: can.bindAndSetup,\n\t\ton: can.bindAndSetup,\n\t\tunbind: can.unbindAndTeardown,\n\t\toff: can.unbindAndTeardown,\n\t\tid: \"id\",\n\t\thelpers: {\n\t\t\taddToMap: function(obj, instance){\n\t\t\t\tvar teardown;\n\t\t\t\tif(!madeMap){\n\t\t\t\t\tteardown = teardownMap;\n\t\t\t\t\tmadeMap = {}\n\t\t\t\t}\n\t\t\t\t// record if it has a Cid before we add one\n\t\t\t\tvar hasCid = obj._cid;\n\t\t\t\tvar cid = can.cid(obj);\n\t\t\t\t\n\t\t\t\t// only update if there already isn't one\n\t\t\t\tif( !madeMap[cid] ){\n\t\t\t\t\n\t\t\t\t\tmadeMap[cid] = {\n\t\t\t\t\t\tobj: obj,\n\t\t\t\t\t\tinstance: instance,\n\t\t\t\t\t\tadded: !hasCid\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn teardown;\n\t\t\t},\n\t\t\t\n\t\t\tcanMakeObserve : function( obj ) {\n\t\t\t\treturn obj && !can.isDeferred(obj) && (can.isArray(obj) || can.isPlainObject( obj ) || ( obj instanceof can.Map ));\n\t\t\t},\n\t\t\tunhookup: function(items, parent){\n\t\t\t\treturn can.each(items, function(item){\n\t\t\t\t\tif(item && item.unbind){\n\t\t\t\t\t\tcan.stopListening.call(parent, item,\"change\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// Listens to changes on `child` and \"bubbles\" the event up.  \n\t\t\t// `child` - The object to listen for changes on.  \n\t\t\t// `prop` - The property name is at on.  \n\t\t\t// `parent` - The parent object of prop.\n\t\t\t// `ob` - (optional) The Map object constructor\n\t\t\t// `list` - (optional) The observable list constructor\n\t\t\thookupBubble: function( child, prop, parent, Ob, List ) {\n\t\t\t\tOb = Ob || Map;\n\t\t\t\tList = List || Map.List;\n\t\n\t\t\t\t// If it's an `array` make a list, otherwise a child.\n\t\t\t\tif (child instanceof Map){\n\t\t\t\t\t// We have an `map` already...\n\t\t\t\t\t// Make sure it is not listening to this already\n\t\t\t\t\t// It's only listening if it has bindings already.\n\t\t\t\t\tparent._bindings && Map.helpers.unhookup([child], parent);\n\t\t\t\t} else if ( can.isArray(child) ) {\n\t\t\t\t\tchild = getMapFromObject(child) || new List(child);\n\t\t\t\t} else {\n\t\t\t\t\tchild = getMapFromObject(child) || new Ob(child);\n\t\t\t\t}\n\t\t\t\t// only listen if something is listening to you\n\t\t\t\tif(parent._bindings){\n\t\t\t\t\t// Listen to all changes and `batchTrigger` upwards.\n\t\t\t\t\tbindToChildAndBubbleToParent(child, prop, parent)\n\t\t\t\t}\n\t\t\t\t\n\t\n\t\t\t\treturn child;\n\t\t\t},\n\t\t\t// A helper used to serialize an `Map` or `Map.List`.  \n\t\t\t// `map` - The observable.  \n\t\t\t// `how` - To serialize with `attr` or `serialize`.  \n\t\t\t// `where` - To put properties, in an `{}` or `[]`.\n\t\t\tserialize: function( map, how, where ) {\n\t\t\t\t// Go through each property.\n\t\t\t\tmap.each(function( val, name ) {\n\t\t\t\t\t// If the value is an `object`, and has an `attrs` or `serialize` function.\n\t\t\t\t\twhere[name] = Map.helpers.canMakeObserve(val) && can.isFunction( val[how] ) ?\n\t\t\t\t\t// Call `attrs` or `serialize` to get the original data back.\n\t\t\t\t\tval[how]() :\n\t\t\t\t\t// Otherwise return the value.\n\t\t\t\t\tval;\n\t\t\t\t});\n\t\t\t\treturn where;\n\t\t\t},\n\t\t\tmakeBindSetup: makeBindSetup\n\t\t},\n\t\t\n\t\t// starts collecting events\n\t\t// takes a callback for after they are updated\n\t\t// how could you hook into after ejs\n\t\t/**\n\t\t * @function can.Map.keys keys\n\t\t * @parent can.Map.static\n\t\t * @description Iterate over the keys of an Map.\n\t\t * @signature `can.Map.keys(map)`\n\t\t * @param {can.Map} map the `can.Map` to get the keys from\n\t\t * @return {Array} array An array containing the keys from _map_.\n\t\t * \n\t\t * @body\n\t\t * `keys` iterates over an map to get an array of its keys.\n\t\t * \n\t\t * @codestart\n\t\t * var people = new can.Map({\n\t\t *     a: 'Alice',\n\t\t *     b: 'Bob',\n\t\t *     e: 'Eve'\n\t\t * });\n\t\t * \n\t\t * can.Map.keys(people); // ['a', 'b', 'e']\n\t\t * @codeend\n\t\t */\n\t\tkeys: function(map) {\n\t\t\tvar keys = [];\n\t\t\tcan.__reading && can.__reading(map, '__keys');\n\t\t\tfor(var keyName in map._data) {\n\t\t\t\tkeys.push(keyName);\n\t\t\t}\n\t\t\treturn keys;\n\t\t}\n\t},\n\t/**\n\t * @prototype\n\t */\n\t{\n\t\tsetup: function( obj ) {\n\t\t\t// `_data` is where we keep the properties.\n\t\t\tthis._data = {}\n\t\t\t/**\n\t\t\t * @property {String} can.Map.prototype._cid\n\t\t\t * @hide\n\t\t\t *\n\t\t\t * A globally unique ID for this `can.Map` instance.\n\t\t\t */\n\t\t\t// The namespace this `object` uses to listen to events.\n\t\t\tcan.cid(this, \".map\");\n\t\t\t// Sets all `attrs`.\n\t\t\tthis._init = 1;\n\t\t\tthis._setupComputes();\n\t\t\tvar teardownMapping = obj && can.Map.helpers.addToMap(obj, this);\n\t\t\t/**\n\t\t\t * @property {*} can.Map.prototype.DEFAULT-ATTR\n\t\t\t * \n\t\t\t * @description Specify a default property and value.\n\t\t\t * \n\t\t\t * @option {*} A value of any type other than a function that will\n\t\t\t * be set as the `DEFAULT-ATTR` attribute's value.\n\t\t\t * \n\t\t\t * @body\n\t\t\t * \n\t\t\t * ## Use\n\t\t\t * \n\t\t\t * When extending [can.Map], if a prototype property is not a function,\n\t\t\t * it is used as a default value on instances of the extended Map.  For example:\n\t\t\t * \n\t\t\t *     var Paginate = can.Map.extend({\n\t\t\t *       limit: 20,\n\t\t\t *       offset: 0,\n\t\t\t *       next: function(){\n\t\t\t *         this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n\t\t\t *       }  \n\t\t\t *     });\n\t\t\t * \n\t\t\t *     var paginate = new Paginate({limit: 30});\n\t\t\t * \n\t\t\t *     paginate.attr(\"offset\") //-> 0\n\t\t\t *     paginate.attr(\"limit\")  //-> 30\n\t\t\t * \n\t\t\t *     paginate.next();\n\t\t\t *     \n\t\t\t *     paginate.attr(\"offset\") //-> 30\n\t\t\t */\n\t\t\tvar data = can.extend( can.extend(true,{},this.constructor.defaults || {}), obj )\n\t\t\tthis.attr(data);\n\t\t\t\n\t\t\tteardownMapping && teardownMapping()\n\t\t\t\n\t\t\tthis.bind('change',can.proxy(this._changes,this));\n\t\t\t\n\t\t\tdelete this._init;\n\t\t},\n\t\t/**\n\t\t * @property {can.compute} can.Map.prototype.COMPUTE-ATTR\n\t\t * \n\t\t * @description Specify an attribute that is computed from other attributes.\n\t\t * \n\t\t * @option {can.compute} A compute that reads values on instances of the\n\t\t * map and returns a derived value.  The compute may also be a getter-setter\n\t\t * compute and able to be passed a value.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * When extending [can.Map], if a prototype property is a [can.compute]\n\t\t * it will setup that compute to behave like a normal attribute. This means\n\t\t * that it can be read and written to with [can.Map::attr attr] and bound to\n\t\t * with [can.Map::bind bind].  \n\t\t * \n\t\t * The following example makes a `fullName` attribute on `Person` maps:\n\t\t * \n\t\t *     var Person = can.Map.extend({\n\t\t *       fullName: can.compute(function(){\n\t\t *         return this.attr(\"first\")+\" \"+this.attr(\"last\")  \n\t\t *       })\n\t\t *     })\n\t\t *     \n\t\t *     var me = new Person({first: \"Justin\", last: \"Meyer\"})\n\t\t * \n\t\t *     me.attr(\"fullName\") //-> \"Justin Meyer\"\n\t\t *     \n\t\t *     me.bind(\"fullName\", function(ev, newValue, oldValue){\n\t\t *       newValue //-> Brian Moschel\n\t\t *       oldValue //-> Justin Meyer\n\t\t *     })\n\t\t *     \n\t\t *     me.attr({first: \"Brian\", last: \"Moschel\"})\n\t\t * \n\t\t * ## Getter / Setter computes\n\t\t * \n\t\t * A compute's setter will be called if [can.Map::attr attr] is\n\t\t * used to set the compute-property's value.\n\t\t * \n\t\t * The following makes `fullName` able to set `first` and `last`:\n\t\t * \n\t\t *     var Person = can.Map.extend({\n\t\t *       fullName: can.compute(function(newValue){\n\t\t *         if( arguments.length ) {\n\t\t *           var parts = newValue.split(\" \");\n\t\t *           this.attr({\n\t\t *             first: parts[0],\n\t\t *             last:  parts[1]\n\t\t *           });\n\t\t *            \n\t\t *         } else {\n\t\t *           return this.attr(\"first\")+\" \"+this.attr(\"last\");\n\t\t *         }\n\t\t *       })\n\t\t *     })\n\t\t *     \n\t\t *     var me = new Person({first: \"Justin\", last: \"Meyer\"})\n\t\t * \n\t\t *     me.attr(\"fullName\", \"Brian Moschel\") \n\t\t *     me.attr(\"first\") //-> \"Brian\"\n\t\t *     me.attr(\"last\")  //-> \"Moschel\"\n\t\t * \n\t\t * \n\t\t * ## Alternatives\n\t\t * \n\t\t * [can.Mustache] and [can.EJS] will automatically convert any function\n\t\t * read in the template to a can.compute. So, simply having a fullName\n\t\t * function like:\n\t\t * \n\t\t *     var Person = can.Map.extend({\n\t\t *       fullName: function(){\n\t\t *         return this.attr(\"first\")+\" \"+this.attr(\"last\")  \n\t\t *       }\n\t\t *     })\n\t\t *     var me = new Person({first: \"Justin\", last: \"Meyer\"})\n\t\t * \n\t\t * Will already be live-bound if read in a template like:\n\t\t * \n\t\t *     {{me.fullName}}\n\t\t *     <%= me.attr(\"fullName\") %>\n\t\t * \n\t\t * The [can.Map.setter setter] plugin can also provide similar functionality as\n\t\t * Getter/Setter computes.\n\t\t */\n\t\t_setupComputes: function(){\n\t\t\tvar computes = this.constructor._computes;\n\t\t\tthis._computedBindings = {};\n\t\t\tfor(var i = 0, len = computes.length, prop; i< len; i++) {\n\t\t\t\tprop = computes[i];\n\t\t\t\tthis[prop] = this[prop].clone(this);\n\t\t\t\tthis._computedBindings[prop] = {\n\t\t\t\t\tcount: 0\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_bindsetup: makeBindSetup(),\n\t\t_bindteardown: function(){\n\t\t\tvar self = this;\n\t\t\tthis._each(function(child){\n\t\t\t\tMap.helpers.unhookup([child], self)\n\t\t\t})\n\t\t},\n\t\t_changes: function(ev, attr, how,newVal, oldVal){\n\t\t\tcan.batch.trigger(this, {type:attr, batchNum: ev.batchNum}, [newVal,oldVal]);\n\t\t},\n\t\t_triggerChange: function(attr, how,newVal, oldVal){\n\t\t\tcan.batch.trigger(this,\"change\",can.makeArray(arguments))\n\t\t},\n\t\t// no live binding iterator\n\t\t_each: function(callback){\n\t\t\tvar data = this.__get();\n\t\t\tfor(var prop in data){\n\t\t\t\tif(data.hasOwnProperty(prop)){\n\t\t\t\t\tcallback(data[prop],prop)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.Map.prototype.attr attr\n\t\t * @description Get or set properties on an Map.\n\t\t * @signature `map.attr()`\n\t\t * \n\t\t * Gets a collection of all the properties in this `can.Map`.\n\t\t * \n\t\t * @return {Object<String, *>} an object with all the properties in this `can.Map`.\n\t\t * \n\t\t * @signature `map.attr(key)`\n\t\t * \n\t\t * Reads a property from this `can.Map`.\n\t\t * \n\t\t * @param {String} key the property to read\n\t\t * @return {*} the value assigned to _key_.\n\t\t *\n\t\t * @signature `map.attr(key, value)`\n\t\t * \n\t\t * Assigns _value_ to a property on this `can.Map` called _key_.\n\t\t * \n\t\t * @param {String} key the property to set\n\t\t * @param {*} the value to assign to _key_.\n\t\t * @return {can.Map} this Map, for chaining\n\t\t * \n\t\t * @signature `map.attr(obj[, removeOthers])`\n\t\t * \n\t\t * Assigns each value in _obj_ to a property on this `can.Map` named after the\n\t\t * corresponding key in _obj_, effectively merging _obj_ into the Map.\n\t\t * \n\t\t * @param {Object<String, *>} obj a collection of key-value pairs to set.\n\t\t * If any properties already exist on the `can.Map`, they will be overwritten.\n\t\t *\n\t\t * @param {bool} [removeOthers=false] whether to remove keys not present in _obj_.\n\t\t * To remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n\t\t *\n\t\t * @return {can.Map} this Map, for chaining\n\t\t * \n\t\t * @body\n\t\t * `attr` gets or sets properties on the `can.Map` it's called on. Here's a tour through\n\t\t * how all of its forms work:\n\t\t *\n\t\t * @codestart\n\t\t * var people = new can.Map({});\n\t\t * \n\t\t * // set a property:\n\t\t * people.attr('a', 'Alex');\n\t\t * \n\t\t * // get a property:\n\t\t * people.attr('a'); // 'Alex'\n\t\t *\n\t\t * // set and merge multiple properties:\n\t\t * people.attr({\n\t\t *     a: 'Alice',\n\t\t *     b: 'Bob'\n\t\t * });\n\t\t * \n\t\t * // get all properties:\n\t\t * people.attr(); // {a: 'Alice', b: 'Bob'}\n\t\t * \n\t\t * // set properties while removing others:\n\t\t * people.attr({\n\t\t *     b: 'Bill',\n\t\t *     e: 'Eve'\n\t\t * }, true);\n\t\t *\n\t\t * people.attr(); // {b: 'Bill', e: 'Eve'}\n\t\t * @codeend\n\t\t * \n\t\t * ## Deep properties\n\t\t * \n\t\t * `attr` can also set and read deep properties. All you have to do is specify\n\t\t * the property name as you normally would if you weren't using `attr`.\n\t\t * \n\t\t * @codestart\n\t\t * var people = new can.Map({names: {}});\n\t\t * \n\t\t * // set a property:\n\t\t * people.attr('names.a', 'Alice');\n\t\t * \n\t\t * // get a property:\n\t\t * people.attr('names.a'); // 'Alice'\n\t\t * people.names.attr('a'); // 'Alice'\n\t\t *\n\t\t * // get all properties:\n\t\t * people.attr(); // {names: {a: 'Alice'}}\n\t\t * @codeend\n\t\t * \n\t\t * Objects that are added to Observes become Observes themselves behind the scenes,\n\t\t * so changes to deep properties fire events at each level, and you can bind at any\n\t\t * level. As this example shows, all the same events are fired no matter what level\n\t\t * you call `attr` at:\n\t\t * \n\t\t * @codestart\n\t\t * var people = new can.Map({names: {}});\n\t\t *\n\t\t * people.bind('change', function(ev, attr, how, newVal, oldVal) {\n\t\t *   console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n\t\t *    console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * people.bind('names', function(ev, newVal, oldVal) {\n\t\t *     console.log('people names: ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t *\n\t\t * people.names.bind('a', function(ev, newVal, oldVal) {\n\t\t *     console.log('people.names a: ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * people.bind('names.a', function(ev, newVal, oldVal) {\n\t\t *     console.log('people names.a: ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n\t\t *                                  // people.names change: a, add, Alice, undefined\n\t\t *                                  // people.names a: Alice, undefined\n\t\t *                                  // people names.a: Alice, undefined\n\t\t * \n\t\t * people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n\t\t *                                  // people.names change: b, add, Bob, undefined\n\t\t *                                  // people.names b: Bob, undefined\n\t\t *                                  // people names.b: Bob, undefined\n\t\t * @codeend\n\t\t * \n\t\t * ## See also\n\t\t * \n\t\t * For information on the events that are fired on property changes and how\n\t\t * to listen for those events, see [can.Map.prototype.bind bind].\n\t\t */\n\t\tattr: function( attr, val ) {\n\t\t\t// This is super obfuscated for space -- basically, we're checking\n\t\t\t// if the type of the attribute is not a `number` or a `string`.\n\t\t\tvar type = typeof attr;\n\t\t\tif ( type !== \"string\" && type !== \"number\" ) {\n\t\t\t\treturn this._attrs(attr, val)\n\t\t\t} else if ( arguments.length === 1 ) {// If we are getting a value.\n\t\t\t\t// Let people know we are reading.\n\t\t\t\tcan.__reading && can.__reading(this, attr)\n\t\t\t\treturn this._get(attr)\n\t\t\t} else {\n\t\t\t\t// Otherwise we are setting.\n\t\t\t\tthis._set(attr, val);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.Map.prototype.each each\n\t\t * @description Call a function on each property of an Map.\n\t\t * @signature `map.each( callback(item, propName ) )`\n\t\t * \n\t\t * `each` iterates through the Map, calling a function\n\t\t * for each property value and key.\n\t\t * \n\t\t * @param {function(*,String)} callback(item,propName) the function to call for each property\n\t\t * The value and key of each property will be passed as the first and second\n\t\t * arguments, respectively, to the callback. If the callback returns false,\n\t\t * the loop will stop.\n\t\t * \n\t\t * @return {can.Map} this Map, for chaining\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var names = [];\n\t\t * new can.Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n\t\t *     names.push(value);\n\t\t * });\n\t\t * \n\t\t * names; // ['Alice', 'Bob', 'Eve']\n\t\t * \n\t\t * names = [];\n\t\t * new can.Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n\t\t *     names.push(value);\n\t\t *     if(key === 'b') {\n\t\t *         return false;\n\t\t *     }\n\t\t * });\n\t\t * \n\t\t * names; // ['Alice', 'Bob']\n\t\t * \n\t\t * @codeend\n\t\t */\n\t\teach: function() {\n\t\t\tcan.__reading && can.__reading(this, '__keys');\n\t\t\treturn can.each.apply(undefined, [this.__get()].concat(can.makeArray(arguments)))\n\t\t},\n\t\t/**\n\t\t * @function can.Map.prototype.removeAttr removeAttr\n\t\t * @description Remove a property from an Map.\n\t\t * @signature `map.removeAttr(attrName)`\n\t\t * @param {String} attrName the name of the property to remove\n\t\t * @return {*} the value of the property that was removed\n\t\t * \n\t\t * @body\n\t\t * `removeAttr` removes a property by name from an Map.\n\t\t * \n\t\t * @codestart\n\t\t * var people = new can.Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\t\t * \n\t\t * people.removeAttr('b'); // 'Bob'\n\t\t * people.attr();          // {a: 'Alice', e: 'Eve'}\n\t\t * @codeend\n\t\t * \n\t\t * Removing an attribute will cause a _change_ event to fire with `'remove'`\n\t\t * passed as the _how_ parameter and `undefined` passed as the _newVal_ to\n\t\t * handlers. It will also cause a _property name_ event to fire with `undefined`\n\t\t * passed as _newVal_. An in-depth description at these events can be found\n\t\t * under `[can.Map.prototype.attr attr]`.\n\t\t */\n\t\tremoveAttr: function( attr ) {\n\t\t\t\t// Info if this is List or not\n\t\t\tvar isList = can.List && this instanceof can.List,\n\t\t\t\t// Convert the `attr` into parts (if nested).\n\t\t\t\tparts = attrParts(attr),\n\t\t\t\t// The actual property to remove.\n\t\t\t\tprop = parts.shift(),\n\t\t\t\t// The current value.\n\t\t\t\tcurrent = isList ? this[prop] : this._data[prop];\n\n\t\t\t// If we have more parts, call `removeAttr` on that part.\n\t\t\tif ( parts.length ) {\n\t\t\t\treturn current.removeAttr(parts)\n\t\t\t} else {\n\t\t\t\tif(isList) {\n\t\t\t\t\tthis.splice(prop, 1)\n\t\t\t\t} else if( prop in this._data ){\n\t\t\t\t\t// Otherwise, `delete`.\n\t\t\t\t\tdelete this._data[prop];\n\t\t\t\t\t// Create the event.\n\t\t\t\t\tif (!(prop in this.constructor.prototype)) {\n\t\t\t\t\t\tdelete this[prop]\n\t\t\t\t\t}\n\t\t\t\t\t// Let others know the number of keys have changed\n\t\t\t\t\tcan.batch.trigger(this, \"__keys\");\n\t\t\t\t\tthis._triggerChange(prop, \"remove\", undefined, current);\n\n\t\t\t\t}\n\t\t\t\treturn current;\n\t\t\t}\n\t\t},\n\t\t// Reads a property from the `object`.\n\t\t_get: function( attr ) {\n\t\t\tvar value = typeof attr === 'string' && !!~attr.indexOf('.') && this.__get(attr);\n\t\t\tif(value) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\t// break up the attr (`\"foo.bar\"`) into `[\"foo\",\"bar\"]`\n\t\t\tvar parts = attrParts(attr),\n\t\t\t\t// get the value of the first attr name (`\"foo\"`)\n\t\t\t\tcurrent = this.__get(parts.shift());\n\t\t\t// if there are other attributes to read\n\t\t\treturn parts.length ? \n\t\t\t\t// and current has a value\n\t\t\t\tcurrent ?\n\t\t\t\t\t// lookup the remaining attrs on current\n\t\t\t\t\tcurrent._get(parts) : \n\t\t\t\t\t// or if there's no current, return undefined\n\t\t\t\t\tundefined \t\n\t\t\t\t: \n\t\t\t\t// if there are no more parts, return current\n\t\t\t\tcurrent;\n\t\t},\n\t\t// Reads a property directly if an `attr` is provided, otherwise\n\t\t// returns the \"real\" data object itself.\n\t\t__get: function( attr ) {\n\t\t\tif(attr){\n\t\t\t\tif(this[attr] && this[attr].isComputed && can.isFunction(this.constructor.prototype[attr])){\n\t\t\t\t\treturn this[attr]()\n\t\t\t\t} else {\n\t\t\t\t\treturn this._data[attr]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this._data;\n\t\t\t}\n\t\t},\n\t\t// Sets `attr` prop as value on this object where.\n\t\t// `attr` - Is a string of properties or an array  of property values.\n\t\t// `value` - The raw value to set.\n\t\t_set: function( attr, value, keepKey) {\n\t\t\t// Convert `attr` to attr parts (if it isn't already).\n\t\t\tvar parts = attrParts(attr, keepKey),\n\t\t\t\t// The immediate prop we are setting.\n\t\t\t\tprop = parts.shift(),\n\t\t\t\t// The current value.\n\t\t\t\tcurrent = this.__get(prop);\n\n\t\t\t// If we have an `object` and remaining parts.\n\t\t\tif ( Map.helpers.canMakeObserve(current) && parts.length ) {\n\t\t\t\t// That `object` should set it (this might need to call attr).\n\t\t\t\tcurrent._set(parts, value)\n\t\t\t} else if (!parts.length ) {\n\t\t\t\t// We're in \"real\" set territory.\n\t\t\t\tif(this.__convert){\n\t\t\t\t\tvalue = this.__convert(prop, value)\n\t\t\t\t}\n\t\t\t\tthis.__set(prop, value, current)\n\t\t\t} else {\n\t\t\t\tthrow \"can.Map: Object does not exist\"\n\t\t\t}\n\t\t},\n\t\t__set : function(prop, value, current){\n\t\t\n\t\t\t// Otherwise, we are setting it on this `object`.\n\t\t\t// TODO: Check if value is object and transform\n\t\t\t// are we changing the value.\n\t\t\tif ( value !== current ) {\n\t\t\t\t// Check if we are adding this for the first time --\n\t\t\t\t// if we are, we need to create an `add` event.\n\t\t\t\tvar changeType = this.__get().hasOwnProperty(prop) ? \"set\" : \"add\";\n\n\t\t\t\t// Set the value on data.\n\t\t\t\tthis.___set(prop,\n\n\t\t\t\t// If we are getting an object.\n\t\t\t\tMap.helpers.canMakeObserve(value) ?\n\n\t\t\t\t// Hook it up to send event.\n\t\t\t\tMap.helpers.hookupBubble(value, prop, this) :\n\t\t\t\t// Value is normal.\n\t\t\t\tvalue);\n\n\t\t\t\tif(changeType == \"add\"){\n\t\t\t\t\t// If there is no current value, let others know that\n\t\t\t\t\t// the the number of keys have changed\n\t\t\t\t\t\n\t\t\t\t\tcan.batch.trigger(this, \"__keys\", undefined);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t// `batchTrigger` the change event.\n\t\t\t\tthis._triggerChange(prop, changeType, value, current);\n\t\t\t\t\n\t\t\t\t//can.batch.trigger(this, prop, [value, current]);\n\t\t\t\t// If we can stop listening to our old value, do it.\n\t\t\t\tcurrent && Map.helpers.unhookup([current], this);\n\t\t\t}\n\n\t\t},\n\t\t// Directly sets a property on this `object`.\n\t\t___set: function( prop, val ) {\n\t\t\t\n\t\t\tif(this[prop] && this[prop].isComputed && can.isFunction(this.constructor.prototype[prop])){\n\t\t\t\tthis[prop](val);\n\t\t\t}\n\t\t\t\n\t\t\tthis._data[prop] = val;\n\t\t\t// Add property directly for easy writing.\n\t\t\t// Check if its on the `prototype` so we don't overwrite methods like `attrs`.\n\t\t\tif (!(can.isFunction(this.constructor.prototype[prop]))) {\n\t\t\t\tthis[prop] = val\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can.Map.prototype.bind bind\n\t\t * @description Bind event handlers to an Map.\n\t\t * \n\t\t * @signature `map.bind(eventType, handler)`\n\t\t * \n\t\t * @param {String} eventType the type of event to bind this handler to\n\t\t * @param {Function} handler the handler to be called when this type of event fires\n\t\t * The signature of the handler depends on the type of event being bound. See below\n\t\t * for details.\n\t\t * @return {can.Map} this Map, for chaining\n\t\t * \n\t\t * @body\n\t\t * `bind` binds event handlers to property changes on `can.Map`s. When you change\n\t\t * a property using `attr`, two events are fired on the Map, allowing other parts\n\t\t * of your application to map the changes to the object.\n\t\t *\n\t\t * ## The _change_ event\n\t\t * \n\t\t * The first event that is fired is the _change_ event. The _change_ event is useful\n\t\t * if you want to react to all changes on an Map.\n\t\t *\n\t\t * @codestart\n\t\t * var o = new can.Map({});\n\t\t * o.bind('change', function(ev, attr, how, newVal, oldVal) {\n\t\t *     console.log('Something changed.');\n\t\t * });\n\t\t * @codeend\n\t\t * \n\t\t * The parameters of the event handler for the _change_ event are:\n\t\t *\n\t\t * - _ev_ The event object.\n\t\t * - _attr_ Which property changed.\n\t\t * - _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n\t\t * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n\t\t * - _oldVal_ Thishe value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\t\t * \n\t\t * Here is a concrete tour through the _change_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var o = new can.Map({});\n\t\t * o.bind('change', function(ev, attr, how, newVal, oldVal) {\n\t\t *     console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n\t\t * o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n\t\t * o.attr({\n\t\t *     'a': 'Alice',      // [object Object], a, set, Alice, Adam\n\t\t *     'b': 'Bob'         // [object Object], b, add, Bob, undefined\n\t\t * });\n\t\t * o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\t\t * @codeend\n\t\t *\n\t\t * (See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\t\t * \n\t\t * ## The _property name_ event\n\t\t * \n\t\t * The second event that is fired is an event whose type is the same as the changed\n\t\t * property's name. This event is useful for noticing changes to a specific property.\n\t\t *\n\t\t * @codestart\n\t\t * var o = new can.Map({});\n\t\t * o.bind('a', function(ev, newVal, oldVal) {\n\t\t *     console.log('The value of a changed.');\n\t\t * });\n\t\t * @codeend\n\t\t * \n\t\t * The parameters of the event handler for the _property name_ event are:\n\t\t *\n\t\t * - _ev_ The event object.\n\t\t * - _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n\t\t * - _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\t\t * \n\t\t * Here is a concrete tour through the _property name_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var o = new can.Map({});\n\t\t * o.bind('a', function(ev, newVal, oldVal) {\n\t\t *     console.log(ev + ', ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n\t\t * o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n\t\t * o.attr({\n\t\t *     'a': 'Alice',      // [object Object], Alice, Adam\n\t\t *     'b': 'Bob' \n\t\t * });\n\t\t * o.removeAttr('a');     // [object Object], undefined, Alice\n\t\t * @codeend\n\t\t *\n\t\t * ## See also\n\t\t * \n\t\t * More information about changing properties on Observes can be found under\n\t\t * [can.Map.prototype.attr attr].\n\t\t * \n\t\t * For a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n\t\t */\n\t\tbind: function(eventName, handler){\n\t\t\tvar computedBinding = this._computedBindings && this._computedBindings[eventName]\n\t\t\tif( computedBinding ) {\n\t\t\t\tif( !computedBinding.count ) {\n\t\t\t\t\tcomputedBinding.count = 1;\n\t\t\t\t\tvar self =  this;\n\t\t\t\t\tcomputedBinding.handler = function(ev, newVal, oldVal){\n\t\t\t\t\t\tcan.batch.trigger(self, {type: eventName, batchNum: ev.batchNum}, [newVal, oldVal] )\n\t\t\t\t\t}\n\t\t\t\t\tthis[eventName].bind(\"change\", computedBinding.handler)\n\t\t\t\t} else {\n\t\t\t\t\tcomputedBinding.count++\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn can.bindAndSetup.apply(this, arguments);\n\t\t\t\n\t\t},\n\t\t/**\n\t\t * @function can.Map.prototype.unbind unbind\n\t\t * @description Unbind event handlers from an Map.\n\t\t * @signature `map.unbind(eventType[, handler])`\n\t\t * @param {String} eventType the type of event to unbind, exactly as passed to `bind`\n\t\t * @param {Function} [handler] the handler to unbind\n\t\t *\n\t\t * @body\n\t\t * `unbind` unbinds event handlers previously bound with [can.Map.prototype.bind|`bind`].\n\t\t * If no _handler_ is passed, all handlers for the given event type will be unbound.\n\t\t *\n\t\t * @codestart\n\t\t * var i = 0,\n\t\t *     increaseBy2 = function() { i += 2; },\n\t\t *     increaseBy3 = function() { i += 3; },\n\t\t *     o = new can.Map();\n\t\t *\n\t\t * o.bind('change', increaseBy2);\n\t\t * o.bind('change', increaseBy3);\n\t\t * o.attr('a', 'Alice');\n\t\t * i; // 5\n\t\t * \n\t\t * o.unbind('change', increaseBy2);\n\t\t * o.attr('b', 'Bob');\n\t\t * i; // 8\n\t\t *\n\t\t * o.unbind('change');\n\t\t * o.attr('e', 'Eve');\n\t\t * i; // 8\n\t\t * @codeend\n\t\t */\n\t\tunbind: function(eventName, handler){\n\t\t\tvar computedBinding = this._computedBindings && this._computedBindings[eventName]\n\t\t\tif( computedBinding ) {\n\t\t\t\tif( computedBinding.count == 1 ) {\n\t\t\t\t\tcomputedBinding.count = 0;\n\t\t\t\t\tthis[eventName].unbind(\"change\", computedBinding.handler);\n\t\t\t\t\tdelete computedBinding.handler;\n\t\t\t\t} else {\n\t\t\t\t\tcomputedBinding.count++\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn can.unbindAndTeardown.apply(this, arguments);\n\t\t\t\n\t\t},\n\t\t/**\n\t\t * @function can.Map.prototype.serialize serialize\n\t\t * @description Serialize this object to something that\n\t\t * can be passed to `JSON.stringify`.\n\t\t * @signature `map.serialize()`\n\t\t * \n\t\t * \n\t\t * Get the serialized Object form of the map.  Serialized\n\t\t * data is typically used to send back to a server.\n\t\t * \n\t\t *     o.serialize() //-> { name: 'Justin' }\n\t\t *     \n\t\t * Serialize currently returns the same data \n\t\t * as [can.Map.prototype.attrs].  However, in future\n\t\t * versions, serialize will be able to return serialized\n\t\t * data similar to [can.Model].  The following will work:\n\t\t * \n\t\t *     new Map({time: new Date()})\n\t\t *       .serialize() //-> { time: 1319666613663 }\n\t\t * \n\t\t * @return {Object} a JavaScript Object that can be \n\t\t * serialized with `JSON.stringify` or other methods. \n\t\t * \n\t\t */\n\t\tserialize: function() {\n\t\t\treturn can.Map.helpers.serialize(this, 'serialize', {});\n\t\t},\n\t\t/**\n\t\t * @hide\n\t\t * Set multiple properties on the observable\n\t\t * @param {Object} props\n\t\t * @param {Boolean} remove true if you should remove properties that are not in props\n\t\t */\n\t\t_attrs: function( props, remove ) {\n\n\t\t\tif ( props === undefined ) {\n\t\t\t\treturn Map.helpers.serialize(this, 'attr', {})\n\t\t\t}\n\n\t\t\tprops = can.simpleExtend({}, props);\n\t\t\tvar prop,\n\t\t\t\tself = this,\n\t\t\t\tnewVal;\n\t\t\tcan.batch.start();\n\t\t\tthis.each(function(curVal, prop){\n\t\t\t\t// you can not have a _cid property!\n\t\t\t\tif(prop === \"_cid\"){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnewVal = props[prop];\n\n\t\t\t\t// If we are merging...\n\t\t\t\tif ( newVal === undefined ) {\n\t\t\t\t\tremove && self.removeAttr(prop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(self.__convert){\n\t\t\t\t\tnewVal = self.__convert(prop, newVal)\n\t\t\t\t}\n\n\t\t\t\t// if we're dealing with models, want to call _set to let converter run\n\t\t\t\tif( newVal instanceof can.Map ) {\n\t\t\t\t\tself.__set(prop, newVal, curVal)\n\t\t\t\t// if its an object, let attr merge\n\t\t\t\t} else if ( Map.helpers.canMakeObserve(curVal) && Map.helpers.canMakeObserve(newVal) && curVal.attr ) {\n\t\t\t\t\tcurVal.attr(newVal, remove)\n\t\t\t\t// otherwise just set\n\t\t\t\t} else if ( curVal != newVal ) {\n\t\t\t\t\tself.__set(prop, newVal, curVal)\n\t\t\t\t}\n\n\t\t\t\tdelete props[prop];\n\t\t\t})\n\t\t\t// Add remaining props.\n\t\t\tfor ( var prop in props ) {\n\t\t\t\tif(prop !== \"_cid\"){\n\t\t\t\t\tnewVal = props[prop];\n\t\t\t\t\tthis._set(prop, newVal, true)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcan.batch.stop()\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * @function can.Map.prototype.compute compute\n\t\t * @description Make a can.compute from an observable property.\n\t\t * @signature `map.compute(attrName)`\n\t\t * @param {String} attrName the property to bind to\n\t\t * @return {can.compute} a [can.compute] bound to _attrName_\n\t\t *\n\t\t * @body\n\t\t * `compute` is a convenience method for making computes from properties\n\t\t * of Observes. More information about computes can be found under [can.compute].\n\t\t *\n\t\t * @codestart\n\t\t * var map = new can.Map({a: 'Alexis'});\n\t\t * var name = map.compute('a');\n\t\t * name.bind('change', function(ev, nevVal, oldVal) {\n\t\t *     console.log('a changed from ' + oldVal + 'to' + newName + '.');\n\t\t * });\n\t\t *\n\t\t * name(); // 'Alexis'\n\t\t * \n\t\t * map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n\t\t * name(); // 'Adam'\n\t\t *\n\t\t * name('Alice'); // 'a changed from Adam to Alice.'\n\t\t * name(); // 'Alice'\n\t\t */\n\t\tcompute: function(prop) {\n\t\t\tif(can.isFunction( this.constructor.prototype[prop] )){\n\t\t\t\treturn can.compute(this[prop], this);\n\t\t\t} else {\n\t\t\t\treturn can.compute(this,prop);\n\t\t\t}\n\t\t\t\n\t\t}\n\t});\n\t\n\tMap.prototype.on = Map.prototype.bind;\n\tMap.prototype.off = Map.prototype.unbind;\n\n\treturn Map;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/util/string/deparam',[\"can/util/library\", \"can/util/string\"], function( can ){\n\t\n\t// ## deparam.js  \n\t// `can.deparam`  \n\t// _Takes a string of name value pairs and returns a Object literal that represents those params._\n\tvar digitTest = /^\\d+$/,\n\t\tkeyBreaker = /([^\\[\\]]+)|(\\[\\])/g,\n\t\tparamTest = /([^?#]*)(#.*)?$/,\n\t\tprep = function( str ) {\n\t\t\treturn decodeURIComponent( str.replace(/\\+/g, \" \") );\n\t\t};\n\t\n\n\tcan.extend(can, { \n\t\tdeparam: function(params){\n\t\t\n\t\t\tvar data = {},\n\t\t\t\tpairs, lastPart;\n\n\t\t\tif ( params && paramTest.test( params )) {\n\t\t\t\t\n\t\t\t\tpairs = params.split('&'),\n\t\t\t\t\n\t\t\t\tcan.each( pairs, function( pair ) {\n\n\t\t\t\t\tvar parts = pair.split('='),\n\t\t\t\t\t\tkey   = prep( parts.shift() ),\n\t\t\t\t\t\tvalue = prep( parts.join(\"=\")),\n\t\t\t\t\t\tcurrent = data;\n\t\t\t\t\t\n\t\t\t\t\tif(key) {\n\t\t\t\t\t\tparts = key.match(keyBreaker);\n\t\t\t\t\n\t\t\t\t\t\tfor ( var j = 0, l = parts.length - 1; j < l; j++ ) {\n\t\t\t\t\t\t\tif (!current[parts[j]] ) {\n\t\t\t\t\t\t\t\t// If what we are pointing to looks like an `array`\n\t\t\t\t\t\t\t\tcurrent[parts[j]] = digitTest.test(parts[j+1]) || parts[j+1] == \"[]\" ? [] : {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent = current[parts[j]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastPart = parts.pop();\n\t\t\t\t\t\tif ( lastPart == \"[]\" ) {\n\t\t\t\t\t\t\tcurrent.push(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent[lastPart] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t});\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/route',[\"can/util/library\", \"can/map\", \"can/util/string/deparam\"], function(can) {\n\n\t// ## route.js  \n\t// `can.route`  \n\t// _Helps manage browser history (and client state) by synchronizing the \n\t// `window.location.hash` with a `can.Map`._  \n\t//   \n    // Helper methods used for matching routes.\n\tvar \n\t\t// `RegExp` used to match route variables of the type ':name'.\n        // Any word character or a period is matched.\n        matcher = /\\:([\\w\\.]+)/g,\n        // Regular expression for identifying &amp;key=value lists.\n        paramsMatcher = /^(?:&[^=]+=[^&]*)+/,\n        // Converts a JS Object into a list of parameters that can be \n        // inserted into an html element tag.\n\t\tmakeProps = function( props ) {\n\t\t\tvar tags = [];\n\t\t\tcan.each(props, function(val, name){\n\t\t\t\ttags.push( ( name === 'className' ? 'class'  : name )+ '=\"' + \n\t\t\t\t\t\t(name === \"href\" ? val : can.esc(val) ) + '\"');\n\t\t\t});\n\t\t\treturn tags.join(\" \");\n\t\t},\n\t\t// Checks if a route matches the data provided. If any route variable\n        // is not present in the data, the route does not match. If all route\n        // variables are present in the data, the number of matches is returned \n        // to allow discerning between general and more specific routes. \n\t\tmatchesData = function(route, data) {\n\t\t\tvar count = 0, i = 0, defaults = {};\n\t\t\t// look at default values, if they match ...\n\t\t\tfor( var name in route.defaults ) {\n\t\t\t\tif(route.defaults[name] === data[name]){\n\t\t\t\t\t// mark as matched\n\t\t\t\t\tdefaults[name] = 1;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; i < route.names.length; i++ ) {\n\t\t\t\tif (!data.hasOwnProperty(route.names[i]) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif(!defaults[route.names[i]]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn count;\n\t\t},\n\t\tonready = !0,\n\t\tlocation = window.location,\n\t\twrapQuote = function(str) {\n\t\t\treturn (str+'').replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, \"\\\\$1\");\n\t\t},\n\t\teach = can.each,\n\t\textend = can.extend,\n\t\t    // Helper for convert any object (or value) to stringified object (or value)\n\t\tstringify = function(obj) {\n\t\t\t// Object is array, plain object, Map or List\n\t\t\tif(obj && typeof obj === \"object\") {\n\t\t\t\t// Get native object or array from Map or List\n\t\t\t\tif(obj instanceof can.Map) {\n\t\t\t\t\tobj = obj.attr()\n\t\t\t\t// Clone object to prevent change original values\n\t\t\t\t} else {\n\t\t\t\t\tobj = can.isFunction(obj.slice) ? obj.slice() : can.extend({}, obj)\n\t\t\t\t}\n\t\t\t\t// Convert each object property or array item into stringified new\n\t\t\t\tcan.each(obj, function(val, prop) { obj[prop] = stringify(val) })\n\t\t\t// Object supports toString function\n\t\t  } else if(obj !== undefined && obj !== null && can.isFunction(obj.toString)) {\n        obj = obj.toString()\n      }\n\n\t\t\treturn obj\n\t\t},\n\t\tremoveBackslash = function(str){\n\t\t\treturn str.replace(/\\\\/g,\"\")\n\t\t},\n\t\t// A ~~throttled~~ debounced function called multiple times will only fire once the\n        // timer runs down. Each call resets the timer.\n\t\ttimer,\n        // Intermediate storage for `can.route.data`.\n        curParams,\n\t\t// The last hash caused by a data change\n\t\tlastHash,\n\t\t// Are data changes pending that haven't yet updated the hash\n\t\tchangingData,\n\t\t// If the `can.route.data` changes, update the hash.\n\t    // Using `.serialize()` retrieves the raw data contained in the `observable`.\n\t    // This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.\n\t    // This might be able to use batchNum and avoid this.\n\t\tonRouteDataChange = function(ev, attr, how, newval) {\n\t\t\t// indicate that data is changing\n\t\t\tchangingData = 1;\n\t\t\tclearTimeout( timer );\n\t\t\ttimer = setTimeout(function() {\n\t\t\t\t// indicate that the hash is set to look like the data\n\t\t\t\tchangingData = 0;\n\t\t\t\tvar serialized = can.route.data.serialize(),\n\t\t\t\t\tpath = can.route.param(serialized, true);\n\t\t\t\tcan.route._call(\"setURL\",path);\n\t\t\t\t\n\t\t\t\tlastHash = path\n\t\t\t}, 10);\n\t\t};\n\n\n\tcan.route = function( url, defaults ) {\n        // if route ends with a / and url starts with a /, remove the leading / of the url\n        var root = can.route._call(\"root\");\n        \n        if(root.lastIndexOf(\"/\") == root.length - 1 &&\n        \turl.indexOf(\"/\") === 0) {\n        \turl = url.substr(1);\n        }\n        \n        \n        defaults = defaults || {};\n        // Extract the variable names and replace with `RegExp` that will match\n\t\t// an atual URL with values.\n\t\tvar names = [],\n\t\t\tres,\n\t\t\ttest = \"\",\n\t\t\tlastIndex = matcher.lastIndex = 0,\n\t\t\tnext,\n\t\t\tquerySeparator = can.route._call(\"querySeparator\");\n\t\t\t\n\t\t// res will be something like [\":foo\",\"foo\"]\n\t\twhile(res = matcher.exec(url)){\n\t\t\tnames.push(res[1]);\n\t\t\ttest += removeBackslash( url.substring(lastIndex, matcher.lastIndex - res[0].length) );\n\t\t\tnext = \"\\\\\"+( removeBackslash(url.substr(matcher.lastIndex,1)) || querySeparator );\n\t\t\t// a name without a default value HAS to have a value\n\t\t\t// a name that has a default value can be empty\n\t\t\t// The `\\\\` is for string-escaping giving single `\\` for `RegExp` escaping.\n\t\t\ttest += \"([^\" +next+\"]\"+(defaults[res[1]] ? \"*\" : \"+\")+\")\";\n\t\t\tlastIndex = matcher.lastIndex;\n\t\t}\n\t\ttest += url.substr(lastIndex).replace(\"\\\\\",\"\")\n\t\t// Add route in a form that can be easily figured out.\n\t\tcan.route.routes[url] = {\n            // A regular expression that will match the route when variable values \n            // are present; i.e. for `:page/:type` the `RegExp` is `/([\\w\\.]*)/([\\w\\.]*)/` which\n            // will match for any value of `:page` and `:type` (word chars or period).\n\t\t\ttest: new RegExp(\"^\" + test+\"($|\"+wrapQuote(querySeparator)+\")\"),\n            // The original URL, same as the index for this entry in routes.\n\t\t\troute: url,\n            // An `array` of all the variable names in this route.\n\t\t\tnames: names,\n            // Default values provided for the variables.\n\t\t\tdefaults: defaults,\n            // The number of parts in the URL separated by `/`.\n\t\t\tlength: url.split('/').length\n\t\t};\n\t\treturn can.route;\n\t};\n\n\t/**\n\t * @static\n\t */\n\textend(can.route, {\n\t\t\n\t\t/**\n\t\t * @function can.route.param param\n\t\t * @parent can.route.static\n\t\t * @description Get a route path from given data.\n\t\t * @signature `can.route.param( data )`\n\t\t * @param {data} object The data to populate the route with.\n\t\t * @return {String} The route, with the data populated in it.\n\t\t *\n\t\t * @body\n\t\t * Parameterizes the raw JS object representation provided in data.\n\t\t *\n\t\t *     can.route.param( { type: \"video\", id: 5 } ) \n\t\t *          // -> \"type=video&id=5\"\n\t\t *\n\t\t * If a route matching the provided data is found, that URL is built\n\t\t * from the data. Any remaining data is added at the end of the\n\t\t * URL as &amp; separated key/value parameters.\n\t\t *\n\t\t *     can.route(\":type/:id\")\n\t\t *     \n\t\t *     can.route.param( { type: \"video\", id: 5 } ) // -> \"video/5\"\n\t\t *     can.route.param( { type: \"video\", id: 5, isNew: false } ) \n\t\t *          // -> \"video/5&isNew=false\"\n\t\t */\n\t\tparam: function( data , _setRoute ) {\n\t\t\t// Check if the provided data keys match the names in any routes;\n\t\t\t// Get the one with the most matches.\n\t\t\tvar route,\n\t\t\t\t// Need to have at least 1 match.\n\t\t\t\tmatches = 0,\n\t\t\t\tmatchCount,\n\t\t\t\trouteName = data.route,\n\t\t\t\tpropCount = 0;\n\t\t\t\t\n\t\t\tdelete data.route;\n\t\t\t\n\t\t\teach(data, function(){\n\t\t\t\tpropCount++;\n\t\t\t});\n\t\t\t// Otherwise find route.\n\t\t\teach(can.route.routes, function(temp, name){\n\t\t\t\t// best route is the first with all defaults matching\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmatchCount = matchesData(temp, data);\n\t\t\t\tif ( matchCount > matches ) {\n\t\t\t\t\troute = temp;\n\t\t\t\t\tmatches = matchCount;\n\t\t\t\t}\n\t\t\t\tif(matchCount >= propCount){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// If we have a route name in our `can.route` data, and it's\n\t\t\t// just as good as what currently matches, use that\n\t\t\tif (can.route.routes[routeName] && matchesData(can.route.routes[routeName], data ) === matches) {\n\t\t\t\troute = can.route.routes[routeName];\n\t\t\t}\n\t\t\t// If this is match...\n\t\t\tif ( route ) {\n\t\t\t\tvar cpy = extend({}, data),\n                    // Create the url by replacing the var names with the provided data.\n                    // If the default value is found an empty string is inserted.\n\t\t\t\t\tres = route.route.replace(matcher, function( whole, name ) {\n                        delete cpy[name];\n                        return data[name] === route.defaults[name] ? \"\" : encodeURIComponent( data[name] );\n                    }).replace(\"\\\\\",\"\"),\n                    after;\n\t\t\t\t// Remove matching default values\n\t\t\t\teach(route.defaults, function(val,name){\n\t\t\t\t\tif(cpy[name] === val) {\n\t\t\t\t\t\tdelete cpy[name];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// The remaining elements of data are added as \n\t\t\t\t// `&amp;` separated parameters to the url.\n\t\t\t\tafter = can.param(cpy);\n\t\t\t\t// if we are paraming for setting the hash\n\t\t\t\t// we also want to make sure the route value is updated\n\t\t\t\tif(_setRoute){\n\t\t\t\t\tcan.route.attr('route',route.route);\n\t\t\t\t}\n\t\t\t\treturn res + (after ? can.route._call(\"querySeparator\") + after : \"\");\n\t\t\t}\n            // If no route was found, there is no hash URL, only paramters.\n\t\t\treturn can.isEmptyObject(data) ? \"\" : can.route._call(\"querySeparator\") + can.param(data);\n\t\t},\n\t\t/**\n\t\t * @function can.route.deparam deparam\n\t\t * @parent can.route.static\n\t\t * @description Extract data from a route path.\n\t\t * @signature `can.route.deparam( url )`\n\t\t * @param {String} url A route fragment to extract data from.\n\t\t * @return {Object} An object containing the extracted data.\n\t\t * \n\t\t * @body\n\t\t * Creates a data object based on the query string passed into it. This is \n\t\t * useful to create an object based on the `location.hash`.\n\t\t *\n\t\t *     can.route.deparam(\"id=5&type=videos\") \n\t\t *          // -> { id: 5, type: \"videos\" }\n\t\t *\n\t\t * \n\t\t * It's important to make sure the hash or exclamantion point is not passed\n\t\t * to `can.route.deparam` otherwise it will be included in the first property's\n\t\t * name.\n\t\t *\n\t\t *     can.route.attr(\"id\", 5) // location.hash -> #!id=5\n\t\t *     can.route.attr(\"type\", \"videos\") \n\t\t *          // location.hash -> #!id=5&type=videos\n\t\t *     can.route.deparam(location.hash) \n\t\t *          // -> { #!id: 5, type: \"videos\" }\n\t\t *\n\t\t * `can.route.deparam` will try and find a matching route and, if it does,\n\t\t * will deconstruct the URL and parse our the key/value parameters into the data object.\n\t\t *\n\t\t *     can.route(\":type/:id\")\n\t\t *\n\t\t *     can.route.deparam(\"videos/5\");\n\t\t *          // -> { id: 5, route: \":type/:id\", type: \"videos\" }\n\t\t */\n\t\tdeparam: function( url ) {\n\t\t\t\n\t\t\t// remove the url\n\t\t\tvar root = can.route._call(\"root\");\n\t        if(root.lastIndexOf(\"/\") == root.length - 1 &&\n\t        \turl.indexOf(\"/\") === 0) {\n\t        \turl = url.substr(1);\n\t        }\n\t\t\t\n\t\t\t// See if the url matches any routes by testing it against the `route.test` `RegExp`.\n            // By comparing the URL length the most specialized route that matches is used.\n\t\t\tvar route = {\n\t\t\t\tlength: -1\n\t\t\t},\n\t\t\t\tquerySeparator = can.route._call(\"querySeparator\"),\n\t\t\t\tparamsMatcher = can.route._call(\"paramsMatcher\");\n\t\t\t\t\n\t\t\teach(can.route.routes, function(temp, name){\n\t\t\t\tif ( temp.test.test(url) && temp.length > route.length ) {\n\t\t\t\t\troute = temp;\n\t\t\t\t}\n\t\t\t});\n            // If a route was matched.\n\t\t\tif ( route.length > -1 ) { \n\n\t\t\t\tvar // Since `RegExp` backreferences are used in `route.test` (parens)\n                    // the parts will contain the full matched string and each variable (back-referenced) value.\n                    parts = url.match(route.test),\n                    // Start will contain the full matched string; parts contain the variable values.\n\t\t\t\t\tstart = parts.shift(),\n                    // The remainder will be the `&amp;key=value` list at the end of the URL.\n\t\t\t\t\tremainder = url.substr(start.length - (parts[parts.length-1] === querySeparator ? 1 : 0) ),\n                    // If there is a remainder and it contains a `&amp;key=value` list deparam it.\n                    obj = (remainder && paramsMatcher.test(remainder)) ? can.deparam( remainder.slice(1) ) : {};\n\n                // Add the default values for this route.\n\t\t\t\tobj = extend(true, {}, route.defaults, obj);\n                // Overwrite each of the default values in `obj` with those in \n\t\t\t\t// parts if that part is not empty.\n\t\t\t\teach(parts,function(part,  i){\n\t\t\t\t\tif ( part && part !== querySeparator ) {\n\t\t\t\t\t\tobj[route.names[i]] = decodeURIComponent( part );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tobj.route = route.route;\n\t\t\t\treturn obj;\n\t\t\t}\n            // If no route was matched, it is parsed as a `&amp;key=value` list.\n\t\t\tif ( url.charAt(0) !== querySeparator ) {\n\t\t\t\turl = querySeparator + url;\n\t\t\t}\n\t\t\treturn paramsMatcher.test(url) ? can.deparam( url.slice(1) ) : {};\n\t\t},\n\t\t/**\n\t\t * @hide\n\t\t * A can.Map that represents the state of the history.\n\t\t */\n\t\tdata: new can.Map({}),\n        /**\n         * @property {Object} routes\n\t\t * @hide\n\t\t * \n         * A list of routes recognized by the router indixed by the url used to add it.\n         * Each route is an object with these members:\n         * \n\t\t *  - test - A regular expression that will match the route when variable values \n         *    are present; i.e. for :page/:type the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n         *    will match for any value of :page and :type (word chars or period).\n\t\t * \n         *  - route - The original URL, same as the index for this entry in routes.\n         * \n\t\t *  - names - An array of all the variable names in this route\n         * \n\t\t *  - defaults - Default values provided for the variables or an empty object.\n         * \n\t\t *  - length - The number of parts in the URL separated by '/'.\n         */\n\t\troutes: {},\n\t\t/**\n\t\t * @function can.route.ready ready\n\t\t * @parent can.route.static\n\t\t * \n\t\t * Initialize can.route.\n\t\t * \n\t\t * @signature `can.route.ready()`\n\t\t * \n\t\t * Sets up the two-way binding between the hash and the can.route observable map and\n\t\t * sets the can.route map to its initial values.\n\t\t * \n\t\t * @return {can.route} The `can.route` object.\n\t\t *\n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * After setting all your routes, call can.route.ready().\n\t\t * \n\t\t *     can.route(\"overview/:dateStart-:dateEnd\");\n\t\t *     can.route(\":type/:id\")\n\t\t *     can.route.ready()\n\t\t */\n\t\tready: function(val) {\n\t\t\tif( val !== true ) {\n\t\t\t\tcan.route._setup();\n\t\t\t\tcan.route.setState();\n\t\t\t}\n\t\t\treturn can.route;\n\t\t},\n\t\t/**\n\t\t * @function can.route.url url\n\t\t * @parent can.route.static\n\t\t * @signature `can.route.url( data [, merge] )`\n\t\t * \n\t\t * Make a URL fragment that when set to window.location.hash will update can.route's properties\n\t\t * to match those in `data`.\n\t\t * \n\t\t * @param {Object} data The data to populate the route with.\n\t\t * @param {Boolean} [merge] Whether the given options should be merged into the current state of the route.\n\t\t * @return {String} The route URL and query string.\n\t\t *\n\t\t * @body \n\t\t * Similar to [can.route.link], but instead of creating an anchor tag, `can.route.url` creates \n\t\t * only the URL based on the route options passed into it.\n\t\t *\n\t\t *     can.route.url( { type: \"videos\", id: 5 } ) \n\t\t *          // -> \"#!type=videos&id=5\"\n\t\t *\n\t\t * If a route matching the provided data is found the URL is built from the data. Any remaining\n\t\t * data is added at the end of the URL as & separated key/value parameters.\n\t\t *\n\t\t *     can.route(\":type/:id\")\n\t\t *\n\t\t *     can.route.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\n\t\t *     can.route.url( { type: \"video\", id: 5, isNew: false } ) \n\t\t *          // -> \"#!video/5&isNew=false\"\n\t\t */\n\t\turl: function( options, merge ) {\n\t\t\t\n\t\t\tif (merge) {\n                options = can.extend({}, can.route.deparam( can.route._call(\"matchingPartOfURL\")), options);\n            }\n            return can.route._call(\"root\") + can.route.param(options);\n\t\t},\n\t\t/**\n\t\t * @function can.route.link link\n\t\t * @parent can.route.static\n\t\t * @signature `can.route.link( innerText, data, props [, merge] )`\n\t\t * \n\t\t * Make an anchor tag (`<A>`) that when clicked on will update can.route's properties\n\t\t * to match those in `data`.\n\t\t * \n\t\t * @param {Object} innerText The text inside the link.\n\t\t * @param {Object} data The data to populate the route with.\n\t\t * @param {Object} props Properties for the anchor other than `href`.\n\t\t * @param {Boolean} [merge] Whether the given options should be merged into the current state of the route.\n\t\t * @return {String} A string with an anchor tag that points to the populated route.\n\t\t * \n\t\t * @body\n\t\t * Creates and returns an anchor tag with an href of the route \n\t\t * attributes passed into it, as well as any properies desired\n\t\t * for the tag.\n\t\t *\n\t\t *     can.route.link( \"My videos\", { type: \"videos\" }, {}, false )\n\t\t *          // -> <a href=\"#!type=videos\">My videos</a>\n\t\t * \n\t\t * Other attributes besides href can be added to the anchor tag\n\t\t * by passing in a data object with the attributes desired.\n\t\t *\n\t\t *     can.route.link( \"My videos\", { type: \"videos\" }, \n\t\t *       { className: \"new\" }, false ) \n\t\t *          // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n\t\t *\n\t\t * It is possible to utilize the current route options when making anchor\n\t\t * tags in order to make your code more reusable. If merge is set to true,\n\t\t * the route options passed into `can.route.link` will be passed into the\n\t\t * current ones.\n\t\t *\n\t\t *     location.hash = \"#!type=videos\" \n\t\t *     can.route.link( \"The zoo\", { id: 5 }, true )\n\t\t *          // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\t\t *\n\t\t *     location.hash = \"#!type=pictures\" \n\t\t *     can.route.link( \"The zoo\", { id: 5 }, true )\n\t\t *          // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n\t\t *\n\t\t *\n\t\t */\n\t\tlink: function( name, options, props, merge ) {\n\t\t\treturn \"<a \" + makeProps(\n\t\t\textend({\n\t\t\t\thref: can.route.url(options, merge)\n\t\t\t}, props)) + \">\" + name + \"</a>\";\n\t\t},\n\t\t/**\n\t\t * @function can.route.current current\n\t\t * @parent can.route.static\n\t\t * @signature `can.route.current( data )`\n\t\t * \n\t\t * Check if data represents the current route.\n\t\t * \n\t\t * @param {Object} data Data to check agains the current route.\n         * @return {Boolean} Whether the data matches the current URL.\n\t\t * \n\t\t * @body\n\t\t * Checks the page's current URL to see if the route represents the options passed \n\t\t * into the function.\n\t\t *\n\t\t * Returns true if the options respresent the current URL.\n\t\t * \n\t\t *     can.route.attr('id', 5) // location.hash -> \"#!id=5\"\n\t\t *     can.route.current({ id: 5 }) // -> true\n\t\t *     can.route.current({ id: 5, type: 'videos' }) // -> false\n\t\t *     \n\t\t *     can.route.attr('type', 'videos') \n\t\t *            // location.hash -> #!id=5&type=videos\n\t\t *     can.route.current({ id: 5, type: 'videos' }) // -> true\n\t\t */\n\t\tcurrent: function( options ) {\n\t\t\treturn this._call(\"matchingPartOfURL\") === can.route.param(options);\n\t\t},\n\t\tbindings: {\n\t\t\thashchange : {\n\t\t\t\tparamsMatcher: paramsMatcher,\n\t\t\t\tquerySeparator: \"&\",\n\t\t\t\tbind: function(){\n\t\t\t\t\tcan.bind.call(window,'hashchange', setState);\n\t\t\t\t},\n\t\t\t\tunbind: function(){\n\t\t\t\t\tcan.unbind.call(window,'hashchange', setState);\n\t\t\t\t},\n\t\t\t\t// Gets the part of the url we are determinging the route from.\n\t\t\t\t// For hashbased routing, it's everything after the #, for\n\t\t\t\t// pushState it's configurable\n\t\t\t\tmatchingPartOfURL: function() {\n\t\t\t\t\treturn location.href.split(/#!?/)[1] || \"\";\n\t\t\t\t},\n\t\t\t\t// gets called with the serialized can.route data after a route has changed\n\t\t\t\t// returns what the url has been updated to (for matching purposes)\n\t\t\t\tsetURL: function(path) {\n\t\t\t\t\tlocation.hash = \"#!\" + path;\n\t\t\t\t\treturn path;\n\t\t\t\t},\n\t\t\t\troot: \"#!\"\n\t\t\t}\n\t\t},\n\t\tdefaultBinding: \"hashchange\",\n\t\tcurrentBinding: null,\n\t\t// ready calls setup\n\t\t// setup binds and listens to data changes\n\t\t\t// bind listens to whatever you should be listening to\n\t\t\t// data changes tries to set the path\n\t\t\n\t\t// we need to be able to\n\t\t// easily kick off calling setState\n\t\t// \tteardown whatever is there\n\t\t//  turn on a particular binding\n\t\t\n\t\t// called when the route is ready\n\t\t_setup: function() {\n\t\t\tif(!can.route.currentBinding){\n\t\t\t\tcan.route._call(\"bind\");\n\t\t\t\tcan.route.bind(\"change\", onRouteDataChange);\n\t\t\t\tcan.route.currentBinding = can.route.defaultBinding;\n\t\t\t}\n\t\t},\n\t\t_teardown: function(){\n\t\t\tif( can.route.currentBinding ) {\n\t\t\t\tcan.route._call(\"unbind\");\n\t\t\t\tcan.route.unbind(\"change\", onRouteDataChange);\n\t\t\t\tcan.route.currentBinding = null;\n\t\t\t}\n\t\t\tclearTimeout(timer);\n\t\t\tchangingData = 0;\n\t\t},\n\t\t// a helper to get stuff from the current or default bindings\n\t\t_call: function(){\n\t\t\tvar args = can.makeArray(arguments),\n\t\t\t\tprop = args.shift(),\n\t\t\t\tbinding = can.route.bindings[can.route.currentBinding || can.route.defaultBinding]\n\t\t\t\tmethod = binding[prop];\n\t\t\tif(typeof method === \"function\"){\n\t\t\t\treturn method.apply(binding,args)\n\t\t\t} else {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t});\n\t\n\t\n    // The functions in the following list applied to `can.route` (e.g. `can.route.attr('...')`) will\n    // instead act on the `can.route.data` observe.\n\teach(['bind','unbind','on','off','delegate','undelegate','removeAttr', 'compute', '_get', '__get'], function(name){\n\t\tcan.route[name] = function(){\n\t\t\t// `delegate` and `undelegate` require\n\t\t\t// the `can/map/delegate` plugin\n\t\t\tif(!can.route.data[name]) {\n            \treturn;\n\t\t\t}\n\n\t\t\treturn can.route.data[name].apply(can.route.data, arguments);\n\t\t}\n\t})\n\n\t// Because everything in hashbang is in fact a string this will automaticaly convert new values to string. Works with single value, or deep hashes.\n  // Main motivation for this is to prevent double route event call for same value.\n  // Example (the problem):\n  // When you load page with hashbang like #!&some_number=2 and bind 'some_number' on routes.\n  // It will fire event with adding of \"2\" (string) to 'some_number' property\n  // But when you after this set can.route.attr({some_number: 2}) or can.route.attr('some_number', 2). it fires another event with change of 'some_number' from \"2\" (string) to 2 (integer)\n  // This wont happen again with this normalization\n\tcan.route.attr = function(attr, val) {\n\t\tvar type = typeof attr,\n\t\t\t\tnewArguments;\n\n\t\t// Reading\n\t\tif(val === undefined) {\n\t\t\tnewArguments = arguments;\n\t\t// Sets object\n\t\t} else if (type !== \"string\" && type !== \"number\") {\n\t\t\tnewArguments = [stringify(attr), val];\n\t\t// Sets key - value\n\t\t} else {\n\t\t\tnewArguments = [attr, stringify(val)];\n\t\t}\n\n\t\treturn can.route.data.attr.apply(can.route.data, newArguments)\n\t}\n\n\tvar // Deparameterizes the portion of the hash of interest and assign the\n        // values to the `can.route.data` removing existing values no longer in the hash.\n        // setState is called typically by hashchange which fires asynchronously\n        // So it's possible that someone started changing the data before the \n        // hashchange event fired.  For this reason, it will not set the route data\n        // if the data is changing or the hash already matches the hash that was set.\n        setState = can.route.setState = function() {\n\t\t\tvar hash = can.route._call(\"matchingPartOfURL\");\n\t\t\tcurParams = can.route.deparam( hash );\n\t\t\t\n\t\t\t// if the hash data is currently changing, or\n\t\t\t// the hash is what we set it to anyway, do NOT change the hash\n\t\t\tif(!changingData || hash !== lastHash){\n\t\t\t\tcan.route.attr(curParams, true);\n\t\t\t}\n\t\t};\n\t\t\n\t\n\n\t\n\n\treturn can.route;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/control',[\"can/util/library\", \"can/construct\"], function( can ) {\n\t// ## control.js\n\t// `can.Control`  \n\t// _Controller_\n\t\n\t// Binds an element, returns a function that unbinds.\n\tvar bind = function( el, ev, callback ) {\n\n\t\t\tcan.bind.call( el, ev, callback );\n\n\t\t\treturn function() {\n\t\t\t\tcan.unbind.call(el, ev, callback);\n\t\t\t};\n\t\t},\n\t\tisFunction = can.isFunction,\n\t\textend = can.extend,\n\t\teach = can.each,\n\t\tslice = [].slice,\n\t\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\t\tspecial = can.getObject(\"$.event.special\", [can]) || {},\n\n\t\t// Binds an element, returns a function that unbinds.\n\t\tdelegate = function( el, selector, ev, callback ) {\n\t\t\tcan.delegate.call(el, selector, ev, callback);\n\t\t\treturn function() {\n\t\t\t\tcan.undelegate.call(el, selector, ev, callback);\n\t\t\t};\n\t\t},\n\t\t\n\t\t// Calls bind or unbind depending if there is a selector.\n\t\tbinder = function( el, ev, callback, selector ) {\n\t\t\treturn selector ?\n\t\t\t\tdelegate( el, can.trim( selector ), ev, callback ) : \n\t\t\t\tbind( el, ev, callback );\n\t\t},\n\t\t\n\t\tbasicProcessor;\n\n\tvar Control = can.Control = can.Construct(\n\t/**\n\t * @add can.Control\n\t */\n\t//\n\t/** \n\t * @static\n\t */\n\t{\n\t\t// Setup pre-processes which methods are event listeners.\n\t\t/**\n\t\t * @hide\n\t\t * \n\t\t * Setup pre-process which methods are event listeners.\n\t\t * \n\t\t */\n\t\tsetup: function() {\n\n\t\t\t// Allow contollers to inherit \"defaults\" from super-classes as it \n\t\t\t// done in `can.Construct`\n\t\t\tcan.Construct.setup.apply( this, arguments );\n\n\t\t\t// If you didn't provide a name, or are `control`, don't do anything.\n\t\t\tif ( can.Control ) {\n\n\t\t\t\t// Cache the underscored names.\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\t// Calculate and cache actions.\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor ( funcName in control.prototype ) {\n\t\t\t\t\tif ( control._isAction(funcName) ) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's an element\n\t\t_shifter : function( context, name ) {\n\n\t\t\tvar method = typeof name == \"string\" ? context[name] : name;\n\n\t\t\tif ( ! isFunction( method )) {\n\t\t\t\tmethod = context[ method ];\n\t\t\t}\n\t\t\t\n\t\t\treturn function() {\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [this.nodeName ? can.$(this) : this].concat( slice.call(arguments, 0)));\n\t\t\t};\n\t\t},\n\n\t\t// Return `true` if is an action.\n\t\t/**\n\t\t * @hide\n\t\t * @param {String} methodName a prototype function\n\t\t * @return {Boolean} truthy if an action or not\n\t\t */\n\t\t_isAction: function( methodName ) {\n\t\t\t\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\t\t\t// if not the constructor\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t\t// and is a function or links to a function\n\t\t\t\t( type == \"function\" || (type == \"string\" &&  isFunction(this.prototype[val] ) ) ) &&\n\t\t\t\t// and is in special, a processor, or has a funny character\n\t\t\t\t!! ( special[methodName] || processors[methodName] || /[^\\w]/.test(methodName) );\n\t\t},\n\t\t// Takes a method name and the options passed to a control\n\t\t// and tries to return the data necessary to pass to a processor\n\t\t// (something that binds things).\n\t\t/**\n\t\t * @hide\n\t\t * Takes a method name and the options passed to a control\n\t\t * and tries to return the data necessary to pass to a processor\n\t\t * (something that binds things).\n\t\t * \n\t\t * For performance reasons, this called twice.  First, it is called when \n\t\t * the Control class is created.  If the methodName is templated\n\t\t * like: \"{window} foo\", it returns null.  If it is not templated\n\t\t * it returns event binding data.\n\t\t * \n\t\t * The resulting data is added to this.actions.\n\t\t * \n\t\t * When a control instance is created, _action is called again, but only\n\t\t * on templated actions.  \n\t\t * \n\t\t * @param {Object} methodName the method that will be bound\n\t\t * @param {Object} [options] first param merged with class default options\n\t\t * @return {Object} null or the processor and pre-split parts.  \n\t\t * The processor is what does the binding/subscribing.\n\t\t */\n\t\t_action: function( methodName, options ) {\n\t\t\t\n\t\t\t// If we don't have options (a `control` instance), we'll run this \n\t\t\t// later.  \n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif ( options || ! paramReplacer.test( methodName )) {\n\t\t\t\t// If we have options, run sub to replace templates `{}` with a\n\t\t\t\t// value from the options or the window\n\t\t\t\tvar convertedName = options ? can.sub(methodName, this._lookup(options)) : methodName;\n\t\t\t\tif(!convertedName) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// If a `{}` template resolves to an object, `convertedName` will be\n\t\t\t\t// an array\n\t\t\t\tvar arr = can.isArray(convertedName),\n\n\t\t\t\t\t// Get the name\n\t\t\t\t\tname = arr ? convertedName[1] : convertedName,\n\n\t\t\t\t\t// Grab the event off the end\n\t\t\t\t\tparts = name.split(/\\s+/g),\n\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\treturn {\n\t\t\t\t\tprocessor: processors[event] || basicProcessor,\n\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\tdelegate : arr ? convertedName[0] : undefined\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t_lookup: function(options){\n\t\t\treturn [options, window]\n\t\t},\n\t\t// An object of `{eventName : function}` pairs that Control uses to \n\t\t// hook up events auto-magically.\n\t\t/**\n\t\t * @property {Object.<can.Control.processor>} can.Control.processors processors\n\t\t * @parent can.Control.static\n\t\t * \n\t\t * @description A collection of hookups for custom events on Controls.\n\t\t *\n\t\t * @body\n\t\t * `processors` is an object that allows you to add new events to bind\n\t\t * to on a control, or to change how existent events are bound. Each\n\t\t * key-value pair of `processors` is a specification that pertains to\n\t\t * an event where the key is the name of the event, and the value is\n\t\t * a function that processes calls to bind to the event.\n\t\t *\n\t\t * The processor function takes five arguments:\n\t\t * \n\t\t * - _el_: The Control's element.\n\t\t * - _event_: The event type.\n\t\t * - _selector_: The selector preceding the event in the binding used on the Control.\n\t\t * - _callback_: The callback function being bound.\n\t\t * - _control_: The Control the event is bound on.\n\t\t *\n\t\t * Inside your processor function, you should bind _callback_ to the event, and\n\t\t * return a function for can.Control to call when _callback_ needs to be unbound.\n\t\t * (If _selector_ is defined, you will likely want to use some form of delegation\n\t\t * to bind the event.)\n\t\t *\n\t\t * Here is a Control with a custom event processor set and two callbacks bound\n\t\t * to that event:\n\t\t *\n\t\t * @codestart\n\t\t * can.Control.processors.birthday = function(el, ev, selector, callback, control) {\n\t\t *   if(selector) {\n\t\t *     myFramework.delegate(ev, el, selector, callback);\n\t\t *     return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t\t *   } else {\n\t     *     myFramework.bind(ev, el, callback);\n\t\t *     return function() { myFramework.unbind(ev, el, callback); };  \n\t\t *   }\n\t\t * };\n\t\t *\n\t\t * can.Control(\"EventTarget\", { }, {\n\t\t *   'birthday': function(el, ev) {\n\t\t *     // do something appropriate for the occasion\n\t\t *   },\n\t\t *   '.grandchild birthday': function(el, ev) {\n\t\t *     // do something appropriate for the occasion\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var target = new EventTarget('#person');\n\t\t * @codeend\n\t\t *\n\t\t * When `target` is initialized, can.Control will call `can.Control.processors.birthday`\n\t\t * twice (because there are two event hookups for the _birthday_ event). The first\n\t\t * time it's called, the arguments will be:\n\t\t * \n\t\t * - _el_: A NodeList that wraps the element with id 'person'.\n\t\t * - _ev_: `'birthday'`\n\t\t * - _selector_: `''`\n\t\t * - _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\n\t\t * definition.\n\t\t * - _control_: `target` itself.\n\t\t * \n\t\t * The second time, the arguments are slightly different:\n\t\t * \n\t\t * - _el_: A NodeList that wraps the element with id 'person'.\n\t\t * - _ev_: `'birthday'`\n\t\t * - _selector_: `'.grandchild'`\n\t\t * - _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\n\t\t * definition.\n\t\t * - _control_: `target` itself.\n\t\t *\n\t\t * can.Control already has processors for these events:\n\t\t * \n\t\t *   - change \n\t\t *   - click \n\t\t *   - contextmenu \n\t\t *   - dblclick \n\t\t *   - focusin\n\t\t *   - focusout\n\t\t *   - keydown \n\t\t *   - keyup \n\t\t *   - keypress \n\t\t *   - mousedown \n\t\t *   - mouseenter\n\t\t *   - mouseleave\n\t\t *   - mousemove \n\t\t *   - mouseout \n\t\t *   - mouseover \n\t\t *   - mouseup \n\t\t *   - reset \n\t\t *   - resize \n\t\t *   - scroll \n\t\t *   - select \n\t\t *   - submit  \n\t\t */\n\t\tprocessors: {},\n\t\t// A object of name-value pairs that act as default values for a \n\t\t// control instance\n\t\tdefaults: {}\n\t\t/**\n\t\t * @property {Object} can.Control.defaults defaults\n\t\t * @parent can.Control.static\n\t\t * @description Default values for the Control's options.\n\t\t *\n\t\t * @body\n\t\t * `defaults` provides default values for a Control's options.\n\t\t * Options passed into the constructor function will be shallowly merged\n\t\t * into the values from defaults in [can.Control::setup], and\n\t\t * the result will be stored in [can.Control::options this.options].\n\t\t * \n\t\t *     Message = can.Control.extend({\n\t\t *       defaults: {\n\t\t *         message: \"Hello World\"\n\t\t *       }\n\t\t *     }, {\n\t\t *       init: function(){\n\t\t *         this.element.text( this.options.message );\n\t\t *       }\n\t\t *     });\n\t\t *\n\t\t *     new Message( \"#el1\" ); //writes \"Hello World\"\n\t\t *     new Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\t\t */\n\t},\n\t{\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// Sets `this.element`, saves the control in `data, binds event\n\t\t// handlers.\n\t\t/**\n\t\t * @property {NodeList} can.Control.prototype.element element\n\t\t * @parent can.Control.prototype\n\t\t * @description The element associated with this control.\n\t\t * \n\t\t * @body\n\t\t * The library-wrapped element this control is associated with,\n\t\t * as passed into the constructor. If you want to change the element\n\t\t * that a Control will attach to, you should do it in [can.Control::setup setup].\n\t\t * If you change the element later, make sure to call [can.Control::on on]\n\t\t * to rebind all the bindings.\n\t\t *\n\t\t * If `element` is removed from the DOM, [can.Control::destroy] will\n\t\t * be called and the Control will be destroyed.\n\t\t */\n\t\t//\n\t\t/**\n\t\t * @function can.Control.prototype.setup setup\n\t\t * @parent can.Control.prototype\n\t\t * @description Perform pre-initialization logic.\n\t\t * @signature `control.setup(element, options)`\n\t\t * @param {HTMLElement|NodeList|String} element The element as passed to the constructor.\n\t\t * @param {Object} [options] option values for the control.  These get added to\n\t\t * this.options and merged with [can.Control.static.defaults defaults].\n\t\t * @return {undefined|Array} return an array if you want to change what init is called with. By\n\t\t * default it is called with the element and options passed to the control.\n\t\t * \n\t\t * @body\n\t\t * Setup is where most of control's magic happens.  It does the following:\n\t\t * \n\t\t * ### Sets this.element\n\t\t * \n\t\t * The first parameter passed to new Control( el, options ) is expected to be \n\t\t * an element.  This gets converted to a Wrapped NodeList element and set as\n\t\t * [can.Control.prototype.element this.element].\n\t\t * \n\t\t * ### Adds the control's name to the element's className\n\t\t * \n\t\t * Control adds it's plugin name to the element's className for easier \n\t\t * debugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\t\t * \"foo_bar\" to the className.\n\t\t * \n\t\t * ### Saves the control in $.data\n\t\t * \n\t\t * A reference to the control instance is saved in $.data.  You can find \n\t\t * instances of \"Foo.Bar\" like: \n\t\t * \n\t\t *     $( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\t\t *\n\t\t * ### Merges Options\n\t\t * Merges the default options with optional user-supplied ones.\n\t\t * Additionally, default values are exposed in the static [can.Control.static.defaults defaults] \n\t\t * so that users can change them.\n\t\t * \n\t\t * ### Binds event handlers\n\t\t * \n\t\t * Setup does the event binding described in [can.Control].\n\t\t */\n\t\tsetup: function( element, options ) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls._fullName,\n\t\t\t\tarr;\n\n\t\t\t// Want the raw element here.\n\t\t\tthis.element = can.$(element)\n\n\t\t\tif ( pluginname && pluginname !== 'can_control') {\n\t\t\t\t// Set element and `className` on element.\n\t\t\t\tthis.element.addClass(pluginname);\n\t\t\t}\n\t\t\t\n\t\t\t(arr = can.data(this.element,\"controls\")) || can.data(this.element,\"controls\",arr = []);\n\t\t\tarr.push(this);\n\t\t\t\n\t\t\t// Option merging.\n\t\t\t/**\n\t\t\t * @property {Object} can.Control.prototype.options options\n\t\t\t * @parent can.Control.prototype\n\t\t\t * \n\t\t\t * @description\n\t\t\t * \n\t\t\t * Options used to configure a control.\n\t\t\t * \n\t\t\t * @body\n\t\t\t * \n\t\t\t * The `this.options` property is an Object that contains\n\t\t\t * configuration data passed to a control when it is\n\t\t\t * created (`new can.Control(element, options)`). \n\t\t\t * \n\t\t\t * In the following example, an options object with\n\t\t\t * a message is passed to a `Greeting` control. The \n\t\t\t * `Greeting` control changes the text of its [can.Control::element element] \n\t\t\t * to the options' message value.\n\t\t\t * \n\t\t\t *     var Greeting = can.Control.extend({\n\t\t\t *       init: function(){\n\t\t\t *         this.element.text( this.options.message )  \n\t\t\t *       }  \n\t\t\t *     })\n\t\t\t *     \n\t\t\t *     new Greeting(\"#greeting\",{message: \"I understand this.options\"})\n\t\t\t * \n\t\t\t * The options argument passed when creating the control\n\t\t\t * is merged with [can.Control.defaults defaults] in\n\t\t\t * [can.Control.prototype.setup setup].\n\t\t\t * \n\t\t\t * In the following example, if no message property is provided,\n\t\t\t * the defaults' message property is used.\n\t\t\t * \n\t\t\t *     var Greeting = can.Control.extend({\n\t\t\t *       defaults: {\n\t\t\t *         message: \"Defaults merged into this.options\"\n\t\t\t *       }\n\t\t\t *     },{\n\t\t\t *       init: function(){\n\t\t\t *         this.element.text( this.options.message )  \n\t\t\t *       }  \n\t\t\t *     })\n\t\t\t *     \n\t\t\t *     new Greeting(\"#greeting\")\n\t\t\t * \n\t\t\t */\n\t\t\tthis.options = extend({}, cls.defaults, options);\n\n\t\t\t// Bind all event handlers.\n\t\t\tthis.on();\n\n\t\t\t// Gets passed into `init`.\n\t\t\t/**\n\t\t\t * @property {can.NodeList} can.Control.prototype.element element\n\t\t\t * \n\t\t\t * @description The element the Control is associated with.\n\t\t\t * \n\t\t\t * @parent can.Control.prototype\n\t\t\t * \n\t\t\t * @body\n\t\t\t * \n\t\t\t * The control instance's HTMLElement (or window) wrapped by the \n\t\t\t * util library for ease of use. It is set by the first\n\t\t\t * parameter to `new can.Construct( element, options )` \n\t\t\t * in [can.Control::setup].  By default, a control listens to events on `this.element`.\n\t\t\t * \n\t\t\t * ### Quick Example\n\t\t\t * \n\t\t\t * The following `HelloWorld` control sets the control`s text to \"Hello World\":\n\t\t\t * \n\t\t\t *     HelloWorld = can.Control({\n\t\t\t *       init: function(){\n\t\t\t * \t       this.element.text( 'Hello World' );\n\t\t\t *       }\n\t\t\t *     });\n\t\t\t *     \n\t\t\t *     // create the controller on the element\n\t\t\t *     new HelloWorld( document.getElementById( '#helloworld' ) );\n\t\t\t * \n\t\t\t * ## Wrapped NodeList\n\t\t\t * \n\t\t\t * `this.element` is a wrapped NodeList of one HTMLELement (or window).  This\n\t\t\t * is for convenience in libraries like jQuery where all methods operate only on a\n\t\t\t * NodeList.  To get the raw HTMLElement, write:\n\t\t\t * \n\t\t\t *     this.element[0] //-> HTMLElement\n\t\t\t * \n\t\t\t * The following details the NodeList used by each library with \n\t\t\t * an example of updating its text:\n\t\t\t * \n\t\t\t * __jQuery__ `jQuery( HTMLElement )`\n\t\t\t * \n\t\t\t *     this.element.text(\"Hello World\")\n\t\t\t * \n\t\t\t * __Zepto__ `Zepto( HTMLElement )`\n\t\t\t * \n\t\t\t *     this.element.text(\"Hello World\")\n\t\t\t * \n\t\t\t * __Dojo__ `new dojo.NodeList( HTMLElement )`\n\t\t\t * \n\t\t\t *     this.element.text(\"Hello World\")\n\t\t\t * \n\t\t\t * __Mootools__ `$$( HTMLElement )`\n\t\t\t * \n\t\t\t *     this.element.empty().appendText(\"Hello World\")\n\t\t\t * \n\t\t\t * __YUI__ \n\t\t\t * \n\t\t\t *     this.element.set(\"text\", \"Hello World\")\n\t\t\t * \n\t\t\t * \n\t\t\t * ## Changing `this.element`\n\t\t\t * \n\t\t\t * Sometimes you don't want what's passed to `new can.Control`\n\t\t\t * to be this.element.  You can change this by overwriting\n\t\t\t * setup or by unbinding, setting this.element, and rebinding.\n\t\t\t * \n\t\t\t * ### Overwriting Setup\n\t\t\t * \n\t\t\t * The following Combobox overwrites setup to wrap a\n\t\t\t * select element with a div.  That div is used \n\t\t\t * as `this.element`. Notice how `destroy` sets back the\n\t\t\t * original element.\n\t\t\t * \n\t\t\t *     Combobox = can.Control({\n\t\t\t *       setup: function( el, options ) {\n\t\t\t *          this.oldElement = $( el );\n\t\t\t *          var newEl = $( '<div/>' );\n\t\t\t *          this.oldElement.wrap( newEl );\n\t\t\t *          can.Control.prototype.setup.call( this, newEl, options );\n\t\t\t *       },\n\t\t\t *       init: function() {\n\t\t\t *          this.element //-> the div\n\t\t\t *       },\n\t\t\t *       \".option click\": function() {\n\t\t\t *         // event handler bound on the div\n\t\t\t *       },\n\t\t\t *       destroy: function() {\n\t\t\t *          var div = this.element; //save reference\n\t\t\t *          can.Control.prototype.destroy.call( this );\n\t\t\t *          div.replaceWith( this.oldElement );\n\t\t\t *       }\n\t\t\t *     });\n\t\t\t * \n\t\t\t * ### unbinding, setting, and rebinding.\n\t\t\t * \n\t\t\t * You could also change this.element by calling\n\t\t\t * [can.Control::off], setting this.element, and \n\t\t\t * then calling [can.Control::on] like:\n\t\t\t * \n\t\t\t *     move: function( newElement ) {\n\t\t\t *        this.off();\n\t\t\t *        this.element = $( newElement );\n\t\t\t *        this.on();\n\t\t\t *     }\n\t\t\t */\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t/**\n\t\t * @function can.Control.prototype.on on\n\t\t * @parent can.Control.prototype\n\t\t * \n\t\t * @description Bind an event handler to a Control, or rebind all event handlers on a Control.\n\t\t * \n\t\t * @signature `control.on([el,] selector, eventName, func)`\n\t\t * @param {HTMLElement|jQuery collection|Object} [el=this.element]\n\t\t * The element to be bound.  If no element is provided, the control's element is used instead.\n\t\t * @param {CSSSelectorString} selector A css selector for event delegation.\n\t\t * @param {String} eventName The event to listen for.\n\t\t * @param {Function|String} func A callback function or the String name of a control function.  If a control\n\t\t * function name is given, the control function is called back with the bound element and event as the first\n\t\t * and second parameter.  Otherwise the function is called back like a normal bind.\n\t\t * @return {Number} The id of the binding in this._bindings\n\t\t * \n\t\t * @body\n\t\t * `on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n\t\t *\n\t\t * @signature `control.on()`\n\t\t * \n\t\t * Rebind all of a control's event handlers.\n\t\t * \n\t\t * @return {Number} The number of handlers bound to this Control.\n\t\t *\n\t\t * @body\n\t\t * `this.on()` is used to rebind \n\t\t * all event handlers when [can.Control::options this.options] has changed.  It\n\t\t * can also be used to bind or delegate from other elements or objects.\n\t\t * \n\t\t * ## Rebinding\n\t\t * \n\t\t * By using templated event handlers, a control can listen to objects outside\n\t\t * `this.element`.  This is extremely common in MVC programming.  For example,\n\t\t * the following control might listen to a task model's `completed` property and\n\t\t * toggle a strike className like:\n\t\t * \n\t\t *     TaskStriker = can.Control({\n\t\t *       \"{task} completed\": function(){\n\t\t * \t       this.update();\n\t\t *       },\n\t\t *       update: function(){\n\t\t *         if ( this.options.task.completed ) {\n\t\t * \t         this.element.addClass( 'strike' );\n\t\t * \t       } else {\n\t\t *           this.element.removeClass( 'strike' );\n\t\t *         }\n\t\t *       }\n\t\t *     });\n\t\t * \n\t\t *     var taskstriker = new TaskStriker({ \n\t\t *       task: new Task({ completed: 'true' }) \n\t\t *     });\n\t\t * \n\t\t * To update the `taskstriker`'s task, add a task method that updates\n\t\t * this.options and rebinds the event handlers for the new task like:\n\t\t * \n\t\t *     TaskStriker = can.Control({\n\t\t *       \"{task} completed\": function(){\n\t\t * \t       this.update();\n\t\t *       },\n\t\t *       update: function() {\n\t\t *         if ( this.options.task.completed ) {\n\t\t * \t         this.element.addClass( 'strike' );\n\t\t * \t       } else {\n\t\t *           this.element.removeClass( 'strike' );\n\t\t *         }\n\t\t *       },\n\t\t *       task: function( newTask ) {\n\t\t *         this.options.task = newTask;\n\t\t *         this.on();\n\t\t *         this.update();\n\t\t *       }\n\t\t *     });\n\t\t * \n\t\t *     var taskstriker = new TaskStriker({ \n\t\t *       task: new Task({ completed: true }) \n\t\t *     });\n\t\t *     taskstriker.task( new TaskStriker({ \n\t\t *       task: new Task({ completed: false }) \n\t\t *     }));\n\t\t * \n\t\t * ## Adding new events\n\t\t * \n\t\t * If events need to be bound to outside of the control and templated event handlers\n\t\t * are not sufficient, you can call this.on to bind or delegate programmatically:\n\t\t * \n\t\t *     init: function() {\n\t\t *        // calls somethingClicked( el, ev )\n\t\t *        this.on( 'click', 'somethingClicked' ); \n\t\t *     \n\t\t *        // calls function when the window is clicked\n\t\t *        this.on( window, 'click', function( ev ) {\n\t\t *          //do something\n\t\t *        });\n\t\t *     },\n\t\t *     somethingClicked: function( el, ev ) {\n\t\t *       \n\t\t *     }\n\t\t */\n\t\ton: function( el, selector, eventName, func ) {\n\t\t\tif ( ! el ) {\n\n\t\t\t\t// Adds bindings.\n\t\t\t\tthis.off();\n\n\t\t\t\t// Go through the cached list of actions and use the processor \n\t\t\t\t// to bind\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = this.element,\n\t\t\t\t\tdestroyCB = can.Control._shifter(this,\"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\t\t\t\t\t\n\t\t\t\tfor ( funcName in actions ) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty( funcName ) &&\n\t\t\t\t\t\t(ready = actions[funcName] || cls._action(funcName, this.options))) {\n\t\t\t\t\t\tbindings.push(ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// Setup to be destroyed...  \n\t\t\t\t// don't bind because we don't want to remove it.\n\t\t\t\tcan.bind.call(element,\"removed\", destroyCB);\n\t\t\t\tbindings.push(function( el ) {\n\t\t\t\t\tcan.unbind.call(el,\"removed\", destroyCB);\n\t\t\t\t});\n\t\t\t\treturn bindings.length;\n\t\t\t}\n\n\t\t\tif ( typeof el == 'string' ) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\tif(func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif ( typeof func == 'string' ) {\n\t\t\t\tfunc = can.Control._shifter(this,func);\n\t\t\t}\n\n\t\t\tthis._bindings.push( binder( el, eventName, func, selector ));\n\n\t\t\treturn this._bindings.length;\n\t\t},\n\t\t// Unbinds all event handlers on the controller.\n\t\t/**\n\t\t * @hide\n\t\t * Unbinds all event handlers on the controller. You should never\n\t\t * be calling this unless in use with [can.Control::on].\n\t\t */\n\t\toff : function(){\n\t\t\tvar el = this.element[0];\n\t\t\teach(this._bindings || [], function( value ) {\n\t\t\t\tvalue(el);\n\t\t\t});\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = [];\n\t\t},\n\t\t// Prepares a `control` for garbage collection\n\t\t/**\n\t\t * @description Remove a Control from an element and clean up the Control.\n\t\t * @signature `control.destroy()`\n\t\t * \n\t\t * Prepares a control for garbage collection and is a place to\n\t\t * reset any changes the control has made.  \n\t\t * \n\t\t * @function can.Control.prototype.destroy destroy\n\t\t * @parent can.Control.prototype\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * \n\t\t * ## Allowing Garbage Collection\n\t\t * \n\t\t * Destroy is called whenever a control's element is removed from the page using \n\t\t * the library's standard HTML modifier methods.  This means that you\n\t\t * don't have to call destroy yourself and it \n\t\t * will be called automatically when appropriate.  \n\t\t * \n\t\t * The following `Clicker` widget listens on the window for clicks and updates\n\t\t * its element's innerHTML.  If we remove the element, the window's event handler\n\t\t * is removed auto-magically:\n\t\t *  \n\t\t * \n\t\t *      Clickr = can.Control({\n\t\t *       \"{window} click\": function() {\n\t\t * \t       this.element.html( this.count ? \n\t\t * \t                          this.count++ : this.count = 0 );\n\t\t *       }  \n\t\t *     });\n\t\t *     \n\t\t *     // create a clicker on an element\n\t\t *     new Clicker( \"#clickme\" );\n\t\t * \n\t\t *     // remove the element\n\t\t *     $( '#clickme' ).remove();\n\t\t * \n\t\t * \n\t\t * The methods you can use that will destroy controls automatically by library:\n\t\t * \n\t\t * __jQuery and Zepto__\n\t\t * \n\t\t *   - $.fn.remove\n\t\t *   - $.fn.html\n\t\t *   - $.fn.replaceWith\n\t\t *   - $.fn.empty\n\t\t * \n\t\t * __Dojo__\n\t\t * \n\t\t *   - dojo.destroy\n\t\t *   - dojo.empty\n\t\t *   - dojo.place (with the replace option)\n\t\t * \n\t\t * __Mootools__\n\t\t * \n\t\t *   - Element.prototype.destroy\n\t\t * \n\t\t * __YUI__\n\t\t * \n\t\t *   - Y.Node.prototype.remove\n\t\t *   - Y.Node.prototype.destroy\n\t\t * \n\t\t * \n\t\t * ## Teardown in Destroy\n\t\t * \n\t\t * Sometimes, you want to reset a controlled element back to its\n\t\t * original state when the control is destroyed.  Overwriting destroy\n\t\t * lets you write teardown code of this manner.  __When overwriting\n\t\t * destroy, make sure you call Control's base functionality__.\n\t\t * \n\t\t * The following example changes an element's text when the control is\n\t\t * created and sets it back when the control is removed:\n\t\t * \n\t\t *     Changer = can.Control.extend({\n\t\t *       init: function() {\n\t\t *         this.oldText = this.element.text();\n\t\t *         this.element.text( \"Changed!!!\" );\n\t\t *       },\n\t\t *       destroy: function() {\n\t\t *         this.element.text( this.oldText );\n\t\t *         can.Control.prototype.destroy.call( this );\n\t\t *       }\n\t\t *     });\n\t\t *     \n\t\t *     // create a changer which changes #myel's text\n\t\t *     var changer = new Changer( '#myel' );\n\t\t * \n\t\t *     // destroy changer which will reset it\n\t\t *     changer.destroy();\n\t\t * \n\t\t * ## Base Functionality\n\t\t * \n\t\t * Control prepares the control for garbage collection by:\n\t\t * \n\t\t *   - unbinding all event handlers\n\t\t *   - clearing references to this.element and this.options\n\t\t *   - clearing the element's reference to the control\n\t\t *   - removing it's [can.Control.pluginName] from the element's className\n\t\t * \n\t\t */\n\t\tdestroy: function() {\n\t\t\t//Control already destroyed\n\t\t\tif(this.element === null) {\n\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || Class._fullName,\n\t\t\t\tcontrols;\n\t\t\t\n\t\t\t// Unbind bindings.\n\t\t\tthis.off();\n\t\t\t\n\t\t\tif(pluginName && pluginName !== 'can_control'){\n\t\t\t\t// Remove the `className`.\n\t\t\t\tthis.element.removeClass(pluginName);\n\t\t\t}\n\t\t\t\n\t\t\t// Remove from `data`.\n\t\t\tcontrols = can.data(this.element,\"controls\");\n\t\t\tcontrols.splice(can.inArray(this, controls),1);\n\t\t\t\n\t\t\tcan.trigger( this, \"destroyed\"); // In case we want to know if the `control` is removed.\n\t\t\t\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n\tvar processors = can.Control.processors,\n\t// Processors do the binding.\n\t// They return a function that unbinds when called.  \n\t//\n\t// The basic processor that binds events.\n\tbasicProcessor = function( el, event, selector, methodName, control ) {\n\t\treturn binder( el, event, can.Control._shifter(control, methodName), selector);\n\t};\n\n\n\n\n\t// Set common events to be processed as a `basicProcessor`\n\teach([\"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\t// #104 - Add touch events as default processors\n\t\t// TOOD feature detect?\n\t\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\"\n\t], function( v ) {\n\t\tprocessors[v] = basicProcessor;\n\t});\n\n\treturn Control;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/control/route',[\"can/util/library\", \"can/route\", \"can/control\"], function(can){\n\t\n\t// ## control/route.js  \n\t// _Controller route integration._\n\t\n\tcan.Control.processors.route = function( el, event, selector, funcName, controller ) {\n\t\tselector = selector || \"\";\n\t\tif ( !can.route.routes[selector] ) {\n\t\t\tcan.route( selector );\n\t\t}\n\t\tvar batchNum,\n\t\t\tcheck = function( ev, attr, how ) {\n\t\t\t\tif ( can.route.attr('route') === ( selector ) && \n\t\t\t\t\t( ev.batchNum === undefined || ev.batchNum !== batchNum ) ) {\n\t\t\t\t\t\n\t\t\t\t\tbatchNum = ev.batchNum;\n\t\t\t\t\t\n\t\t\t\t\tvar d = can.route.attr();\n\t\t\t\t\tdelete d.route;\n\t\t\t\t\tif ( can.isFunction( controller[ funcName ] )) {\n\t\t\t\t\t\tcontroller[funcName]( d );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontroller[controller[funcName]](d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t};\n\t\tcan.route.bind( 'change', check );\n\t\treturn function() {\n\t\t\tcan.route.unbind( 'change', check );\n\t\t};\n\t};\n\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/list',[\"can/util/library\", \"can/map\"], function(can, Map){\n\t\n\t\n\t\n\t// Helpers for `observable` lists.\n\tvar splice = [].splice,\n\t\t// test if splice works correctly\n\t\tspliceRemovesProps = (function(){\n\t\t\t// IE's splice doesn't remove properties\n\t\t\tvar obj = {0: \"a\", length: 1};\n\t\t\tsplice.call(obj, 0,1);\n\t\t\treturn !obj[0];\n\t\t})(),\n\t/**\n\t * @add can.List\n\t */\n\tlist = Map(\n\t/**\n\t * @static\n\t */\n\t{\n\t\t/**\n\t\t * @property {can.Map} can.List.Map\n\t\t * \n\t\t * @description Specify the Map type used to make objects added to this list observable.\n\t\t * \n\t\t * @option {can.Map} When objects are added to a can.List, those objects are\n\t\t * converted into can.Map instances.  For example:\n\t\t * \n\t\t *     var list = new can.List();\n\t\t *     list.push({name: \"Justin\"});\n\t\t *     \n\t\t *     var map = list.attr(0);\n\t\t *     map.attr(\"name\") //-> \"Justin\"\n\t\t * \n\t\t * By changing [can.List.Map], you can specify a different type of Map instance to \n\t\t * create. For example:\n\t\t * \n\t\t *     var User = can.Map.extend({\n\t\t *       fullName: function(){\n\t\t *         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n\t\t *       }\n\t\t *     });\n\t\t * \n\t\t *     User.List = can.List.extend({\n\t\t *       Map: User\n\t\t *     });\n\t\t * \n\t\t *     var list = new User.List();\n\t\t *     list.push({first: \"Justin\", last: \"Meyer\"});\n\t\t * \n\t\t *     var user = list.attr(0);\n\t\t *     user.fullName() //-> \"Justin Meyer\"\n\t\t * \n\t\t * \n\t\t * \n\t\t */\n\t\tMap: Map\n\t\t/**\n\t\t * @function can.Map.extend\n\t\t * \n\t\t * @signature `can.List.extend([name,] [staticProperties,] instanceProperties)`\n\t\t * \n\t\t * Creates a new extended constructor function. Learn more at [can.Construct.extend].\n \t\t *    \n\t\t * @param {String} [name] If provided, adds the extened List constructor function\n\t\t * to the window at the given name.\n\t\t * \n\t\t * @param {Object} [staticProperties] Properties and methods \n\t\t * directly on the constructor function. The most common property to set is [can.List.Map].\n\t\t * \n\t\t * @param {Object} [instanceProperties] Properties and methods on instances of this list type.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * \n\t\t */\n\t},\n\t/**\n\t * @prototype\n\t */\n\t{\n\t\tsetup: function( instances, options ) {\n\t\t\tthis.length = 0;\n\t\t\tcan.cid(this, \".map\")\n\t\t\tthis._init = 1;\n\t\t\tinstances = instances || [];\n\t\t\t\n\t\t\t\n\t\t\tif( can.isDeferred(instances) ) {\n\t\t\t\tthis.replace(instances)\n\t\t\t} else {\n\t\t\t\tvar teardownMapping = instances.length && can.Map.helpers.addToMap(instances, this);\n\t\t\t\tthis.push.apply(this, can.makeArray(instances || []));\n\t\t\t}\n\t\t\t\n\t\t\tteardownMapping && teardownMapping();\n\t\t\t\n\t\t\t// this change needs to be ignored\n\t\t\tthis.bind('change',can.proxy(this._changes,this));\n\t\t\tcan.simpleExtend(this, options);\n\t\t\tdelete this._init;\n\t\t},\n\t\t_triggerChange: function(attr, how, newVal, oldVal){\n\t\t\t\n\t\t\tMap.prototype._triggerChange.apply(this,arguments)\n\t\t\t// `batchTrigger` direct add and remove events...\n\t\t\tif ( !~ attr.indexOf('.')){\n\t\t\t\t\n\t\t\t\tif( how === 'add' ) {\n\t\t\t\t\tcan.batch.trigger(this, how, [newVal,+attr]);\n\t\t\t\t\tcan.batch.trigger(this,'length',[this.length]);\n\t\t\t\t} else if( how === 'remove' ) {\n\t\t\t\t\tcan.batch.trigger(this, how, [oldVal, +attr]);\n\t\t\t\t\tcan.batch.trigger(this,'length',[this.length]);\n\t\t\t\t} else {\n\t\t\t\t\tcan.batch.trigger(this,how,[newVal, +attr])\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t__get : function(attr){\n\t\t\treturn attr ? this[attr] : this;\n\t\t},\n\t\t___set : function(attr, val){\n\t\t\tthis[attr] = val;\n\t\t\tif(+attr >= this.length){\n\t\t\t\tthis.length = (+attr+1)\n\t\t\t}\n\t\t},\n\t\t_each: function(callback){\n\t\t\tvar data = this.__get();\n\t\t\tfor(var i =0; i < data.length; i++){\n\t\t\t\tcallback(data[i],i)\n\t\t\t}\n\t\t},\n\t\t_bindsetup: Map.helpers.makeBindSetup(\"*\"),\n\t\t// Returns the serialized form of this list.\n\t\t/**\n\t\t * @hide\n\t\t * Returns the serialized form of this list.\n\t\t */\n\t\tserialize: function() {\n\t\t\treturn Map.helpers.serialize(this, 'serialize', []);\n\t\t},\n\t\t/**\n\t\t * @function can.List.prototype.each each\n\t\t * @description Call a function on each element of a List.\n\t\t * @signature `list.each( callback(item, index) )`\n\t\t * \n\t\t * `each` iterates through the Map, calling a function\n\t\t * for each element.\n\t\t * \n\t\t * @param {function(*, Number)} callback the function to call for each element\n\t\t * The value and index of each element will be passed as the first and second\n\t\t * arguments, respectively, to the callback. If the callback returns false,\n\t\t * the loop will stop.\n\t\t * \n\t\t * @return {can.List} this List, for chaining\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var i = 0;\n\t\t * new can.Map([1, 10, 100]).each(function(element, index) {\n\t\t *     i += element;\n\t\t * });\n\t\t * \n\t\t * i; // 111\n\t\t * \n\t\t * i = 0;\n\t\t * new can.Map([1, 10, 100]).each(function(element, index) {\n\t\t *     i += element;\n\t\t *     if(index >= 1) {\n\t\t *         return false;\n\t\t *     }\n\t\t * });\n\t\t * \n\t\t * i; // 11\n\t\t * @codeend\n\t\t */\n\t\t//  \n\t\t/**\n\t\t * @function can.List.prototype.splice splice\n\t\t * @description Insert and remove elements from a List.\n\t\t * @signature `list.splice(index[, howMany[, ...newElements]])`\n\t\t * @param {Number} index where to start removing or inserting elements\n\t\t * \n\t\t * @param {Number} [howMany] the number of elements to remove\n\t\t * If _howMany_ is not provided, `splice` will all elements from `index` to the end of the List.\n\t\t *\n\t\t * @param {*} newElements elements to insert into the List\n\t\t *\n\t\t * @return {Array} the elements removed by `splice`\n\t\t *\n\t\t * @body\n\t\t * `splice` lets you remove elements from and insert elements into a List.\n\t\t *\n\t\t * This example demonstrates how to do surgery on a list of numbers:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List([0, 1, 2, 3]);\n\t\t *\n\t\t * // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n\t\t * list.splice(2, 1, 'Alice', 'Bob');\n\t\t * list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n\t\t * @codeend\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `splice` causes the List it's called on to emit _change_ events,\n\t\t * _add_ events, _remove_ events, and _length_ events. If there are\n\t\t * any elements to remove, a _change_ event, a _remove_ event, and a\n\t\t * _length_ event will be fired. If there are any elements to insert, a\n\t\t * separate _change_ event, an _add_ event, and a separate _length_ event\n\t\t * will be fired. \n\t\t *\n\t\t * This slightly-modified version of the above example should help\n\t\t * make it clear how `splice` causes events to be emitted:\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List(['a', 'b', 'c', 'd']);\n\t\t * list.bind('change', function(ev, attr, how, newVals, oldVals) {\n\t     *     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t\t * });\n\t\t * list.bind('add', function(ev, newVals, where) {\n\t     *     console.log('add: ' + newVals + ', ' + where);\n\t\t * });\n\t\t * list.bind('remove', function(ev, oldVals, where) {\n\t     *     console.log('remove: ' + oldVals + ', ' + where);\n\t\t * });\n\t\t * list.bind('length', function(ev, length) {\n\t     *     console.log('length: ' + length + ', ' + this.attr());\n\t\t * });\n\t\t *\n\t\t * // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n\t\t * list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n\t\t *                                    // remove: ['c'], 2\n\t\t *                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n\t\t *                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n\t\t *                                    // add: ['Alice', 'Bob'], 2\n\t\t *                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n\t\t * @codeend\n\t\t *\n\t\t * More information about binding to these events can be found under [can.List.attr attr].\n\t\t */\n\t\tsplice: function( index, howMany ) {\n\t\t\tvar args = can.makeArray(arguments),\n\t\t\t\ti;\n\n\t\t\tfor ( i = 2; i < args.length; i++ ) {\n\t\t\t\tvar val = args[i];\n\t\t\t\tif ( Map.helpers.canMakeObserve(val) ) {\n\t\t\t\t\targs[i] = Map.helpers.hookupBubble(val, \"*\", this, this.constructor.Map, this.constructor)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( howMany === undefined ) {\n\t\t\t\thowMany = args[1] = this.length - index;\n\t\t\t}\n\t\t\tvar removed = splice.apply(this, args);\n\t\t\t\n\t\t\tif(!spliceRemovesProps) {\n\t\t\t\tfor(var i = this.length; i < removed.length+this.length; i++){\n\t\t\t\t\tdelete this[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcan.batch.start();\n\t\t\tif ( howMany > 0 ) {\n\t\t\t\tthis._triggerChange(\"\"+index, \"remove\", undefined, removed);\n\t\t\t\tMap.helpers.unhookup(removed, this);\n\t\t\t}\n\t\t\tif ( args.length > 2 ) {\n\t\t\t\tthis._triggerChange(\"\"+index, \"add\", args.slice(2), removed);\n\t\t\t}\n\t\t\tcan.batch.stop();\n\t\t\treturn removed;\n\t\t},\n\t\t/**\n\t\t * @description Get or set elements in a List.\n\t\t * @function can.List.prototype.attr attr\n\t\t * \n\t\t * @signature `list.attr()`\n\t\t * \n\t\t * Gets an array of all the elements in this `can.List`.\n\t\t * \n\t\t * @return {Array} An array with all the elements in this List.\n\t\t * \n\t\t * @signature `list.attr(index)`\n\t\t * \n\t\t * Reads an element from this `can.List`.\n\t\t * \n\t\t * @param {Number} index The element to read.\n\t\t * @return {*} The value at _index_.\n\t\t * \n\t\t * @signature `list.attr(index, value)`\n\t\t * \n\t\t * Assigns _value_ to the index _index_ on this `can.List`, expanding the list if necessary.\n\t\t * \n\t\t * @param {Number} index The element to set.\n\t\t * @param {*} value The value to assign at _index_.\n\t\t * @return {can.List} This list, for chaining.\n\t\t * \n\t\t * @signature `list.attr(elements[, replaceCompletely])`\n\t\t * \n\t\t * Merges the members of _elements_ into this List, replacing each from the beginning in order. If\n\t\t * _elements_ is longer than the current List, the current List will be expanded. If _elements_\n\t\t * is shorter than the current List, the extra existing members are not affected (unless\n\t\t * _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can.Map::removeAttr removeAttr]`.\n\t\t * \n\t\t * @param {Array} elements An array of elements to merge in.\n\t\t * \n\t\t * @param {bool} [replaceCompletely=false] whether to completely replace the elements of List\n\t\t * If _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing\n\t\t * extra members of the List will be removed.\n\t\t * \n\t\t * @return {can.List} This list, for chaining.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `attr` gets or sets elements on the `can.List` it's called on. Here's a tour through\n\t\t * how all of its forms work:\n\t\t * \n\t\t *     var people = new can.List(['Alex', 'Bill']);\n\t\t *     \n\t\t *     // set an element:\n\t\t *     people.attr(0, 'Adam');\n\t\t *     \n\t\t *     // get an element:\n\t\t *     people.attr(0); // 'Adam'\n\t\t *     people[0]; // 'Adam'\n\t\t *     \n\t\t *     // get all elements:\n\t\t *     people.attr(); // ['Adam', 'Bill']\n\t\t *     \n\t\t *     // extend the array:\n\t\t *     people.attr(4, 'Charlie');\n\t\t *     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\t\t *     \n\t\t *     // merge the elements:\n\t\t *     people.attr(['Alice', 'Bob', 'Eve']);\n\t\t *     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\t\t * \n\t\t * ## Deep properties\n\t\t * \n\t\t * `attr` can also set and read deep properties. All you have to do is specify\n\t\t * the property name as you normally would if you weren't using `attr`.\n\t\t * \n\t\t * @codestart\n\t\t * var people = new can.List([{name: 'Alex'}, {name: 'Bob'}]);\n\t\t * \n\t\t * // set a property:\n\t\t * people.attr('0.name', 'Alice');\n\t\t * \n\t\t * // get a property:\n\t\t * people.attr('0.name');  // 'Alice'\n\t\t * people[0].attr('name'); // 'Alice'\n\t\t * \n\t\t * // get all properties:\n\t\t * people.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n\t\t * @codeend\n\t\t * \n\t\t * The discussion of deep properties under `[can.Map.prototype.attr]` may also\n\t\t * be enlightening.\n\t\t * \n\t\t * ## Events\n\t\t * \n\t\t * `can.List`s emit five types of events in response to changes. They are:\n\t\t * \n\t\t * - the _change_ event fires on every change to a List.\n\t\t * - the _set_ event is fired when an element is set.\n\t\t * - the _add_ event is fired when an element is added to the List.\n\t\t * - the _remove_ event is fired when an element is removed from the List.\n\t\t * - the _length_ event is fired when the length of the List changes.\n\t\t * \n\t\t * ### The _change_ event\n\t\t *  \n\t\t * The first event that is fired is the _change_ event. The _change_ event is useful\n\t\t * if you want to react to all changes on an List.\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List([]);\n\t\t * list.bind('change', function(ev, index, how, newVal, oldVal) {\n\t\t *     console.log('Something changed.');\n\t\t * });\n\t\t * @codeend\n\t\t * \n\t\t * The parameters of the event handler for the _change_ event are:\n\t\t * \n\t\t * - _ev_ The event object.\n\t\t * - _index_ Where the change took place.\n\t\t * - _how_ Whether elements were added, removed, or set.\n\t\t * Possible values are `'add'`, `'remove'`, or `'set'`.\n\t\t * - _newVal_ The elements affected after the change\n\t\t *  _newVal_ will be a single value when an index is set, an Array when elements\n\t\t * were added, and `undefined` if elements were removed.\n\t\t * - _oldVal_ The elements affected before the change.\n\t\t * _newVal_ will be a single value when an index is set, an Array when elements\n\t\t * were removed, and `undefined` if elements were added.\n\t\t * \n\t\t * Here is a concrete tour through the _change_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * list.bind('change', function(ev, index, how, newVal, oldVal) {\n\t\t *     console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n\t\t * });\n\t\t * \n\t\t * list.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\n\t\t * list.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\n\t\t * list.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\n\t\t * list.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n\t\t *                                // [object Object], 1, set, Bob, Bill\n\t\t * list.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n\t\t * @codeend\n\t\t * \n\t\t * ### The _set_ event\n\t\t * \n\t\t * _set_ events are fired when an element at an index that already exists in the List is\n\t\t * modified. Actions can cause _set_ events to fire never also cause _length_ events\n\t\t * to fire (although some functions, such as `[can.List.prototype.splice splice]`\n\t\t * may cause unrelated sets of events to fire after being batched).\n\t\t * \n\t\t * The parameters of the event handler for the _set_ event are:\n\t\t * \n\t\t * - _ev_ The event object.\n\t\t * - _newVal_ The new value of the element.\n\t\t * - _index_ where the set took place.\n\t\t * \n\t\t * Here is a concrete tour through the _set_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * list.bind('set', function(ev, newVal, index) {\n\t\t *     console.log(newVal + ', ' + index);\n\t\t * });\n\t\t * \n\t\t * list.attr(['Alexis', 'Bill']);\n\t\t * list.attr(2, 'Eve');          \n\t\t * list.attr(0, 'Adam');          // Adam, 0\n\t\t * list.attr(['Alice', 'Bob']);   // Alice, 0\n\t\t *                                // Bob, 1\n\t\t * list.removeAttr(1);            \n\t\t * @codeend\n\t\t * \n\t\t * ### The _add_ event\n\t\t * \n\t\t * _add_ events are fired when elements are added or inserted\n\t\t * into the List.\n\t\t * \n\t\t * The parameters of the event handler for the _add_ event are:\n\t\t * \n\t\t * - _ev_ The event object.\n\t\t * - _newElements_ The new elements.\n\t\t * If more than one element is added, _newElements_ will be an array.\n\t\t * Otherwise, it is simply the new element itself.\n\t\t * - _index_ Where the add or insert took place.\n\t\t * \n\t\t * Here is a concrete tour through the _add_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * list.bind('add', function(ev, newElements, index) {\n\t\t *     console.log(newElements + ', ' + index);\n\t\t * });\n\t\t * \n\t\t * list.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\n\t\t * list.attr(2, 'Eve');           // Eve, 2\n\t\t * list.attr(0, 'Adam');          \n\t\t * list.attr(['Alice', 'Bob']);   \n\t\t *                                \n\t\t * list.removeAttr(1);            \n\t\t * @codeend\n\t\t * \n\t\t * ### The _remove_ event\n\t\t * \n\t\t * _remove_ events are fired when elements are removed from the list.\n\t\t * \n\t\t * The parameters of the event handler for the _remove_ event are:\n\t\t * \n\t\t * - _ev_ The event object.\n\t\t * - _removedElements_ The removed elements.\n\t\t * If more than one element was removed, _removedElements_ will be an array.\n\t\t * Otherwise, it is simply the element itself.\n\t\t * - _index_ Where the removal took place.\n\t\t * \n\t\t * Here is a concrete tour through the _remove_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * list.bind('remove', function(ev, removedElements, index) {\n\t\t *     console.log(removedElements + ', ' + index);\n\t\t * });\n\t\t * \n\t\t * list.attr(['Alexis', 'Bill']); \n\t\t * list.attr(2, 'Eve');           \n\t\t * list.attr(0, 'Adam');          \n\t\t * list.attr(['Alice', 'Bob']);   \n\t\t *                                \n\t\t * list.removeAttr(1);            // Bob, 1\n\t\t * @codeend\n\t\t * \n\t\t * ### The _length_ event\n\t\t * \n\t\t * _length_ events are fired whenever the list changes.\n\t\t * \n\t\t * The parameters of the event handler for the _length_ event are:\n\t\t * \n\t\t * - _ev_ The event object.\n\t\t * - _length_ The current length of the list.\n\t\t * If events were batched when the _length_ event was triggered, _length_\n\t\t * will have the length of the list when `stopBatch` was called. Because\n\t\t * of this, you may recieve multiple _length_ events with the same\n\t\t * _length_ parameter.\n\t\t * \n\t\t * Here is a concrete tour through the _length_ event handler's arguments:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * list.bind('length', function(ev, length) {\n\t\t *     console.log(length);\n\t\t * });\n\t\t * \n\t\t * list.attr(['Alexis', 'Bill']); // 2\n\t\t * list.attr(2, 'Eve');           // 3\n\t\t * list.attr(0, 'Adam');          \n\t\t * list.attr(['Alice', 'Bob']);   \n\t\t *                                \n\t\t * list.removeAttr(1);            // 2\n\t\t * @codeend\n\t\t */\n\t\t_attrs: function( items, remove ) {\n\t\t\tif ( items === undefined ) {\n\t\t\t\treturn Map.helpers.serialize(this, 'attr', []);\n\t\t\t}\n\n\t\t\t// Create a copy.\n\t\t\titems = can.makeArray( items );\n\n      \t\tcan.batch.start();\n\t\t\tthis._updateAttrs(items, remove);\n\t\t\tcan.batch.stop()\n\t\t},\n\n\t    _updateAttrs : function( items, remove ){\n\t      var len = Math.min(items.length, this.length);\n\t\n\t      for ( var prop = 0; prop < len; prop++ ) {\n\t        var curVal = this[prop],\n\t          newVal = items[prop];\n\t\n\t        if ( Map.helpers.canMakeObserve(curVal) && Map.helpers.canMakeObserve(newVal) ) {\n\t          curVal.attr(newVal, remove)\n\t        } else if ( curVal != newVal ) {\n\t          this._set(prop, newVal)\n\t        } else {\n\t\n\t        }\n\t      }\n\t      if ( items.length > this.length ) {\n\t        // Add in the remaining props.\n\t        this.push.apply( this, items.slice( this.length ) );\n\t      } else if ( items.length < this.length && remove ) {\n\t        this.splice(items.length)\n\t      }\n\t    }\n\t}),\n\n\n\t\t// Converts to an `array` of arguments.\n\t\tgetArgs = function( args ) {\n\t\t\treturn args[0] && can.isArray(args[0]) ?\n\t\t\t\targs[0] :\n\t\t\t\tcan.makeArray(args);\n\t\t};\n\t// Create `push`, `pop`, `shift`, and `unshift`\n\tcan.each(\n\t{\n\t\t/**\n\t\t * @function can.List.prototype.push push\n\t\t * @description Add elements to the end of a list.\n\t\t * @signature `list.push(...elements)`\n\t\t *\n\t\t * `push` adds elements onto the end of a List.]\n\t\t * \n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `push` is fairly straightforward:\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice']);\n\t\t *\n\t\t * list.push('Bob', 'Eve');\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * @codeend\n\t\t *\n\t\t * If you have an array you want to concatenate to the end\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * @codestart\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new can.List(['Alice']);\n\t\t *\n\t\t * list.push.apply(list, names);\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * @codeend\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `push` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `push` has a counterpart in [can.List.pop pop], or you may be\n\t\t * looking for [can.List.unshift unshift] and its counterpart [can.List.shift shift].\n\t\t */\n\t\tpush: \"length\",\n\t\t/**\n\t\t * @function can.List.prototype.unshift unshift\n\t\t * @description Add elements to the beginning of a List.\n\t\t * @signature `list.unshift(...elements)`\n\t\t *\n\t\t * `unshift` adds elements onto the beginning of a List.\n\t\t * \n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `unshift` adds elements to the front of the list in bulk in the order specified:\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * @codeend\n\t\t *\n\t\t * If you have an array you want to concatenate to the beginning\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * @codestart\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new can.List(['Alice']);\n\t\t *\n\t\t * list.push.apply(list, names);\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * @codeend\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `unshift` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `unshift` has a counterpart in [can.List.shift shift], or you may be\n\t\t * looking for [can.List.push push] and its counterpart [can.List.pop pop].\n\t\t */\n\t\tunshift: 0\n\t},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction( where, name ) {\n\t\tvar orig = [][name]\n\t\tlist.prototype[name] = function() {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this.length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres,\n\t\t\t\tval,\n\t\t\t\tconstructor = this.constructor;\n\n\t\t\t// Go through and convert anything to an `map` that needs to be converted.\n\t\t\twhile(i--){\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] =  Map.helpers.canMakeObserve(val) ?\n\t\t\t\t\tMap.helpers.hookupBubble(val, \"*\", this, this.constructor.Map, this.constructor) :\n\t\t\t\t\tval;\n\t\t\t}\n\t\t\t\n\t\t\t// Call the original method.\n\t\t\tres = orig.apply(this, args);\n\n\t\t\tif ( !this.comparator || args.length ) {\n\n\t\t\t\tthis._triggerChange(\"\"+len, \"add\", args, undefined);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\treturn res;\n\t\t}\n\t});\n\n\tcan.each({\n\t\t/**\n\t\t * @function can.List.prototype.pop pop\n\t\t * @description Remove an element from the end of a List.\n\t\t * @signature `list.pop()`\n\t\t *\n\t\t * `push` removes an element from the end of a List.\n\t\t * \n\t\t * @return {*} the element just popped off the List, or `undefined` if the List was empty\n\t\t *\n\t\t * @body\n\t\t * `pop` is the opposite action from `[can.List.push push]`:\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice']);\n\t\t *\n\t\t * list.push('Bob', 'Eve');\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * \n\t\t * list.pop(); // 'Eve'\n\t\t * list.pop(); // 'Bob'\n\t\t * list.pop(); // 'Alice'\n\t\t * list.pop(); // undefined\n\t\t * @codeend\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `pop` has its counterpart in [can.List.push push], or you may be\n\t\t * looking for [can.List.unshift unshift] and its counterpart [can.List.shift shift].\n\t\t */\n\t\tpop: \"length\",\n\t\t/**\n\t\t * @function can.List.prototype.shift shift\n\t\t * @description Remove en element from the front of a list.\n\t\t * @signature `list.shift()`\n\t\t *\n\t\t * `shift` removes an element from the beginning of a List.\n\t\t *\n\t\t * @return {*} the element just shifted off the List, or `undefined` if the List is empty\n\t\t *\n\t\t * @body\n\t\t * `shift` is the opposite action from `[can.List.unshift unshift]`:\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t *\n\t\t * list.shift(); // 'Bob'\n\t\t * list.shift(); // 'Eve'\n\t\t * list.shift(); // 'Alice'\n\t\t * list.shift(); // undefined\n\t\t * @codeend\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `shift` has a counterpart in [can.List.unshift unshift], or you may be\n\t\t * looking for [can.List.push push] and its counterpart [can.List.pop pop].\n\t\t */\n\t\tshift: 0\n\t},\n\t// Creates a `remove` type method\n\tfunction( where, name ) {\n\t\tlist.prototype[name] = function() {\n\t\t\t\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this.length ? this.length - 1 : 0;\n\n\n\t\t\tvar res = [][name].apply(this, args)\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tthis._triggerChange(\"\"+len, \"remove\", undefined, [res])\n\n\t\t\tif ( res && res.unbind ) {\n\t\t\t\tcan.stopListening.call(this, res, \"change\");\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t});\n\t\n\tcan.extend(list.prototype, {\n\t\t/**\n\t\t * @function can.List.prototype.indexOf indexOf\n\t\t * @description Look for an item in a List.\n\t\t * @signature `list.indexOf(item)`\n\t\t *\n\t\t * `indexOf` finds the position of a given item in the List.\n\t\t *\n\t\t * @param {*} item the item to find\n\t\t *\n\t\t * @return {Number} the position of the item in the List, or -1 if the item is not found.\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice', 'Bob', 'Eve']);\n\t\t * list.indexOf('Alice');   // 0\n\t\t * list.indexOf('Charlie'); // -1\n\t\t * @codeend\n\t\t *\n\t\t * It is trivial to make a `contains`-type function using `indexOf`:\n\t\t *\n\t\t * @codestart\n\t\t * function(list, item) {\n\t\t *     return list.indexOf(item) >= 0;\n\t\t * }\n\t\t * @codeend\n\t\t */\n\t\tindexOf: function(item, fromIndex) {\n\t\t\tthis.attr('length')\n\t\t\treturn can.inArray(item, this, fromIndex)\n\t\t},\n\n\t\t/**\n\t\t * @function can.List.prototype.join join\n\t\t * @description Join a List's elements into a string.\n\t\t * @signature `list.join(separator)`\n\t\t *\n\t\t * `join` turns a List into a string by inserting _separator_ between the string representations\n\t\t * of all the elements of the List.\n\t\t *\n\t\t * @param {String} separator the string to seperate elements with\n\t\t *\n\t\t * @return {String} the joined string\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice', 'Bob', 'Eve']);\n\t\t * list.join(', '); // 'Alice, Bob, Eve'\n\t\t *\n\t\t * var beatles = new can.List(['John', 'Paul', 'Ringo', 'George']);\n\t\t * beatles.join('&'); // 'John&Paul&Ringo&George'\n\t\t * @codeend\n\t\t */\n\t\tjoin: function(){\n\t\t\treturn [].join.apply(this.attr(), arguments)\n\t\t},\n\t\t\n\t\t/**\n\t\t * @function can.List.prototype.reverse reverse\n\t\t * @description Reverse the order of a List.\n\t\t * @signature `list.reverse()`\n\t\t *\n\t\t * `reverse` reverses the elements of the List in place.\n\t\t *\n\t\t * @return {can.List} the List, for chaining\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice', 'Bob', 'Eve']);\n\t\t * var reversedList = list.reverse();\n\t\t *\n\t\t * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];\n\t\t * list === reversedList; // true\n\t\t * @codeend\n\t\t */\n\t\treverse: [].reverse,\n\n\t\t/**\n\t\t * @function can.List.prototype.slice slice\n\t\t * @description Make a copy of a part of a List.\n\t\t * @signature `list.slice([start[, end]])`\n\t\t *\n\t\t * `slice` creates a copy of a portion of the List.\n\t\t *\n\t\t * @param {Number} [start=0] the index to start copying from\n\t\t *\n\t\t * @param {Number} [end] the first index not to include in the copy\n\t\t * If _end_ is not supplied, `slice` will copy until the end of the list.\n\t\t *\n\t\t * @return {can.List} a new `can.List` with the extracted elements\n\t\t *\n\t\t * @body\n\t\t * @codestart\n\t\t * var list = new can.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\n\t\t * var newList = list.slice(1, 4);\n\t\t * newList.attr(); // ['Bob', 'Charlie', 'Daniel']\n\t\t * @codeend\n\t\t *\n\t\t * `slice` is the simplest way to copy a List:\n\t\t * \n\t\t * @codestart\n\t\t * var list = new can.List(['Alice', 'Bob', 'Eve']);\n\t\t * var copy = list.slice();\n\t\t *\n\t\t * copy.attr();   // ['Alice', 'Bob', 'Eve']\n\t\t * list === copy; // false\n\t\t * @codeend\n\t\t */\n\t\tslice : function() {\n\t\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\t\treturn new this.constructor( temp );\n\t\t},\n\n\t\t/**\n\t\t * @function can.List.prototype.concat concat\n\t\t * @description Merge many collections together into a List.\n\t\t * @signature `list.concat(...args)`\n\t\t * @param {Array|can.List|*} args Any number of arrays, Lists, or values to add in\n\t\t * For each parameter given, if it is an Array or a List, each of its elements will be added to\n\t\t * the end of the concatenated List. Otherwise, the parameter itself will be added.\n\t\t *\n\t\t * @body\n\t\t * `concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List();\n\t\t * var newList = list.concat(\n\t\t *     'Alice',\n\t\t *     ['Bob', 'Charlie']),\n\t\t *     new can.List(['Daniel', 'Eve']),\n\t\t *     {f: 'Francis'}\n\t\t * );\n\t\t * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n\t\t * @codeend\n\t\t */\n\t\tconcat : function() {\n\t\t\tvar args = [];\n\t\t\tcan.each( can.makeArray( arguments ), function( arg, i ) {\n\t\t\t\targs[i] = arg instanceof can.List ? arg.serialize() : arg ;\n\t\t\t});\n\t\t\treturn new this.constructor(Array.prototype.concat.apply(this.serialize(), args));\n\t\t},\n\n\t\t/**\n\t\t * @function can.List.prototype.forEach forEach\n\t\t * @description Call a function for each element of a List.\n\t\t * @signature `list.forEach(callback[, thisArg])`\n\t\t * @param {function(element, index, list)} callback a function to call with each element of the List\n\t\t * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\n\t\t * current element of the list, and _list_ the List the elements are coming from.\n\t\t * @param {Object} [thisArg] the object to use as `this` inside the callback\n\t\t *\n\t\t * @body\n\t\t * `forEach` calls a callback for each element in the List.\n\t\t *\n\t\t * @codestart\n\t\t * var list = new can.List([1, 2, 3]);\n\t\t * list.forEach(function(element, index, list) {\n\t\t *     list.attr(index, element * element);\n\t\t * });\n\t\t * list.attr(); // [1, 4, 9]\n\t\t * @codeend\n\t\t */\n\t\tforEach : function( cb, thisarg ) {\n\t\t\treturn can.each(this, cb, thisarg || this );\n\t\t},\n\n\t\t/**\n\t\t * @function can.List.prototype.replace replace\n\t\t * @description Replace all the elements of a List.\n\t\t * @signature `list.replace(collection)`\n\t\t * @param {Array|can.List|can.Deferred} collection the collection of new elements to use\n\t\t * If a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\n\t\t * The elements of the list are not actually removed until the Deferred resolves.\n\t\t *\n\t\t * @body\n\t\t * `replace` replaces all the elements of this List with new ones.\n\t\t *\n\t\t * `replace` is especially useful when `can.List`s are live-bound into `[can.Control]`s,\n\t\t * and you intend to populate them with the results of a `[can.Model]` call:\n\t\t *\n\t\t * @codestart\n\t\t * can.Control({\n\t\t *     init: function() {\n\t\t *         this.list = new Todo.List();\n\t\t *         // live-bind the list into the DOM\n\t\t *         this.element.html(can.view('list.mustache', this.list));\n\t\t *         // when this AJAX call returns, the live-bound DOM will be updated\n\t\t *         this.list.replace(Todo.findAll());\n\t\t *     }\n\t\t * });\n\t\t * @codeend\n\t\t *\n\t\t * Learn more about [can.Model.List making Lists of models].\n\t\t *\n\t\t * ## Events\n\t\t * \n\t\t * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\n\t\t * an_add_ event and a _remove_ event, whereas `attr` will cause _set_ events along an _add_ or _remove_\n\t\t * event if needed. Corresponding _change_ and _length_ events will be fired as well.\n\t\t *\n\t\t * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n\t\t * @codestart\n\t\t * var attrList = new can.List(['Alexis', 'Bill']);\n\t\t * attrList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t\t * });\n\t\t * \n\t\t * var replaceList = new can.List(['Alexis', 'Bill']);\n\t\t * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t\t * });\n\t\t * \n\t\t * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n\t\t *                                               // 1, set, Ben, Bill\n\t\t * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n\t\t *                                               // 0, add, undefined, ['Adam', 'Ben']\n\t\t * \n\t\t * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n\t\t *                                               // 1, remove, undefined, Ben\n\t\t * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n\t\t *                                               // 0, add, Amber, ['Adam', 'Ben']\n\t\t * \n\t\t * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n\t\t *                                               // 1, add, ['Bob', 'Eve'], undefined\n\t\t * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n\t\t *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n\t\t * @codeend\n\t\t */\n\t\treplace : function(newList) {\n\t\t\tif(can.isDeferred(newList)) {\n\t\t\t\tnewList.then(can.proxy(this.replace, this));\n\t\t\t} else {\n\t\t\t\tthis.splice.apply(this, [0, this.length].concat(can.makeArray(newList || [])));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\tcan.List = Map.List = list;\n\treturn can.List;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/model',[\"can/util/library\", \"can/map\", \"can/list\"], function( can ) {\n\t\n\t// ## model.js  \n\t// `can.Model`  \n\t// _A `can.Map` that connects to a RESTful interface._\n\t//  \n\t// Generic deferred piping function\n\t/**\n\t * @add can.Model\n\t */\n\tvar\tpipe = function( def, model, func ) {\n\t\tvar d = new can.Deferred();\n\t\tdef.then(function(){\n\t\t\tvar args = can.makeArray( arguments ),\n\t\t\t    success = true;\n\t\t\ttry {\n\t\t\t\targs[0] = model[func](args[0]);\n\t\t\t} catch(e) {\n\t\t\t\tsuccess = false;\n\t\t\t\td.rejectWith(d, [e].concat(args));\n\t\t\t}\n\t\t\tif (success) {\n\t\t\t\td.resolveWith(d, args);\n\t\t\t}\n\t\t},function(){\n\t\t\td.rejectWith(this, arguments);\n\t\t});\n\n\t\tif(typeof def.abort === 'function') {\n\t\t\td.abort = function() {\n\t\t\t\treturn def.abort();\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t},\n\t\tmodelNum = 0,\n\t\tignoreHookup = /change.observe\\d+/,\n\t\tgetId = function( inst ) {\n\t\t\t// Instead of using attr, use __get for performance.\n\t\t\t// Need to set reading\n\t\t\tcan.__reading && can.__reading(inst, inst.constructor.id)\n\t\t\treturn inst.__get(inst.constructor.id);\n\t\t},\n\t\t// Ajax `options` generator function\n\t\tajax = function( ajaxOb, data, type, dataType, success, error ) {\n\n\t\t\tvar params = {};\n\t\t\t\n\t\t\t// If we get a string, handle it.\n\t\t\tif ( typeof ajaxOb == \"string\" ) {\n\t\t\t\t// If there's a space, it's probably the type.\n\t\t\t\tvar parts = ajaxOb.split(/\\s+/);\n\t\t\t\tparams.url = parts.pop();\n\t\t\t\tif ( parts.length ) {\n\t\t\t\t\tparams.type = parts.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcan.extend( params, ajaxOb );\n\t\t\t}\n\n\t\t\t// If we are a non-array object, copy to a new attrs.\n\t\t\tparams.data = typeof data == \"object\" && ! can.isArray( data ) ?\n\t\t\t\tcan.extend(params.data || {}, data) : data;\n\t\n\t\t\t// Get the url with any templated values filled out.\n\t\t\tparams.url = can.sub(params.url, params.data, true);\n\n\t\t\treturn can.ajax( can.extend({\n\t\t\t\ttype: type || \"post\",\n\t\t\t\tdataType: dataType ||\"json\",\n\t\t\t\tsuccess : success,\n\t\t\t\terror: error\n\t\t\t}, params ));\n\t\t},\n\t\tmakeRequest = function( self, type, success, error, method ) {\n\t\t\tvar args;\n\t\t\t// if we pass an array as `self` it it means we are coming from\n\t\t\t// the queued request, and we're passing already serialized data\n\t\t\t// self's signature will be: [self, serializedData]\n\t\t\tif(can.isArray(self)){\n\t\t\t\targs = self[1];\n\t\t\t\tself = self[0];\n\t\t\t} else {\n\t\t\t\targs = self.serialize();\n\t\t\t}\n\t\t\targs = [args];\n\t\t\tvar deferred,\n\t\t\t\t// The model.\n\t\t\t\tmodel = self.constructor,\n\t\t\t\tjqXHR;\n\n\t\t\t// `update` and `destroy` need the `id`.\n\t\t\tif ( type !== 'create' ) {\n\t\t\t\targs.unshift(getId(self));\n\t\t\t}\n\n\t\t\t\n\t\t\tjqXHR = model[type].apply(model, args);\n\t\t\t\n\t\t\tdeferred = jqXHR.pipe(function(data){\n\t\t\t\tself[method || type + \"d\"](data, jqXHR);\n\t\t\t\treturn self;\n\t\t\t});\n\n\t\t\t// Hook up `abort`\n\t\t\tif(jqXHR.abort){\n\t\t\t\tdeferred.abort = function(){\n\t\t\t\t\tjqXHR.abort();\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tdeferred.then(success,error);\n\t\t\treturn deferred;\n\t\t},\n\t\tinitializers = {\n\t\t\t// makes a models function that looks up the data in a particular property\n\t\t\tmodels: function(prop){\n\t\t\t\treturn function( instancesRawData, oldList ) {\n\t\t\t\t\t// until \"end of turn\", increment reqs counter so instances will be added to the store\n\t\t\t\t\tcan.Model._reqs++;\n\t\t\t\t\tif ( ! instancesRawData ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t      \n\t\t\t\t\tif ( instancesRawData instanceof this.List ) {\n\t\t\t\t\t\treturn instancesRawData;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\t// Get the list type.\n\t\t\t\t\tvar self = this,\n\t\t\t\t\t\ttmp = [],\n\t\t\t\t\t\tres = oldList instanceof can.List ? oldList : new( self.List || ML),\n\t\t\t\t\t\t// Did we get an `array`?\n\t\t\t\t\t\tarr = can.isArray(instancesRawData),\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Did we get a model list?\n\t\t\t\t\t\tml = (instancesRawData instanceof ML),\n\t\t\n\t\t\t\t\t\t// Get the raw `array` of objects.\n\t\t\t\t\t\traw = arr ?\n\t\t\n\t\t\t\t\t\t// If an `array`, return the `array`.\n\t\t\t\t\t\tinstancesRawData :\n\t\t\n\t\t\t\t\t\t// Otherwise if a model list.\n\t\t\t\t\t\t(ml ?\n\t\t\n\t\t\t\t\t\t// Get the raw objects from the list.\n\t\t\t\t\t\tinstancesRawData.serialize() :\n\t\t\n\t\t\t\t\t\t// Get the object's data.\n\t\t\t\t\t\tcan.getObject( prop||\"data\", instancesRawData)),\n\t\t\t\t\t\ti = 0;\n\t\t\n\t\t\t\t\tif(typeof raw === 'undefined') {\n\t\t\t\t\t\tthrow new Error('Could not get any raw data while converting using .models');\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\n\t\t\t\t\tif(res.length) {\n\t\t\t\t\t\tres.splice(0);\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tcan.each(raw, function( rawPart ) {\n\t\t\t\t\t\ttmp.push( self.model( rawPart ));\n\t\t\t\t\t});\n\t\t\n\t\t\t\t\t// We only want one change event so push everything at once\n\t\t\t\t\tres.push.apply(res, tmp);\n\t\t\n\t\t\t\t\tif ( ! arr ) { // Push other stuff onto `array`.\n\t\t\t\t\t\tcan.each(instancesRawData, function(val, prop){\n\t\t\t\t\t\t\tif ( prop !== 'data' ) {\n\t\t\t\t\t\t\t\tres.attr(prop, val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\t// at \"end of turn\", clean up the store\n\t\t\t\t\tsetTimeout(can.proxy(this._clean, this), 1);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmodel: function( prop ) {\n\t\t\t\treturn function( attributes ) {\n\t\t\t\t\tif ( ! attributes ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof attributes.serialize === 'function' ) {\n\t\t\t\t\t\tattributes = attributes.serialize();\n\t\t\t\t\t}\n\t\t\t\t\tif(prop){\n\t\t\t\t\t\tattributes = can.getObject( prop||\"data\", attributes );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar id = attributes[ this.id ],\n\t\t\t\t\t    model = (id || id === 0) && this.store[id] ?\n\t\t\t\t\t\t    this.store[id].attr(attributes, this.removeAttr || false) : new this( attributes );\n\t\t\t\t\t\n\t\t\t\t\treturn model;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t\n\t// This object describes how to make an ajax request for each ajax method.  \n\t// The available properties are:\n\t//\t\t`url` - The default url to use as indicated as a property on the model.\n\t//\t\t`type` - The default http request type\n\t//\t\t`data` - A method that takes the `arguments` and returns `data` used for ajax.\n\t/** \n\t * @static\n\t */\n\t//\n\t\t/**\n\t\t * @function can.Model.bind bind\n\t\t * @parent can.Model.static\n\t\t * @description Listen for events on a Model class.\n\t\t *\n\t\t * @signature `can.Model.bind(eventType, handler)`\n\t\t * @param {String} eventType The type of event.  It must be\n\t\t * `\"created\"`, `\"updated\"`, `\"destroyed\"`.\n\t\t * @param {function} handler A callback function\n\t\t * that gets called with the event and instance that was\n\t\t * created, destroyed, or updated.\n\t\t * @return {can.Model} The model constructor function.\n\t\t *\n\t\t * @body\n\t\t * `bind(eventType, handler(event, instance))` listens to\n\t\t * __created__, __updated__, __destroyed__ events on all \n\t\t * instances of the model.\n\t\t * \n\t\t *     Task.bind(\"created\", function(ev, createdTask){\n\t\t * \t     this //-> Task\n\t\t *       createdTask.attr(\"name\") //-> \"Dishes\"\n\t\t *     })\n\t\t *     \n\t\t *     new Task({name: \"Dishes\"}).save();\n\t\t */\n\t\t// \n\t\t/**\n\t\t * @function can.Model.unbind unbind\n\t\t * @parent can.Model.static\n\t\t * @description Stop listening for events on a Model class.\n\t\t * \n\t\t * @signature `can.Model.unbind(eventType, handler)`\n\t\t * @param {String} eventType The type of event. It must be\n\t\t * `\"created\"`, `\"updated\"`, `\"destroyed\"`.\n\t\t * @param {function} handler A callback function\n\t\t * that was passed to `bind`.\n\t\t * @return {can.Model} The model constructor function.\n\t\t *\n\t\t * @body\n\t\t * `unbind(eventType, handler)` removes a listener\n\t\t * attached with [can.Model.bind].\n\t\t * \n\t\t *     var handler = function(ev, createdTask){\n\t\t * \t     \n\t\t *     }\n\t\t *     Task.bind(\"created\", handler)\n\t\t *     Task.unbind(\"created\", handler)\n\t\t * \n\t\t * You have to pass the same function to `unbind` that you\n\t\t * passed to `bind`.\n\t\t */\n\t\t// \n\t\t/**\n\t\t * @property {String} can.Model.id id\n\t\t * @parent can.Model.static\n\t\t * The name of the id field.  Defaults to `'id'`. Change this if it is something different.\n\t\t * \n\t\t * For example, it's common in .NET to use `'Id'`.  Your model might look like:\n\t\t * \n\t\t *     Friend = can.Model.extend({\n\t\t *       id: \"Id\"\n\t\t *     },{});\n\t\t */\n\t\t/**\n\t\t * @property {Boolean} can.Model.removeAttr removeAttr\n\t\t * @parent can.Model.static\n\t\t * Sets whether model conversion should remove non existing attributes or merge with\n\t\t * the existing attributes. The default is `false`.\n\t\t * For example, if `Task.findOne({ id: 1 })` returns\n\t\t *\n\t\t *      { id: 1, name: 'Do dishes', index: 1, color: ['red', 'blue'] }\n\t\t *\n         * for the first request and\n\t\t *\n\t\t *      { id: 1, name: 'Really do dishes', color: ['green'] }\n\t\t *\n\t\t *  for the next request, the actual model attributes would look like:\n\t\t *\n\t\t *      { id: 1, name: 'Really do dishes', index: 1, color: ['green', 'blue'] }\n\t\t *\n\t\t *  Because the attributes of the original model and the updated model will\n\t\t *  be merged. Setting `removeAttr` to `true` will result in model attributes like\n\t\t *\n\t\t *      { id: 1, name: 'Really do dishes', color: ['green'] }\n\t\t *\n\t\t */\n\tajaxMethods = {\n\t\t/**\n\t\t * @description Specifies how to create a new resource on the server. `create(serialized)` is called \n\t\t * by [can.Model.prototype.save save] if the model instance [can.Model.prototype.isNew is new].\n\t\t * @function can.Model.create create\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * \n\t\t * @signature `can.Model.create: function(serialized) -> deferred`\n\t\t * \n\t\t * Specify a function to create persistent instances. The function will\n\t\t * typically perform an AJAX request to a service that results in\n\t\t * creating a record in a database.\n\t\t * \n\t\t * @param {Object} serialized The [can.Map::serialize serialized] properties of\n\t\t * the model to create.\n\t\t * @return {can.Deferred} A Deferred that resolves to an object of attributes\n\t\t * that will be added to the created model instance.  The object __MUST__ contain\n\t\t * an [can.Model.id id] property so that future calls to [can.Model.prototype.save save]\n\t\t * will call [can.Model.update].\n\t\t * \n\t\t * \n\t\t * @signature `can.Model.create: \"[METHOD] /path/to/resource\"`\n\t\t * \n\t\t * Specify a HTTP method and url to create persistent instances.\n\t\t * \n\t\t * If you provide a URL, the Model will send a request to that URL using\n\t\t * the method specified (or POST if none is specified) when saving a\n\t\t * new instance on the server. (See below for more details.)\n\t\t * \n\t\t * @param {HttpMethod} METHOD An HTTP method. Defaults to `\"POST\"`.\n\t\t * @param {STRING} url The URL of the service to retrieve JSON data.\n\t\t * \n\t\t * \n\t\t * @signature `can.Model.create: {ajaxSettings}`\n\t\t * \n\t\t * Specify an options object that is used to make a HTTP request to create\n\t\t * persistent instances.\n\t\t * \n\t\t * @param {can.AjaxSettings} ajaxSettings A settings object that\n\t\t * specifies the options available to pass to [can.ajax].\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * `create(attributes) -> Deferred` is used by [can.Model::save save] to create a \n\t\t * model instance on the server. \n\t\t * \n\t\t * ## Implement with a URL\n\t\t * \n\t\t * The easiest way to implement create is to give it the url \n\t\t * to post data to:\n\t\t * \n\t\t *     var Recipe = can.Model.extend({\n\t\t *       create: \"/recipes\"\n\t\t *     },{})\n\t\t *     \n\t\t * This lets you create a recipe like:\n\t\t *  \n\t\t *     new Recipe({name: \"hot dog\"}).save();\n\t\t * \n\t\t * \n\t\t * ## Implement with a Function\n\t\t * \n\t\t * You can also implement create by yourself. Create gets called \n\t\t * with `attrs`, which are the [can.Map::serialize serialized] model \n\t\t * attributes.  Create returns a `Deferred` \n\t\t * that contains the id of the new instance and any other \n\t\t * properties that should be set on the instance.\n\t\t *  \n\t\t * For example, the following code makes a request \n\t\t * to `POST /recipes.json {'name': 'hot+dog'}` and gets back\n\t\t * something that looks like:\n\t\t *  \n\t\t *     { \n\t\t *       \"id\": 5,\n\t\t *       \"createdAt\": 2234234329\n\t\t *     }\n\t\t * \n\t\t * The code looks like:\n\t\t * \n\t\t *     can.Model.extend(\"Recipe\", {\n\t\t *       create : function( attrs ){\n\t\t *         return $.post(\"/recipes.json\",attrs, undefined ,\"json\");\n\t\t *       }\n\t\t *     },{})\n\t\t */\n\t\tcreate : {\n\t\t\turl : \"_shortName\",\n\t\t\ttype :\"post\"\n\t\t},\n\t\t/**\n\t\t * @description Update a resource on the server.\n\t\t * @function can.Model.update update\n\t\t * @parent can.Model.static\n\t\t * @signature `can.Model.update: \"[METHOD] /path/to/resource\"`\n\t\t * If you provide a URL, the Model will send a request to that URL using\n\t\t * the method specified (or PUT if none is specified) when updating an\n\t\t * instance on the server. (See below for more details.)\n\t\t * @return {can.Deferred} A Deferred that resolves to the updated model.\n\t\t *\n\t\t * @signature `can.Model.update: function(id, serialized) -> can.Deffered`\n\t\t * If you provide a function, the Model will expect you to do your own AJAX requests.\n\t\t * @param {*} id The ID of the model to update.\n\t\t * @param {Object} serialized The [can.Map::serialize serialized] properties of\n\t\t * the model to update.\n\t\t * @return {can.Deferred} A Deferred that resolves to the updated model.\n\t\t *\n\t\t * @body\n\t\t * `update( id, attrs ) -> Deferred` is used by [can.Model::save save] to \n\t\t * update a model instance on the server. \n\t\t * \n\t\t * ## Implement with a URL\n\t\t * \n\t\t * The easist way to implement update is to just give it the url to `PUT` data to:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       update: \"/recipes/{id}\"\n\t\t *     },{});\n\t\t *     \n\t\t * This lets you update a recipe like:\n\t\t *  \n\t\t *     Recipe.findOne({id: 1}, function(recipe){\n\t\t *       recipe.attr('name','salad');\n\t\t *       recipe.save();\n\t\t *     })\n\t\t * \n\t\t * This will make an XHR request like:\n\t\t * \n\t\t *     PUT /recipes/1 \n\t\t *     name=salad\n\t\t *  \n\t\t * If your server doesn't use PUT, you can change it to post like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       update: \"POST /recipes/{id}\"\n\t\t *     },{});\n\t\t * \n\t\t * The server should send back an object with any new attributes the model \n\t\t * should have.  For example if your server updates the \"updatedAt\" property, it\n\t\t * should send back something like:\n\t\t * \n\t\t *     // PUT /recipes/4 {name: \"Food\"} ->\n\t\t *     {\n\t\t *       updatedAt : \"10-20-2011\"\n\t\t *     }\n\t\t * \n\t\t * ## Implement with a Function\n\t\t * \n\t\t * You can also implement update by yourself.  Update takes the `id` and\n\t\t * `attributes` of the instance to be updated.  Update must return\n\t\t * a [can.Deferred Deferred] that resolves to an object that contains any \n\t\t * properties that should be set on the instance.\n\t\t *  \n\t\t * For example, the following code makes a request \n\t\t * to '/recipes/5.json?name=hot+dog' and gets back\n\t\t * something that looks like:\n\t\t *  \n\t\t *     { \n\t\t *       updatedAt: \"10-20-2011\"\n\t\t *     }\n\t\t * \n\t\t * The code looks like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       update : function(id, attrs ) {\n\t\t *         return $.post(\"/recipes/\"+id+\".json\",attrs, null,\"json\");\n\t\t *       }\n\t\t *     },{});\n\t\t */\n\t\tupdate : {\n\t\t\tdata : function(id, attrs){\n\t\t\t\tattrs = attrs || {};\n\t\t\t\tvar identity = this.id;\n\t\t\t\tif ( attrs[identity] && attrs[identity] !== id ) {\n\t\t\t\t\tattrs[\"new\" + can.capitalize(id)] = attrs[identity];\n\t\t\t\t\tdelete attrs[identity];\n\t\t\t\t}\n\t\t\t\tattrs[identity] = id;\n\t\t\t\treturn attrs;\n\t\t\t},\n\t\t\ttype : \"put\"\n\t\t},\n\t\t/**\n\t\t * @description Destroy a resource on the server.\n\t\t * @function can.Model.destroy destroy\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * @signature `can.Model.destroy: function(id) -> deferred`\n\t\t * \n\t\t * \n\t\t * \n\t\t * If you provide a function, the Model will expect you to do your own AJAX requests.\n\t\t * @param {*} id The ID of the resource to destroy.\n\t\t * @return {can.Deferred} A Deferred that resolves to the destroyed model.\n\t\t * \n\t\t * \n\t\t * @signature `can.Model.destroy: \"[METHOD] /path/to/resource\"`\n\t\t * \n\t\t * If you provide a URL, the Model will send a request to that URL using\n\t\t * the method specified (or DELETE if none is specified) when deleting an\n\t\t * instance on the server. (See below for more details.)\n\t\t * \n\t\t * @return {can.Deferred} A Deferred that resolves to the destroyed model.\n\t\t *\n\t\t *\n\t\t *\n\t\t * @body\n\t\t * `destroy(id) -> Deferred` is used by [can.Model::destroy] remove a model \n\t\t * instance from the server.\n\t\t * \n\t\t * ## Implement with a URL\n\t\t * \n\t\t * You can implement destroy with a string like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       destroy : \"/recipe/{id}\"\n\t\t *     },{})\n\t\t * \n\t\t * And use [can.Model::destroy] to destroy it like:\n\t\t * \n\t\t *     Recipe.findOne({id: 1}, function(recipe){\n\t\t * \t      recipe.destroy();\n\t\t *     });\n\t\t * \n\t\t * This sends a `DELETE` request to `/thing/destroy/1`.\n\t\t * \n\t\t * If your server does not support `DELETE` you can override it like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       destroy : \"POST /recipe/destroy/{id}\"\n\t\t *     },{})\n\t\t * \n\t\t * ## Implement with a function\n\t\t * \n\t\t * Implement destroy with a function like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       destroy : function(id){\n\t\t *         return $.post(\"/recipe/destroy/\"+id,{});\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * Destroy just needs to return a deferred that resolves.\n\t\t */\n\t\tdestroy : {\n\t\t\ttype : \"delete\",\n\t\t\tdata : function(id, attrs){\n\t\t\t\tattrs = attrs || {};\n\t\t\t\tattrs.id = attrs[this.id] = id;\n\t\t\t\treturn attrs;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @description Retrieve multiple resources from a server.\n\t\t * @function can.Model.findAll findAll\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * @signature `can.Model.findAll( params[, success[, error]] )`\n\t\t * \n\t\t * Retrieve multiple resources from a server.\n\t\t * \n\t\t * @param {Object} params Values to filter the request or results with.\n\t\t * @param {function(can.Model.List)} [success(list)] A callback to call on successful retrieval. The callback recieves\n\t\t * a can.Model.List of the retrieved resources.\n\t\t * @param {function(can.AjaxSettings)} [error(xhr)] A callback to call when an error occurs. The callback receives the\n\t\t * XmlHttpRequest object.\n\t\t * @return {can.Deferred} A deferred that resolves to a [can.Model.List] of retrieved models.\n\t\t *\n\t\t * \n\t\t * @signature `can.Model.findAll: findAllData( params ) -> deferred`\n\t\t * \n\t\t * Implements `findAll` with a [can.Model.findAllData function]. This function\n\t\t * is passed to [can.Model.makeFindAll makeFindAll] to create the external \n\t\t * `findAll` method.\n\t\t * \n\t\t *     findAll: function(params){\n\t\t *       return $.get(\"/tasks\",params)  \n\t\t *     }\n\t\t * \n\t\t * @param {can.Model.findAllData} findAllData A function that accepts parameters\n\t\t * specifying a list of instance data to retrieve and returns a [can.Deferred]\n\t\t * that resolves to an array of those instances.\n\t\t * \n\t\t * @signature `can.Model.findAll: \"[METHOD] /path/to/resource\"`\n\t\t * \n\t\t * Implements `findAll` with a HTTP method and url to retrieve instance data. \n\t\t * \n\t\t *     findAll: \"GET /tasks\"\n\t\t * \n\t\t * If `findAll` is implemented with a string, this gets converted to \n\t\t * a [can.Model.findAllData findAllData function]\n\t\t * which is passed to [can.Model.makeFindAll makeFindAll] to create the external \n\t\t * `findAll` method.\n\t\t * \n\t\t * @param {HttpMethod} METHOD An HTTP method. Defaults to `\"GET\"`.\n\t\t * \n\t\t * @param {STRING} url The URL of the service to retrieve JSON data.\n\t\t * \n\t\t * @return {JSON} The service should return a JSON object like:\n\t\t * \n\t\t *     {\n\t\t *       \"data\": [\n\t\t *         { \"id\" : 1, \"name\" : \"do the dishes\" },\n\t\t *         { \"id\" : 2, \"name\" : \"mow the lawn\" },\n\t\t *         { \"id\" : 3, \"name\" : \"iron my shirts\" }\n\t\t *       ]\n\t\t *     }\n\t\t * \n\t\t * This object is passed to [can.Model.models] to turn it into instances.\n\t\t * \n\t\t * _Note: .findAll can also accept an array, but you \n\t\t * probably [should not be doing that](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)._\n\t\t * \n\t\t * \n\t\t * @signature `can.Model.findAll: {ajaxSettings}`\n\t\t * \n\t\t * Implements `findAll` with a [can.AjaxSettings ajax settings object].\n\t\t * \n\t\t *     findAll: {url: \"/tasks\", dataType: \"json\"}\n\t\t * \n\t\t * If `findAll` is implemented with an object, it gets converted to \n\t\t * a [can.Model.findAllData findAllData function]\n\t\t * which is passed to [can.Model.makeFindAll makeFindAll] to create the external \n\t\t * `findAll` method.\n\t\t * \n\t\t * @param {can.AjaxSettings} ajaxSettings A settings object that\n\t\t * specifies the options available to pass to [can.ajax].\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `findAll( params, success(instances), error(xhr) ) -> Deferred` is used to retrieve model \n\t\t * instances from the server. After implementing `findAll`, use it to retrieve instances of the model\n\t\t * like:\n\t\t * \n\t\t *     Recipe.findAll({favorite: true}, function(recipes){\n\t\t *       recipes[0].attr('name') //-> \"Ice Water\"\n\t\t *     }, function( xhr ){\n\t\t *       // called if an error\n\t\t *     }) //-> Deferred\n\t\t * \n\t\t * \n\t\t * Before you can use `findAll`, you must implement it.\n\t\t * \n\t\t * ## Implement with a URL\n\t\t * \n\t\t * Implement findAll with a url like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findAll : \"/recipes.json\"\n\t\t *     },{});\n\t\t * \n\t\t * The server should return data that looks like:\n\t\t * \n\t\t *     [\n\t\t *       {\"id\" : 57, \"name\": \"Ice Water\"},\n\t\t *       {\"id\" : 58, \"name\": \"Toast\"}\n\t\t *     ]\n\t\t * \n\t\t * ## Implement with an Object\n\t\t * \n\t\t * Implement findAll with an object that specifies the parameters to\n\t\t * `can.ajax` (jQuery.ajax) like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findAll : {\n\t\t *         url: \"/recipes.xml\",\n\t\t *         dataType: \"xml\"\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * ## Implement with a Function\n\t\t * \n\t\t * To implement with a function, `findAll` is passed __params__ to filter\n\t\t * the instances retrieved from the server and it should return a\n\t\t * deferred that resolves to an array of model data. For example:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findAll : function(params){\n\t\t *         return $.ajax({\n\t\t *           url: '/recipes.json',\n\t\t *           type: 'get',\n\t\t *           dataType: 'json'})\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t */\n\t\tfindAll : {\n\t\t\turl : \"_shortName\"\n\t\t},\n\t\t/**\n\t\t * @description Retrieve a resource from a server.\n\t\t * @function can.Model.findOne findOne\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * @signature `can.Model.findOne( params[, success[, error]] )`\n\t\t * \n\t\t * Retrieve a single instance from the server.\n\t\t * \n\t\t * @param {Object} params Values to filter the request or results with.\n\t\t * @param {function(can.Model)} [success(model)] A callback to call on successful retrieval. The callback recieves\n\t\t * the retrieved resource as a can.Model.\n\t\t * @param {function(can.AjaxSettings)} [error(xhr)] A callback to call when an error occurs. The callback receives the\n\t\t * XmlHttpRequest object.\n\t\t * @return {can.Deferred} A deferred that resolves to a [can.Model.List] of retrieved models.\n\t\t * \n\t\t * @signature `can.Model.findOne: findOneData( params ) -> deferred`\n\t\t * \n\t\t * Implements `findOne` with a [can.Model.findOneData function]. This function\n\t\t * is passed to [can.Model.makeFindOne makeFindOne] to create the external \n\t\t * `findOne` method.\n\t\t * \n\t\t *     findOne: function(params){\n\t\t *       return $.get(\"/task/\"+params.id)  \n\t\t *     }\n\t\t * \n\t\t * @param {can.Model.findOneData} findOneData A function that accepts parameters\n\t\t * specifying an instance to retreive and returns a [can.Deferred]\n\t\t * that resolves to that instance.\n\t\t * \n\t\t * @signature `can.Model.findOne: \"[METHOD] /path/to/resource\"`\n\t\t * \n\t\t * Implements `findOne` with a HTTP method and url to retrieve an instance's data. \n\t\t * \n\t\t *     findOne: \"GET /tasks/{id}\"\n\t\t * \n\t\t * If `findOne` is implemented with a string, this gets converted to \n\t\t * a [can.Model.makeFindOne makeFindOne function]\n\t\t * which is passed to [can.Model.makeFindOne makeFindOne] to create the external \n\t\t * `findOne` method.\n\t\t * \n\t\t * @param {HttpMethod} METHOD An HTTP method. Defaults to `\"GET\"`.\n\t\t * \n\t\t * @param {STRING} url The URL of the service to retrieve JSON data.\n\t\t * \n\t\t * @signature `can.Model.findOne: {ajaxSettings}`\n\t\t * \n\t\t * Implements `findOne` with a [can.AjaxSettings ajax settings object].\n\t\t * \n\t\t *     findOne: {url: \"/tasks/{id}\", dataType: \"json\"}\n\t\t * \n\t\t * If `findOne` is implemented with an object, it gets converted to \n\t\t * a [can.Model.makeFindOne makeFindOne function]\n\t\t * which is passed to [can.Model.makeFindOne makeFindOne] to create the external \n\t\t * `findOne` method.\n\t\t * \n\t\t * @param {can.AjaxSettings} ajaxSettings A settings object that\n\t\t * specifies the options available to pass to [can.ajax].\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `findOne( params, success(instance), error(xhr) ) -> Deferred` is used to retrieve a model \n\t\t * instance from the server. \n\t\t * \n\t\t * Use `findOne` like:\n\t\t * \n\t\t *     Recipe.findOne({id: 57}, function(recipe){\n\t\t * \t     recipe.attr('name') //-> \"Ice Water\"\n\t\t *     }, function( xhr ){\n\t\t * \t     // called if an error\n\t\t *     }) //-> Deferred\n\t\t * \n\t\t * Before you can use `findOne`, you must implement it.\n\t\t * \n\t\t * ## Implement with a URL\n\t\t * \n\t\t * Implement findAll with a url like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findOne : \"/recipes/{id}.json\"\n\t\t *     },{});\n\t\t * \n\t\t * If `findOne` is called like:\n\t\t * \n\t\t *     Recipe.findOne({id: 57});\n\t\t * \n\t\t * The server should return data that looks like:\n\t\t * \n\t\t *     {\"id\" : 57, \"name\": \"Ice Water\"}\n\t\t * \n\t\t * ## Implement with an Object\n\t\t * \n\t\t * Implement `findOne` with an object that specifies the parameters to\n\t\t * `can.ajax` (jQuery.ajax) like:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findOne : {\n\t\t *         url: \"/recipes/{id}.xml\",\n\t\t *         dataType: \"xml\"\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * ## Implement with a Function\n\t\t * \n\t\t * To implement with a function, `findOne` is passed __params__ to specify\n\t\t * the instance retrieved from the server and it should return a\n\t\t * deferred that resolves to the model data.  Also notice that you now need to\n\t\t * build the URL manually. For example:\n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       findOne : function(params){\n\t\t *         return $.ajax({\n\t\t *           url: '/recipes/' + params.id,\n\t\t *           type: 'get',\n\t\t *           dataType: 'json'})\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * \n\t\t */\n\t\tfindOne: {}\n\t},\n\t\t// Makes an ajax request `function` from a string.\n\t\t//\t\t`ajaxMethod` - The `ajaxMethod` object defined above.\n\t\t//\t\t`str` - The string the user provided. Ex: `findAll: \"/recipes.json\"`.\n\t\tajaxMaker = function(ajaxMethod, str){\n\t\t\t// Return a `function` that serves as the ajax method.\n\t\t\treturn function(data){\n\t\t\t\t// If the ajax method has it's own way of getting `data`, use that.\n\t\t\t\tdata = ajaxMethod.data ? \n\t\t\t\t\tajaxMethod.data.apply(this, arguments) :\n\t\t\t\t\t// Otherwise use the data passed in.\n\t\t\t\t\tdata;\n\t\t\t\t// Return the ajax method with `data` and the `type` provided.\n\t\t\t\treturn ajax(str || this[ajaxMethod.url || \"_url\"], data, ajaxMethod.type || \"get\")\n\t\t\t}\n\t\t};\n\n\n\t\n\t\n\tcan.Model = can.Map({\n\t\tfullName: \"can.Model\",\n\t\t_reqs: 0,\n\t\t/**\n\t\t * @hide\n\t\t * @function can.Model.setup\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * Configures \n\t\t * \n\t\t */\n\t\tsetup : function(base){\n\t\t\t// create store here if someone wants to use model without inheriting from it\n\t\t\tthis.store = {};\n\t\t\tcan.Map.setup.apply(this, arguments);\n\t\t\t// Set default list as model list\n\t\t\tif(!can.Model){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/**\n\t\t\t * @property {can.Model.List} can.Model.static.List List\n\t\t\t * @parent can.Model.static\n\t\t\t * \n\t\t\t * @description Specifies the type of List that [can.Model.findAll findAll]\n\t\t\t * should return.\n\t\t\t * \n\t\t\t * @option {can.Model.List} A can.Model's List property is the\n\t\t\t * type of [can.List List] returned \n\t\t\t * from [can.Model.findAll findAll]. For example:\n\t\t\t * \n\t\t\t *     Task = can.Model.extend({\n\t\t\t *       findAll: \"/tasks\"\n\t\t\t *     },{})\n\t\t\t *     \n\t\t\t *     Task.findAll({}, function(tasks){\n\t\t\t *       tasks instanceof Task.List //-> true\n\t\t\t *     })\n\t\t\t * \n\t\t\t * Overwrite a Model's `List` property to add custom \n\t\t\t * behavior to the lists provided to `findAll` like:\n\t\t\t * \n\t\t\t *     Task = can.Model.extend({\n\t\t\t *       findAll: \"/tasks\"\n\t\t\t *     },{})\n\t\t\t *     Task.List = Task.List.extend({\n\t\t\t *       completed: function(){\n\t\t\t *         var count = 0;\n\t\t\t *         this.each(function(task){\n\t\t\t *           if( task.attr(\"completed\") ) count++;\n\t\t\t *         })\n\t\t\t *         return count;\n\t\t\t *       }\n\t\t\t *     })\n\t\t\t *     \n\t\t\t *     Task.findAll({}, function(tasks){\n\t\t\t *       tasks.completed() //-> 3\n\t\t\t *     })\n\t\t\t * \n\t\t\t * When [can.Model] is extended,\n\t\t\t * [can.Model.List] is extended and set as the extended Model's\n\t\t\t * `List` property. The extended list's [can.List.Map Map] property\n\t\t\t * is set to the extended Model.  For example:\n\t\t\t * \n\t\t\t *     Task = can.Model.extend({\n\t\t\t *       findAll: \"/tasks\"\n\t\t\t *     },{})\n\t\t\t *     Task.List.Map //-> Task\n\t\t\t * \n\t\t\t */\n\t\t\tthis.List = ML({Map: this},{});\n\t\t\tvar self = this,\n\t\t\t\tclean = can.proxy(this._clean, self);\n\t\t\t\n\t\t\t\n\t\t\t// go through ajax methods and set them up\n\t\t\tcan.each(ajaxMethods, function(method, name){\n\t\t\t\t// if an ajax method is not a function, it's either\n\t\t\t\t// a string url like findAll: \"/recipes\" or an\n\t\t\t\t// ajax options object like {url: \"/recipes\"}\n\t\t\t\tif ( ! can.isFunction( self[name] )) {\n\t\t\t\t\t// use ajaxMaker to convert that into a function\n\t\t\t\t\t// that returns a deferred with the data\n\t\t\t\t\tself[name] = ajaxMaker(method, self[name]);\n\t\t\t\t}\n\t\t\t\t// check if there's a make function like makeFindAll\n\t\t\t\t// these take deferred function and can do special\n\t\t\t\t// behavior with it (like look up data in a store)\n\t\t\t\tif (self[\"make\"+can.capitalize(name)]){\n\t\t\t\t\t// pass the deferred method to the make method to get back\n\t\t\t\t\t// the \"findAll\" method.\n\t\t\t\t\tvar newMethod = self[\"make\"+can.capitalize(name)](self[name]);\n\t\t\t\t\tcan.Construct._overwrite(self, base, name,function(){\n\t\t\t\t\t\t// increment the numer of requests\n\t\t\t\t\t\tcan.Model._reqs++;\n\t\t\t\t\t\tvar def = newMethod.apply(this, arguments);\n\t\t\t\t\t\tvar then = def.then(clean, clean);\n\t\t\t\t\t\tthen.abort = def.abort;\n\n\t\t\t\t\t\t// attach abort to our then and return it\n\t\t\t\t\t\treturn then;\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t});\n\t\t\tcan.each(initializers, function(makeInitializer, name){\n\t\t\t\tif( typeof self[name] === \"string\" ) {\n\t\t\t\t\tcan.Construct._overwrite( self, base, name, makeInitializer( self[name] ) )\n\t\t\t\t}\n\t\t\t})\n\t\t\tif(self.fullName == \"can.Model\" || !self.fullName){\n\t\t\t\tself.fullName = \"Model\"+(++modelNum);\n\t\t\t}\n\t\t\t// Add ajax converters.\n\t\t\tcan.Model._reqs = 0;\n\t\t\tthis._url = this._shortName+\"/{\"+this.id+\"}\"\n\t\t},\n\t\t_ajax : ajaxMaker,\n\t\t_makeRequest : makeRequest,\n\t\t_clean : function(){\n\t\t\tcan.Model._reqs--;\n\t\t\tif(!can.Model._reqs){\n\t\t\t\tfor(var id in this.store) {\n\t\t\t\t\tif(!this.store[id]._bindings){\n\t\t\t\t\t\tdelete this.store[id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments[0];\n\t\t},\n\t\t/**\n\t\t * @function can.Model.models models\n\t\t * @parent can.Model.static\n\t\t * @description Convert raw data into can.Model instances.\n\t\t * \n\t\t * @signature `can.Model.models(data[, oldList])`\n\t\t * @param {Array<Object>} data The raw data from a `[can.Model.findAll findAll()]` request.\n\t\t * @param {can.Model.List} [oldList] If supplied, this List will be updated with the data from\n\t\t * __data__.\n\t\t * @return {can.Model.List} A List of Models made from the raw data.\n\t\t * \n\t\t * @signature `models: \"PROPERTY\"`\n\t\t * \n\t\t * Creates a `models` function that looks for the array of instance data in the PROPERTY\n\t\t * property of the raw response data of [can.Model.findAll].\n\t\t * \n\t\t * @body\n\t\t * `can.Model.models(data, xhr)` is used to \n\t\t * convert the raw response of a [can.Model.findAll] request \n\t\t * into a [can.Model.List] of model instances.  \n\t\t * \n\t\t * This method is rarely called directly. Instead the deferred returned\n\t\t * by findAll is piped into `models`.  This creates a new deferred that\n\t\t * resolves to a [can.Model.List] of instances instead of an array of\n\t\t * simple JS objects.\n\t\t * \n\t\t * If your server is returning data in non-standard way,\n\t\t * overwriting `can.Model.models` is the best way to normalize it.\n\t\t * \n\t\t * ## Quick Example\n\t\t * \n\t\t * The following uses models to convert to a [can.Model.List] of model\n\t\t * instances.\n\t\t * \n\t\t *     Task = can.Model.extend()\n\t\t *     var tasks = Task.models([\n\t\t *       {id: 1, name : \"dishes\", complete : false},\n\t\t *       {id: 2, name: \"laundry\", compelte: true}\n\t\t *     ])\n\t\t *     \n\t\t *     tasks.attr(\"0.complete\", true)\n\t\t * \n\t\t * ## Non-standard Services\n\t\t * \n\t\t * `can.Model.models` expects data to be an array of name-value pair \n\t\t * objects like:\n\t\t * \n\t\t *     [{id: 1, name : \"dishes\"},{id:2, name: \"laundry\"}, ...]\n\t\t *     \n\t\t * It can also take an object with additional data about the array like:\n\t\t * \n\t\t *     {\n\t\t *       count: 15000 //how many total items there might be\n\t\t *       data: [{id: 1, name : \"justin\"},{id:2, name: \"brian\"}, ...]\n\t\t *     }\n\t\t * \n\t\t * In this case, models will return a [can.Model.List] of instances found in \n\t\t * data, but with additional properties as expandos on the list:\n\t\t * \n\t\t *     var tasks = Task.models({\n\t\t *       count : 1500,\n\t\t *       data : [{id: 1, name: 'dishes'}, ...]\n\t\t *     })\n\t\t *     tasks.attr(\"name\") // -> 'dishes'\n\t\t *     tasks.count // -> 1500\n\t\t * \n\t\t * ### Overwriting Models\n\t\t * \n\t\t * If your service returns data like:\n\t\t * \n\t\t *     {thingsToDo: [{name: \"dishes\", id: 5}]}\n\t\t * \n\t\t * You will want to overwrite models to pass the base models what it expects like:\n\t\t * \n\t\t *     Task = can.Model.extend({\n\t\t *       models : function(data){\n\t\t *         return can.Model.models.call(this,data.thingsToDo);\n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * `can.Model.models` passes each instance's data to `can.Model.model` to\n\t\t * create the individual instances.\n\t\t */\n\t\tmodels: initializers.models(\"data\"),\n\t\t/**\n\t\t * @function can.Model.model model\n\t\t * @parent can.Model.static\n\t\t * @description Convert raw data into a can.Model instance.\n\t\t * @signature `can.Model.model(data)`\n\t\t * @param {Object} data The data to convert to a can.Model instance.\n\t\t * @return {can.Model} An instance of can.Model made with the given data.\n\t\t * \n\t\t * @signature `model: \"PROPERTY\"`\n\t\t * \n\t\t * Creates a `model` function that looks for the attributes object in the PROPERTY\n\t\t * property of raw instance data.\n\t\t * \n\t\t * @body\n\t\t * `can.Model.model(attributes)` is used to convert data from the server into\n\t\t * a model instance.  It is rarely called directly.  Instead it is invoked as \n\t\t * a result of [can.Model.findOne] or [can.Model.findAll].  \n\t\t * \n\t\t * If your server is returning data in non-standard way,\n\t\t * overwriting `can.Model.model` is a good way to normalize it.\n\t\t * \n\t\t * ## Example\n\t\t * \n\t\t * The following uses `model` to convert to a model\n\t\t * instance.\n\t\t * \n\t\t *     Task = can.Model.extend({},{})\n\t\t *     var task = Task.model({id: 1, name : \"dishes\", complete : false})\n\t\t *     \n\t\t *     tasks.attr(\"complete\", true)\n\t\t * \n\t\t * `Task.model(attrs)` is very similar to simply calling `new Model(attrs)` except\n\t\t * that it checks the model's store if the instance has already been created.  The model's \n\t\t * store is a collection of instances that have event handlers.  \n\t\t * \n\t\t * This means that if the model's store already has an instance, you'll get the same instance\n\t\t * back.  Example:\n\t\t * \n\t\t *     // create a task\n\t\t *     var taskA = new Task({id: 5, complete: true});\n\t\t * \n\t\t *     // bind to it, which puts it in the store\n\t\t * \t   taskA.bind(\"complete\", function(){});\n\t\t *     \n\t\t *     // use model to create / retrieve a task\n\t\t *     var taskB = Task.model({id: 5, complete: true});\n\t\t *     \n\t\t *     taskA === taskB //-> true\n\t\t * \n\t\t * ## Non-standard Services\n\t\t * \n\t\t * `can.Model.model` expects to retreive attributes of the model \n\t\t * instance like:\n\t\t * \n\t\t * \n\t\t *     {id: 5, name : \"dishes\"}\n\t\t *     \n\t\t * \n\t\t * If the service returns data formatted differently, like:\n\t\t * \n\t\t *     {todo: {name: \"dishes\", id: 5}}\n\t\t * \n\t\t * Overwrite `model` like:\n\t\t * \n\t\t *     Task = can.Model.extend({\n\t\t *       model : function(data){\n\t\t *         return can.Model.model.call(this,data.todo);\n\t\t *       }\n\t\t *     },{});\n\t\t */\n\t\tmodel: initializers.model()\n\t},\n\n\n\t/**\n\t * @prototype\n\t */\n\t{\n\t\tsetup: function(attrs){\n\t\t\t// try to add things as early as possible to the store (#457)\n\t\t\t// we add things to the store before any properties are even set\n\t\t\tvar id = attrs && attrs[this.constructor.id];\n\t\t\tif(can.Model._reqs && id != null ){\n\t\t\t\tthis.constructor.store[id] = this;\n\t\t\t}\n\t\t\tcan.Map.prototype.setup.apply(this, arguments)\n\t\t},\n\t\t/**\n\t\t * @function can.Model.prototype.isNew isNew\n\t\t * @description Check if a Model has yet to be saved on the server.\n\t\t * @signature `model.isNew()`\n\t\t * @return {Boolean} Whether an instance has been saved on the server.\n\t\t * (This is determined by whether `id` has a value set yet.)\n\t\t *\n\t\t * @body\n\t\t * `isNew()` returns if the instance is has been created \n\t\t * on the server. This is essentially if the [can.Model.id]\n\t\t * property is null or undefined.\n\t\t * \n\t\t *     new Recipe({id: 1}).isNew() //-> false\n\t\t */\n\t\tisNew: function() {\n\t\t\tvar id = getId(this);\n\t\t\treturn ! ( id || id === 0 ); // If `null` or `undefined`\n\t\t},\n\t\t/**\n\t\t * @function can.Model.prototype.save save\n\t\t * @description Save a model back to the server.\n\t\t * @signature `model.save([success[, error]])`\n\t\t * @param {function} [success] A callback to call on successful save. The callback recieves\n\t\t * the can.Model after saving.\n\t\t * @param {function} [error] A callback to call when an error occurs. The callback receives the\n\t\t * XmlHttpRequest object.\n\t\t * @return {can.Deferred} A Deferred that resolves to the Model after it has been saved.\n\t\t *\n\t\t * @body\n\t\t * `model.save([success(model)],[error(xhr)])` creates or updates \n\t\t * the model instance using [can.Model.create] or\n\t\t * [can.Model.update] depending if the instance\n\t\t * [can.Model::isNew has an id or not].\n\t\t * \n\t\t * ## Using `save` to create an instance.\n\t\t * \n\t\t * If `save` is called on an instance that does not have \n\t\t * an [can.Model.id id] property, it calls [can.Model.create]\n\t\t * with the instance's properties.  It also [can.trigger triggers]\n\t\t * a \"created\" event on the instance and the model.\n\t\t * \n\t\t *     // create a model instance\n\t\t *     var todo = new Todo({name: \"dishes\"})\n\t\t *     \n\t\t *     // listen when the instance is created\n\t\t *     todo.bind(\"created\", function(ev){\n\t\t * \t     this //-> todo\n\t\t *     })\n\t\t *     \n\t\t *     // save it on the server\n\t\t *     todo.save(function(todo){\n\t\t * \t     console.log(\"todo\", todo, \"created\")\n\t\t *     });\n\t\t * \n\t\t * ## Using `save` to update an instance.\n\t\t * \n\t\t * If save is called on an instance that has \n\t\t * an [can.Model.id id] property, it calls [can.Model.create]\n\t\t * with the instance's properties.  When the save is complete,\n\t\t * it triggers an \"updated\" event on the instance and the instance's model.\n\t\t * \n\t\t * Instances with an\n\t\t * __id__ are typically retrieved with [can.Model.findAll] or\n\t\t * [can.Model.findOne].  \n\t\t * \n\t\t *  \n\t\t *     // get a created model instance\n\t\t *     Todo.findOne({id: 5},function(todo){\n\t\t *       \t     \n\t\t *       // listen when the instance is updated\n\t\t *       todo.bind(\"updated\", function(ev){\n\t\t * \t       this //-> todo\n\t\t *       })\n\t\t * \n\t\t *       // update the instance's property\n\t\t *       todo.attr(\"complete\", true)\n\t\t *       \n\t\t *       // save it on the server\n\t\t *       todo.save(function(todo){\n\t\t * \t       console.log(\"todo\", todo, \"updated\")\n\t\t *       });\n\t\t * \n\t\t *     });\n\t\t * \n\t\t */\n\t\tsave: function( success, error ) {\n\t\t\treturn makeRequest(this, this.isNew() ? 'create' : 'update', success, error);\n\t\t},\n\t\t/**\n\t\t * @function can.Model.prototype.destroy destroy\n\t\t * @description Destroy a Model on the server.\n\t\t * @signature `model.destroy([success[, error]])`\n\t\t * @param {function} [success] A callback to call on successful destruction. The callback recieves\n\t\t * the can.Model as it was just prior to destruction.\n\t\t * @param {function} [error] A callback to call when an error occurs. The callback receives the\n\t\t * XmlHttpRequest object.\n\t\t * @return {can.Deferred} A Deferred that resolves to the Model as it was before destruction.\n\t\t *\n\t\t * @body\n\t\t * Destroys the instance by calling \n\t\t * [Can.Model.destroy] with the id of the instance.\n\t\t * \n\t\t *     recipe.destroy(success, error);\n\t\t * \n\t\t * This triggers \"destroyed\" events on the instance and the \n\t\t * Model constructor function which can be listened to with\n\t\t * [can.Model::bind] and [can.Model.bind]. \n\t\t * \n\t\t *     Recipe = can.Model.extend({\n\t\t *       destroy : \"DELETE /services/recipes/{id}\",\n\t\t *       findOne : \"/services/recipes/{id}\"\n\t\t *     },{})\n\t\t *     \n\t\t *     Recipe.bind(\"destroyed\", function(){\n\t\t *       console.log(\"a recipe destroyed\");\t\n\t\t *     });\n\t\t * \n\t\t *     // get a recipe\n\t\t *     Recipe.findOne({id: 5}, function(recipe){\n\t\t *       recipe.bind(\"destroyed\", function(){\n\t\t *         console.log(\"this recipe destroyed\")\t\n\t\t *       })\n\t\t *       recipe.destroy();\n\t\t *     })\n\t\t */\n\t\tdestroy: function( success, error ) {\n\t\t\tif(this.isNew()) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar def = can.Deferred();\n\t\t\t\tdef.then(success, error);\n\t\t\t\treturn def.done(function(data) {\n\t\t\t\t\tself.destroyed(data)\n\t\t\t\t}).resolve(self);\n\t\t\t}\n\t\t\treturn makeRequest(this, 'destroy', success, error, 'destroyed');\n\t\t},\n\t\t/**\n\t\t * @description Listen to events on this Model.\n\t\t * @function can.Model.prototype.bind bind\n\t\t * @signature `model.bind(eventName, handler)`\n\t\t * @param {String} eventName The event to bind to.\n\t\t * @param {function} handler The function to call when the\n\t\t * event occurs. __handler__ is passed the event and the\n\t\t * Model instance.\n\t\t * @return {can.Model} The Model, for chaining.\n\t\t * \n\t\t * @body\n\t\t * `bind(eventName, handler(ev, args...) )` is used to listen\n\t\t * to events on this model instance.  Example:\n\t\t * \n\t\t *     Task = can.Model.extend()\n\t\t *     var task = new Task({name : \"dishes\"})\n\t\t *     task.bind(\"name\", function(ev, newVal, oldVal){})\n\t\t * \n\t\t * Use `bind` the\n\t\t * same as [can.Map::bind] which should be used as\n\t\t * a reference for listening to property changes.\n\t\t * \n\t\t * Bind on model can be used to listen to when \n\t\t * an instance is:\n\t\t * \n\t\t *  - created\n\t\t *  - updated\n\t\t *  - destroyed\n\t\t * \n\t\t * like:\n\t\t * \n\t\t *     Task = can.Model.extend()\n\t\t *     var task = new Task({name : \"dishes\"})\n\t\t * \n\t\t *     task.bind(\"created\", function(ev, newTask){\n\t\t * \t     console.log(\"created\", newTask)\n\t\t *     })\n\t\t *     .bind(\"updated\", function(ev, updatedTask){\n\t\t *       console.log(\"updated\", updatedTask)\n\t\t *     })\n\t\t *     .bind(\"destroyed\", function(ev, destroyedTask){\n\t\t * \t     console.log(\"destroyed\", destroyedTask)\n\t\t *     })\n\t\t * \n\t\t *     // create, update, and destroy\n\t\t *     task.save(function(){\n\t\t *       task.attr('name', \"do dishes\")\n\t\t *           .save(function(){\n\t\t * \t            task.destroy()\n\t\t *           })\n\t\t *     }); \n\t\t *     \n\t\t * \n\t\t * `bind` also extends the inherited \n\t\t * behavior of [can.Map::bind] to track the number\n\t\t * of event bindings on this object which is used to store\n\t\t * the model instance.  When there are no bindings, the \n\t\t * model instance is removed from the store, freeing memory.  \n\t\t */\n\t\t_bindsetup: function(){\n\t\t\tthis.constructor.store[this.__get(this.constructor.id)] = this;\n\t\t\treturn can.Map.prototype._bindsetup.apply( this, arguments );\n\t\t},\n\t\t/**\n\t\t * @function can.Model.prototype.unbind unbind\n\t\t * @description Stop listening to events on this Model.\n\t\t * @signature `model.unbind(eventName[, handler])`\n\t\t * @param {String} eventName The event to unbind from.\n\t\t * @param {function} [handler] A handler previously bound with `bind`.\n\t\t * If __handler__ is not passed, `unbind` will remove all handlers\n\t\t * for the given event.\n\t\t * @return {can.Model} The Model, for chaining.\n\t\t *\n\t\t * @body\n\t\t * `unbind(eventName, handler)` removes a listener\n\t\t * attached with [can.Model::bind].\n\t\t * \n\t\t *     var handler = function(ev, createdTask){\n\t\t * \t     \n\t\t *     }\n\t\t *     task.bind(\"created\", handler)\n\t\t *     task.unbind(\"created\", handler)\n\t\t * \n\t\t * You have to pass the same function to `unbind` that you\n\t\t * passed to `bind`.\n\t\t * \n\t\t * Unbind will also remove the instance from the store\n\t\t * if there are no other listeners.\n\t\t */\n\t\t_bindteardown: function(){\n\t\t\tdelete this.constructor.store[getId(this)];\n\t\t\treturn can.Map.prototype._bindteardown.apply( this, arguments );;\n\t\t},\n\t\t// Change `id`.\n\t\t___set: function( prop, val ) {\n\t\t\tcan.Map.prototype.___set.call(this,prop, val)\n\t\t\t// If we add an `id`, move it to the store.\n\t\t\tif(prop === this.constructor.id && this._bindings){\n\t\t\t\tthis.constructor.store[getId(this)] = this;\n\t\t\t}\n\t\t}\n\t});\n\t\n\tcan.each({\n\t\t/**\n\t\t * @function can.Model.makeFindAll\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * @signature `can.Model.makeFindAll: function(findAllData) -> findAll`\n\t\t * \n\t\t * Returns the external `findAll` method given the implemented [can.Model.findAllData findAllData] function.\n\t\t * \n\t\t * @params {can.Model.findAllData}\n\t\t * \n\t\t * [can.Model.findAll] is implemented with a `String`, [can.AjaxSettings ajax settings object], or \n\t\t * [can.Model.findAllData findAllData] function. If it is implemented as\n\t\t * a `String` or [can.AjaxSettings ajax settings object], those values are used\n\t\t * to create a [can.Model.findAllData findAllData] function.\n\t\t * \n\t\t * The [can.Model.findAllData findAllData] function is passed to `makeFindAll`. `makeFindAll`\n\t\t * should use `findAllData` internally to get the raw data for the request. \n\t\t * \n\t\t * @return {function(params,success,error):can.Deferred}\n\t\t * \n\t\t * Returns function that implements the external API of `findAll`. \n\t\t * \n\t\t * @body \n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `makeFindAll` can be used to implement base models that perform special \n\t\t * behavior. `makeFindAll` is passed a [can.Model.findAllData findAllData] function that retrieves raw\n\t\t * data. It should return a function that when called, uses\n\t\t * the findAllData function to get the raw data, convert them to model instances with\n\t\t * [can.Model.models models].\n\t\t * \n\t\t * ## Caching\n\t\t * \n\t\t * The following uses `makeFindAll` to create a base `CachedModel`:\n\t\t * \n\t\t *     CachedModel = can.Model.extend({\n\t\t *       makeFindAll: function(findAllData){\n\t\t *         // A place to store requests\n\t\t *         var cachedRequests = {};\n\t\t * \n\t\t *         return function(params, success, error){\n\t\t *           // is this not cached?\n\t\t *           if(! cachedRequests[JSON.stringify(params)] ) {\n\t\t *             var self = this;\n\t\t *             // make the request for data, save deferred\n\t\t *             cachedRequests[JSON.stringify(params)] = \n\t\t *               findAllData(params).then(function(data){\n\t\t *                 // convert the raw data into instances\n\t\t *                 return self.models(data)\n\t\t *               })\n\t\t *           }\n\t\t *           // get the saved request\n\t\t *           var def = cachedRequests[JSON.stringify(params)]\n\t\t *           // hookup success and error\n\t\t *           def.then(success,error)\n\t\t *           return def;\n\t\t *         }  \n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * The following Todo model will never request the same list of todo's twice:\n\t\t * \n\t\t *     Todo = CachedModel({\n\t\t *       findAll: \"/todos\"\n\t\t *     },{})\n\t\t * \n\t\t *     // widget 1\n\t\t *     Todo.findAll({})\n\t\t * \n\t\t *     // widget 2\n\t\t *     Todo.findAll({})\n\t\t */\n\t\tmakeFindAll : \"models\",\n\t\t/**\n\t\t * @function can.Model.makeFindOne\n\t\t * @parent can.Model.static\n\t\t * \n\t\t * @signature `can.Model.makeFindOne: function(findOneData) -> findOne`\n\t\t * \n\t\t * Returns the external `findOne` method given the implemented [can.Model.findOneData findOneData] function.\n\t\t * \n\t\t * @params {can.Model.findOneData}\n\t\t * \n\t\t * [can.Model.findOne] is implemented with a `String`, [can.AjaxSettings ajax settings object], or \n\t\t * [can.Model.findOneData findOneData] function. If it is implemented as\n\t\t * a `String` or [can.AjaxSettings ajax settings object], those values are used\n\t\t * to create a [can.Model.findOneData findOneData] function.\n\t\t * \n\t\t * The [can.Model.findOneData findOneData] function is passed to `makeFindOne`. `makeFindOne`\n\t\t * should use `findOneData` internally to get the raw data for the request. \n\t\t * \n\t\t * @return {function(params,success,error):can.Deferred}\n\t\t * \n\t\t * Returns function that implements the external API of `findOne`. \n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `makeFindOne` can be used to implement base models that perform special \n\t\t * behavior. `makeFindOne` is passed a [can.Model.findOneData findOneData] function that retrieves raw\n\t\t * data. It should return a function that when called, uses\n\t\t * the findOneData function to get the raw data, convert them to model instances with\n\t\t * [can.Model.models models].\n\t\t * \n\t\t * ## Caching\n\t\t * \n\t\t * The following uses `makeFindOne` to create a base `CachedModel`:\n\t\t * \n\t\t *     CachedModel = can.Model.extend({\n\t\t *       makeFindOne: function(findOneData){\n\t\t *         // A place to store requests\n\t\t *         var cachedRequests = {};\n\t\t * \n\t\t *         return function(params, success, error){\n\t\t *           // is this not cached?\n\t\t *           if(! cachedRequests[JSON.stringify(params)] ) {\n\t\t *             var self = this;\n\t\t *             // make the request for data, save deferred\n\t\t *             cachedRequests[JSON.stringify(params)] = \n\t\t *               findOneData(params).then(function(data){\n\t\t *                 // convert the raw data into instances\n\t\t *                 return self.model(data)\n\t\t *               })\n\t\t *           }\n\t\t *           // get the saved request\n\t\t *           var def = cachedRequests[JSON.stringify(params)]\n\t\t *           // hookup success and error\n\t\t *           def.then(success,error)\n\t\t *           return def;\n\t\t *         }  \n\t\t *       }\n\t\t *     },{})\n\t\t * \n\t\t * The following Todo model will never request the same todo twice:\n\t\t * \n\t\t *     Todo = CachedModel({\n\t\t *       findOne: \"/todos/{id}\"\n\t\t *     },{})\n\t\t * \n\t\t *     // widget 1\n\t\t *     Todo.findOne({id: 5})\n\t\t * \n\t\t *     // widget 2\n\t\t *     Todo.findOne({id: 5})\n\t\t */\n\t\tmakeFindOne: \"model\",\n\t\tmakeCreate: \"model\",\n\t\tmakeUpdate: \"model\"\n\t}, function( method, name ) {\n\t\tcan.Model[name] = function( oldMethod ) {\n\t\t\treturn function() {\n\t\t\t\tvar args = can.makeArray(arguments),\n\t\t\t\t\toldArgs = can.isFunction( args[1] ) ? args.splice( 0, 1 ) : args.splice( 0, 2 ),\n\t\t\t\t\tdef = pipe( oldMethod.apply( this, oldArgs ), this, method );\n\t\t\t\t\tdef.then( args[0], args[1] );\n\t\t\t\t// return the original promise\n\t\t\t\treturn def;\n\t\t\t};\n\t\t};\n\t});\n\t\t\t\t\n\t\tcan.each([\n\t/**\n\t * @function can.Model.prototype.created created\n\t * @hide\n\t * Called by save after a new instance is created.  Publishes 'created'.\n\t * @param {Object} attrs\n\t */\n\t\"created\",\n\t/**\n\t * @function can.Model.prototype.updated updated\n\t * @hide\n\t * Called by save after an instance is updated.  Publishes 'updated'.\n\t * @param {Object} attrs\n\t */\n\t\"updated\",\n\t/**\n\t * @function can.Model.prototype.destroyed destroyed\n\t * @hide\n\t * Called after an instance is destroyed.  \n\t *   - Publishes \"shortName.destroyed\".\n\t *   - Triggers a \"destroyed\" event on this model.\n\t *   - Removes the model from the global list if its used.\n\t * \n\t */\n\t\"destroyed\"], function( funcName ) {\n\t\tcan.Model.prototype[funcName] = function( attrs ) {\n\t\t\tvar stub, \n\t\t\t\tconstructor = this.constructor;\n\n\t\t\t// Update attributes if attributes have been passed\n\t\t\tstub = attrs && typeof attrs == 'object' && this.attr(attrs.attr ? attrs.attr() : attrs);\n\t\t\t\n\t\t\t// triggers change event that bubble's like\n\t\t\t// handler( 'change','1.destroyed' ). This is used\n\t\t\t// to remove items on destroyed from Model Lists.\n\t\t\t// but there should be a better way.\n\t\t\tcan.trigger(this,\"change\",funcName)\n\t\t\n\n\t\t\t// Call event on the instance's Class\n\t\t\tcan.trigger(constructor,funcName, this);\n\t\t};\n\t});\n  \n  // Model lists are just like `Map.List` except that when their items are \n  // destroyed, it automatically gets removed from the list.\n\tvar ML = can.Model.List = can.List({\n\t\tsetup: function(params){\n\t\t\tif( can.isPlainObject(params) && ! can.isArray(params) ){\n\t\t\t\tcan.List.prototype.setup.apply(this);\n\t\t\t\tthis.replace(this.constructor.Map.findAll(params))\n\t\t\t} else {\n\t\t\t\tcan.List.prototype.setup.apply(this,arguments);\n\t\t\t}\n\t\t},\n\t\t_changes: function(ev, attr){\n\t\t\tcan.List.prototype._changes.apply(this, arguments );\n\t\t\tif(/\\w+\\.destroyed/.test(attr)){\n\t\t\t\tvar index = this.indexOf(ev.target);\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tthis.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\treturn can.Model;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view',[\"can/util/library\"], function( can ) {\n\t// ## view.js\n\t// `can.view`  \n\t// _Templating abstraction._\n\n\tvar isFunction = can.isFunction,\n\t\tmakeArray = can.makeArray,\n\t\t// Used for hookup `id`s.\n\t\thookupId = 1,\n\t/**\n\t * @add can.view\n\t */\n\t$view = can.view = can.template = function(view, data, helpers, callback){\n\t\t// If helpers is a `function`, it is actually a callback.\n\t\tif ( isFunction( helpers )) {\n\t\t\tcallback = helpers;\n\t\t\thelpers = undefined;\n\t\t}\n\n\t\tvar pipe = function(result){\n\t\t\t\treturn $view.frag(result);\n\t\t\t},\n\t\t\t// In case we got a callback, we need to convert the can.view.render\n\t\t\t// result to a document fragment\n\t\t\twrapCallback = isFunction(callback) ? function(frag) {\n\t\t\t\tcallback(pipe(frag));\n\t\t\t} : null,\n\t\t\t// Get the result, if a renderer function is passed in, then we just use that to render the data\n\t\t\tresult = isFunction(view) ? view(data, helpers, wrapCallback) : $view.render(view, data, helpers, wrapCallback),\n\t\t\tdeferred = can.Deferred();\n\n\t\tif(isFunction(result))  {\n\t\t\treturn result;\n\t\t}\n\n\t\tif(can.isDeferred(result)){\n\t\t\tresult.then(function(result, data) {\n\t\t\t\tdeferred.resolve.call(deferred, pipe(result), data);\n\t\t\t}, function() {\n\t\t\t\tdeferred.fail.apply(deferred, arguments);\n\t\t\t});\n\t\t\treturn deferred;\n\t\t}\n\t\t\n\t\t// Convert it into a dom frag.\n\t\treturn pipe(result);\n\t};\n\n\tcan.extend( $view, {\n\t\t// creates a frag and hooks it up all at once\n\t\t/**\n\t\t * @function can.view.frag frag\n\t\t * @parent can.view.static\n\t\t */\n\t\tfrag: function(result, parentNode ){\n\t\t\treturn $view.hookup( $view.fragment(result), parentNode );\n\t\t},\n\n\t\t// simply creates a frag\n\t\t// this is used internally to create a frag\n\t\t// insert it\n\t\t// then hook it up\n\t\tfragment: function(result){\n\t\t\tvar frag = can.buildFragment(result,document.body);\n\t\t\t// If we have an empty frag...\n\t\t\tif(!frag.childNodes.length) { \n\t\t\t\tfrag.appendChild(document.createTextNode(''));\n\t\t\t}\n\t\t\treturn frag;\n\t\t},\n\n\t\t// Convert a path like string into something that's ok for an `element` ID.\n\t\ttoId : function( src ) {\n\t\t\treturn can.map(src.toString().split(/\\/|\\./g), function( part ) {\n\t\t\t\t// Dont include empty strings in toId functions\n\t\t\t\tif ( part ) {\n\t\t\t\t\treturn part;\n\t\t\t\t}\n\t\t\t}).join(\"_\");\n\t\t},\n\t\t\n\t\thookup: function(fragment, parentNode ){\n\t\t\tvar hookupEls = [],\n\t\t\t\tid, \n\t\t\t\tfunc;\n\t\t\t\n\t\t\t// Get all `childNodes`.\n\t\t\tcan.each(fragment.childNodes ? can.makeArray(fragment.childNodes) : fragment, function(node){\n\t\t\t\tif(node.nodeType === 1){\n\t\t\t\t\thookupEls.push(node);\n\t\t\t\t\thookupEls.push.apply(hookupEls, can.makeArray( node.getElementsByTagName('*')));\n\t\t\t\t}\n\t\t\t});\n\n\n\t\t\t// Filter by `data-view-id` attribute.\n\t\t\tcan.each( hookupEls, function( el ) {\n\t\t\t\tif ( el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id]) ) {\n\t\t\t\t\tfunc(el, parentNode, id);\n\t\t\t\t\tdelete $view.hookups[id];\n\t\t\t\t\tel.removeAttribute('data-view-id');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn fragment;\n\t\t},\n\n\t\t/**\n\t\t * @function can.view.ejs ejs\n\t\t * @parent can.view.static\n\t\t *\n\t\t * @signature `can.view.ejs( [id,] template )`\n\t\t * \n\t\t * Register an EJS template string and create a renderer function.\n\t\t * \n\t\t *     var renderer = can.view.ejs(\"<h1><%= message %></h1>\");\n\t\t *     renderer({message: \"Hello\"}) //-> docFrag[ <h1>Hello</h1> ]\n\t\t * \n\t\t * @param {String} [id] An optional ID to register the template.\n\t\t * \n\t\t *     can.view.ejs(\"greet\",\"<h1><%= message %></h1>\");\n\t\t *     can.view(\"greet\",{message: \"Hello\"}) //-> docFrag[<h1>Hello</h1>]\n\t\t * \n\t\t * @param {String} template An EJS template in string form.\n\t\t * @return {can.view.renderer} A renderer function that takes data and helpers.\n\t\t * \n\t\t *\n\t\t * @body\n\t\t * `can.view.ejs([id,] template)` registers an EJS template string\n\t\t * for a given id programatically. The following\n\t\t * registers `myViewEJS` and renders it into a documentFragment.\n\t\t *\n\t\t *      can.view.ejs('myViewEJS', '<h2><%= message %></h2>');\n\t\t *\n\t\t *      var frag = can.view('myViewEJS', {\n\t\t *          message : 'Hello there!'\n\t\t *      });\n\t\t *\n\t\t *      frag // -> <h2>Hello there!</h2>\n\t\t *\n\t\t * To convert the template into a render function, just pass\n\t\t * the template. Call the render function with the data\n\t\t * you want to pass to the template and it returns the\n\t\t * documentFragment.\n\t\t *\n\t\t *      var renderer = can.view.ejs('<div><%= message %></div>');\n\t\t *      renderer({\n\t\t *          message : 'EJS'\n\t\t *      }); // -> <div>EJS</div>\n\t\t */\n\t\t// auj\n\t\t/**\n\t\t * @function can.view.mustache mustache\n\t\t * @parent can.view.static\n\t\t * \n\t\t * @signature `can.view.mustache( [id,] template )`\n\t\t * \n\t\t * Register a Mustache template string and create a renderer function.\n\t\t * \n\t\t *     var renderer = can.view.mustache(\"<h1>{{message}}</h1>\");\n\t\t *     renderer({message: \"Hello\"}) //-> docFrag[ <h1>Hello</h1> ]\n\t\t * \n\t\t * @param {String} [id] An optional ID for the template.\n\t\t * \n\t\t *     can.view.ejs(\"greet\",\"<h1>{{message}}</h1>\");\n\t\t *     can.view(\"greet\",{message: \"Hello\"}) //-> docFrag[<h1>Hello</h1>]\n\t\t * \n\t\t * @param {String} template A Mustache template in string form.\n\t\t *\n\t\t * @return {can.view.renderer} A renderer function that takes data and helpers.\n\t\t *\n\t\t * @body\n\t\t * \n\t\t * `can.view.mustache([id,] template)` registers an Mustache template string \n\t\t * for a given id programatically. The following\n\t\t * registers `myStache` and renders it into a documentFragment.\n\t\t *\n\t\t *      can.viewmustache('myStache', '<h2>{{message}}</h2>');\n\t\t * \n\t\t *      var frag = can.view('myStache', {\n\t\t *          message : 'Hello there!'\n\t\t *      });\n\t\t * \n\t\t *      frag // -> <h2>Hello there!</h2>\n\t\t *\n\t\t * To convert the template into a render function, just pass \n\t\t * the template. Call the render function with the data\n\t\t * you want to pass to the template and it returns the \n\t\t * documentFragment.\n\t\t *\n\t\t *      var renderer = can.view.mustache('<div>{{message}}</div>');\n\t\t *      renderer({\n\t\t *          message : 'Mustache'\n\t\t *      }); // -> <div>Mustache</div>\n\t\t */\n\t\t// heir\n\t\t/**\n\t\t * @property hookups\n\t\t * @hide\n\t\t * A list of pending 'hookups'\n\t\t */\n\t\thookups: {},\n\n\t\t/**\n\t\t * @description Create a hookup to insert into templates.\n\t\t * @function can.view.hook hook\n\t\t * @parent can.view.static\n\t\t * @signature `can.view.hook(callback)`\n\t\t * @param {Function} callback A callback function to be called with the element.\n\t\t *\n\t\t * @body\n\t\t * Registers a hookup function that can be called back after the html is \n\t\t * put on the page.  Typically this is handled by the template engine.  Currently\n\t\t * only EJS supports this functionality.\n\t\t * \n\t\t *     var id = can.view.hook(function(el){\n\t\t *            //do something with el\n\t\t *         }),\n\t\t *         html = \"<div data-view-id='\"+id+\"'>\"\n\t\t *     $('.foo').html(html);\n\t\t */\n\t\thook: function( cb ) {\n\t\t\t$view.hookups[++hookupId] = cb;\n\t\t\treturn \" data-view-id='\"+hookupId+\"'\";\n\t\t},\n\n\t\t/**\n\t\t * @hide\n\t\t * @property {Object} can.view.cached view\n\t\t * @parent can.view\n\t\t * Cached are put in this object\n\t\t */\n\t\tcached: {},\n\n\t\tcachedRenderers: {},\n\n\t\t/**\n\t\t * @property {Boolean} can.view.cache cache\n\t\t * @parent can.view.static\n\t\t * By default, views are cached on the client.  If you'd like the\n\t\t * the views to reload from the server, you can set the `cache` attribute to `false`.\n\t\t *\n\t\t * \t\t//- Forces loads from server\n\t\t * \t\tcan.view.cache = false; \n\t\t *\n\t\t */\n\t\tcache: true,\n\n\t\t/**\n\t\t * @function can.view.register register\n\t\t * @parent can.view.static\n\t\t * @description Register a templating language.\n\t\t * @signature `can.view.register(info)`\n\t\t * @param {{}} info Information about the templating language.\n\t\t * @option {String} plugin The location of the templating language's plugin.\n\t\t * @option {String} suffix Files with this suffix will use this templating language's plugin by default.\n\t\t * @option {function} renderer A function that returns a function that, given data, will render the template with that data.\n\t\t * The __renderer__ function receives the id of the template and the text of the template.\n\t\t * @option {function} script A function that returns the string form of the processed template.\n\t\t *\n\t\t * @body\n\t\t * Registers a template engine to be used with \n\t\t * view helpers and compression.  \n\t\t * \n\t\t * ## Example\n\t\t * \n\t\t * @codestart\n\t\t * can.View.register({\n\t\t * \tsuffix : \"tmpl\",\n\t\t *  plugin : \"jquery/view/tmpl\",\n\t\t * \trenderer: function( id, text ) {\n\t\t * \t\treturn function(data){\n\t\t * \t\t\treturn jQuery.render( text, data );\n\t\t * \t\t}\n\t\t * \t},\n\t\t * \tscript: function( id, text ) {\n\t\t * \t\tvar tmpl = can.tmpl(text).toString();\n\t\t * \t\treturn \"function(data){return (\"+\n\t\t * \t\t  \ttmpl+\n\t\t * \t\t\t\").call(jQuery, jQuery, data); }\";\n\t\t * \t}\n\t\t * })\n\t\t * @codeend\n\t\t */\n\t\tregister: function( info ) {\n\t\t\tthis.types[\".\" + info.suffix] = info;\n\t\t},\n\n\t\ttypes: {},\n\n\t\t/**\n\t\t * @property {String} can.view.ext ext\n\t\t * @parent can.view.static\n\t\t * The default suffix to use if none is provided in the view's url.  \n\t\t * This is set to `.ejs` by default.\n\t\t *\n\t\t * \t\t// Changes view ext to 'txt'\n\t\t * \t\tcan.view.ext = 'txt';\n\t\t *\n\t\t */\n\t\text: \".ejs\",\n\n\t\t/**\n\t\t * Returns the text that \n\t\t * @hide \n\t\t * @param {Object} type\n\t\t * @param {Object} id\n\t\t * @param {Object} src\n\t\t */\n\t\tregisterScript: function() {},\n\n\t\t/**\n\t\t * @hide\n\t\t * Called by a production script to pre-load a renderer function\n\t\t * into the view cache.\n\t\t * @param {String} id\n\t\t * @param {Function} renderer\n\t\t */\n\t\tpreload: function( ) {},\n\n\t\t/**\n\t\t * @function can.view.render render\n\t\t * @parent can.view.static\n\t\t * @description Render a template.\n\t\t * @signature `can.view.render(template[, callback])`\n\t\t * @param {String|Object} view The path of the view template or a view object.\n\t\t * @param {Function} [callback] A function executed after the template has been processed.\n\t\t * @return {Function|can.Deferred} A renderer function to be called with data and helpers\n\t\t * or a Deferred that resolves to a renderer function.\n\t\t *\n\t\t * @signature `can.view.render(template, data[, [helpers,] callback])`\n\t\t * @param {String|Object} view The path of the view template or a view object.\n\t\t * @param {Object} [data] The data to populate the template with.\n\t\t * @param {Object.<String, function>} [helpers] Helper methods referenced in the template.\n\t\t * @param {Function} [callback] A function executed after the template has been processed.\n\t\t * @return {String|can.Deferred} The template with interpolated data in string form\n\t\t * or a Deferred that resolves to the template with interpolated data.\n\t\t *\n\t\t * @body\n\t\t * `can.view.render(view, [data], [helpers], callback)` returns the rendered markup produced by the corresponding template\n\t\t * engine as String. If you pass a deferred object in as data, render returns\n\t\t * a deferred resolving to the rendered markup.\n\t\t * \n\t\t * `can.view.render` is commonly used for sub-templates.\n\t\t * \n\t\t * ## Example\n\t\t * \n\t\t * _welcome.ejs_ looks like:\n\t\t * \n\t\t *     <h1>Hello <%= hello %></h1>\n\t\t * \n\t\t * Render it to a string like:\n\t\t * \n\t\t *     can.view.render(\"welcome.ejs\",{hello: \"world\"})\n\t\t *       //-> <h1>Hello world</h1>\n\t\t * \n\t\t * ## Use as a Subtemplate\n\t\t * \n\t\t * If you have a template like:\n\t\t * \n\t\t *     <ul>\n\t\t *       <% list(items, function(item){ %>\n\t\t *         <%== can.view.render(\"item.ejs\",item) %>\n\t\t *       <% }) %>\n\t\t *     </ul>\n\t\t *\n\t\t * ## Using renderer functions\n\t\t *\n\t\t * If you only pass the view path, `can.view will return a renderer function that can be called with\n\t\t * the data to render:\n\t\t *\n\t\t *     var renderer = can.view.render(\"welcome.ejs\");\n\t\t *     // Do some more things\n\t\t *     renderer({hello: \"world\"}) // -> Document Fragment\n\t\t * \n\t\t */\n\t\trender: function( view, data, helpers, callback ) {\n\t\t\t// If helpers is a `function`, it is actually a callback.\n\t\t\tif ( isFunction( helpers )) {\n\t\t\t\tcallback = helpers;\n\t\t\t\thelpers = undefined;\n\t\t\t}\n\n\t\t\t// See if we got passed any deferreds.\n\t\t\tvar deferreds = getDeferreds(data);\n\n\t\t\tif ( deferreds.length ) { // Does data contain any deferreds?\n\t\t\t\t// The deferred that resolves into the rendered content...\n\t\t\t\tvar deferred = new can.Deferred(),\n\t\t\t\t\tdataCopy = can.extend({}, data);\n\t\n\t\t\t\t// Add the view request to the list of deferreds.\n\t\t\t\tdeferreds.push(get(view, true))\n\t\n\t\t\t\t// Wait for the view and all deferreds to finish...\n\t\t\t\tcan.when.apply(can, deferreds).then(function( resolved ) {\n\t\t\t\t\t// Get all the resolved deferreds.\n\t\t\t\t\tvar objs = makeArray(arguments),\n\t\t\t\t\t\t// Renderer is the last index of the data.\n\t\t\t\t\t\trenderer = objs.pop(),\n\t\t\t\t\t\t// The result of the template rendering with data.\n\t\t\t\t\t\tresult; \n\t\n\t\t\t\t\t// Make data look like the resolved deferreds.\n\t\t\t\t\tif ( can.isDeferred(data) ) {\n\t\t\t\t\t\tdataCopy = usefulPart(resolved);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Go through each prop in data again and\n\t\t\t\t\t\t// replace the defferreds with what they resolved to.\n\t\t\t\t\t\tfor ( var prop in data ) {\n\t\t\t\t\t\t\tif ( can.isDeferred(data[prop]) ) {\n\t\t\t\t\t\t\t\tdataCopy[prop] = usefulPart(objs.shift());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the rendered result.\n\t\t\t\t\tresult = renderer(dataCopy, helpers);\n\t\n\t\t\t\t\t// Resolve with the rendered view.\n\t\t\t\t\tdeferred.resolve(result, dataCopy);\n\n\t\t\t\t\t// If there's a `callback`, call it back with the result.\n\t\t\t\t\tcallback && callback(result, dataCopy);\n\t\t\t\t}, function() {\n\t\t\t\t\tdeferred.reject.apply(deferred, arguments)\n\t\t\t\t});\n\t\t\t\t// Return the deferred...\n\t\t\t\treturn deferred;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// get is called async but in \n\t\t\t\t// ff will be async so we need to temporarily reset\n\t\t\t\tif(can.__reading){\n\t\t\t\t\tvar reading = can.__reading;\n\t\t\t\t\tcan.__reading = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// No deferreds! Render this bad boy.\n\t\t\t\tvar response, \n\t\t\t\t\t// If there's a `callback` function\n\t\t\t\t\tasync = isFunction( callback ),\n\t\t\t\t\t// Get the `view` type\n\t\t\t\t\tdeferred = get(view, async);\n\t\t\t\t\t\n\t\t\t\tif(can.Map && can.__reading){\n\t\t\t\t\tcan.__reading = reading;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If we are `async`...\n\t\t\t\tif ( async ) {\n\t\t\t\t\t// Return the deferred\n\t\t\t\t\tresponse = deferred;\n\t\t\t\t\t// And fire callback with the rendered result.\n\t\t\t\t\tdeferred.then(function( renderer ) {\n\t\t\t\t\t\tcallback(data ? renderer(data, helpers) : renderer);\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\t// if the deferred is resolved, call the cached renderer instead\n\t\t\t\t\t// this is because it's possible, with recursive deferreds to\n\t\t\t\t\t// need to render a view while its deferred is _resolving_.  A _resolving_ deferred\n\t\t\t\t\t// is a deferred that was just resolved and is calling back it's success callbacks.\n\t\t\t\t\t// If a new success handler is called while resoliving, it does not get fired by\n\t\t\t\t\t// jQuery's deferred system.  So instead of adding a new callback\n\t\t\t\t\t// we use the cached renderer.\n\t\t\t\t\t// We also add __view_id on the deferred so we can look up it's cached renderer.\n\t\t\t\t\t// In the future, we might simply store either a deferred or the cached result.\n\t\t\t\t\tif(deferred.state() === \"resolved\" && deferred.__view_id  ){\n\t\t\t\t\t\tvar currentRenderer = $view.cachedRenderers[ deferred.__view_id ];\n\t\t\t\t\t\treturn data ? currentRenderer(data, helpers) : currentRenderer;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, the deferred is complete, so\n\t\t\t\t\t\t// set response to the result of the rendering.\n\t\t\t\t\t\tdeferred.then(function( renderer ) {\n\t\t\t\t\t\t\tresponse = data ? renderer(data, helpers) : renderer;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn response;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @hide\n\t\t * Registers a view with `cached` object.  This is used\n\t\t * internally by this class and Mustache to hookup views.\n\t\t * @param  {String} id\n\t\t * @param  {String} text\n\t\t * @param  {String} type\n\t\t * @param  {can.Deferred} def\n\t\t */\n\t\tregisterView: function( id, text, type, def ) {\n\t\t\t// Get the renderer function.\n\t\t\tvar func = (type || $view.types[$view.ext]).renderer(id, text);\n\t\t\tdef = def || new can.Deferred();\n\t\t\t\n\t\t\t// Cache if we are caching.\n\t\t\tif ( $view.cache ) {\n\t\t\t\t$view.cached[id] = def;\n\t\t\t\tdef.__view_id = id;\n\t\t\t\t$view.cachedRenderers[id] = func;\n\t\t\t}\n\n\t\t\t// Return the objects for the response's `dataTypes`\n\t\t\t// (in this case view).\n\t\t\treturn def.resolve(func);\n\t\t}\n\t});\n\n\t// Makes sure there's a template, if not, have `steal` provide a warning.\n\tvar\tcheckText = function( text, url ) {\n\t\t\tif ( ! text.length ) {\n\t\t\t\n\t\t\t\tthrow \"can.view: No template or empty template:\" + url;\n\t\t\t}\n\t\t},\n\t\t// `Returns a `view` renderer deferred.  \n\t\t// `url` - The url to the template.  \n\t\t// `async` - If the ajax request should be asynchronous.  \n\t\t// Returns a deferred.\n\t\tget = function( obj, async ) {\n\t\t\tvar url = typeof obj === 'string' ? obj : obj.url,\n\t\t\t\tsuffix = obj.engine || url.match(/\\.[\\w\\d]+$/),\n\t\t\t\ttype,\n\t\t\t\t// If we are reading a script element for the content of the template,\n\t\t\t\t// `el` will be set to that script element.\n\t\t\t\tel,\n\t\t\t\t// A unique identifier for the view (used for caching).\n\t\t\t\t// This is typically derived from the element id or\n\t\t\t\t// the url for the template.\n\t\t\t\tid,\n\t\t\t\t// The ajax request used to retrieve the template content.\n\t\t\t\tjqXHR;\n\n\t\t\t//If the url has a #, we assume we want to use an inline template\n\t\t\t//from a script element and not current page's HTML\n\t\t\tif( url.match(/^#/) ) {\n\t\t\t\turl = url.substr(1);\n\t\t\t}\n\t\t\t// If we have an inline template, derive the suffix from the `text/???` part.\n\t\t\t// This only supports `<script>` tags.\n\t\t\tif ( el = document.getElementById(url) ) {\n\t\t\t\tsuffix = \".\"+el.type.match(/\\/(x\\-)?(.+)/)[2];\n\t\t\t}\n\t\n\t\t\t// If there is no suffix, add one.\n\t\t\tif (!suffix && !$view.cached[url] ) {\n\t\t\t\turl += ( suffix = $view.ext );\n\t\t\t}\n\n\t\t\tif ( can.isArray( suffix )) {\n\t\t\t\tsuffix = suffix[0]\n\t\t\t}\n\t\n\t\t\t// Convert to a unique and valid id.\n\t\t\tid = $view.toId(url);\n\t\n\t\t\t// If an absolute path, use `steal` to get it.\n\t\t\t// You should only be using `//` if you are using `steal`.\n\t\t\tif ( url.match(/^\\/\\//) ) {\n\t\t\t\tvar sub = url.substr(2);\n\t\t\t\turl = ! window.steal ? \n\t\t\t\t\tsub :\n\t\t\t\t\tsteal.config().root.mapJoin(\"\"+steal.id(sub));\n\t\t\t}\n\t\n\t\t\t// Set the template engine type.\n\t\t\ttype = $view.types[suffix];\n\t\n\t\t\t// If it is cached, \n\t\t\tif ( $view.cached[id] ) {\n\t\t\t\t// Return the cached deferred renderer.\n\t\t\t\treturn $view.cached[id];\n\t\t\t\n\t\t\t// Otherwise if we are getting this from a `<script>` element.\n\t\t\t} else if ( el ) {\n\t\t\t\t// Resolve immediately with the element's `innerHTML`.\n\t\t\t\treturn $view.registerView(id, el.innerHTML, type);\n\t\t\t} else {\n\t\t\t\t// Make an ajax request for text.\n\t\t\t\tvar d = new can.Deferred();\n\t\t\t\tcan.ajax({\n\t\t\t\t\tasync: async,\n\t\t\t\t\turl: url,\n\t\t\t\t\tdataType: \"text\",\n\t\t\t\t\terror: function(jqXHR) {\n\t\t\t\t\t\tcheckText(\"\", url);\n\t\t\t\t\t\td.reject(jqXHR);\n\t\t\t\t\t},\n\t\t\t\t\tsuccess: function( text ) {\n\t\t\t\t\t\t// Make sure we got some text back.\n\t\t\t\t\t\tcheckText(text, url);\n\t\t\t\t\t\t$view.registerView(id, text, type, d)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d;\n\t\t\t}\n\t\t},\n\t\t// Gets an `array` of deferreds from an `object`.\n\t\t// This only goes one level deep.\n\t\tgetDeferreds = function( data ) {\n\t\t\tvar deferreds = [];\n\n\t\t\t// pull out deferreds\n\t\t\tif ( can.isDeferred(data) ) {\n\t\t\t\treturn [data]\n\t\t\t} else {\n\t\t\t\tfor ( var prop in data ) {\n\t\t\t\t\tif ( can.isDeferred(data[prop]) ) {\n\t\t\t\t\t\tdeferreds.push(data[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn deferreds;\n\t\t},\n\t\t// Gets the useful part of a resolved deferred.\n\t\t// This is for `model`s and `can.ajax` that resolve to an `array`.\n\t\tusefulPart = function( resolved ) {\n\t\t\treturn can.isArray(resolved) && resolved[1] === 'success' ? resolved[0] : resolved\n\t\t};\n\n\t//!steal-pluginify-remove-start\n\tif ( window.steal ) {\n\t\tsteal.type(\"view js\", function( options, success, error ) {\n\t\t\tvar type = $view.types[\".\" + options.type],\n\t\t\t\tid = $view.toId(options.id);\n\t\t\t/**\n\t\t\t * @hide\n\t\t\t * should return something like steal(\"dependencies\",function(EJS){\n\t\t\t * \t return can.view.preload(\"ID\", options.text)\n\t\t\t * })\n\t\t\t */\n\t\t\toptions.text = \"steal('\" + (type.plugin || \"can/view/\" + options.type) + \"',function(can){return \" + \"can.view.preload('\" + id + \"',\" + options.text + \");\\n})\";\n\t\t\tsuccess();\n\t\t})\n\t}\n\t//!steal-pluginify-remove-end\n\n\tcan.extend($view, {\n\t\tregister: function( info ) {\n\t\t\tthis.types[\".\" + info.suffix] = info;\n\n\t\t\t//!steal-pluginify-remove-start\n\t\t\tif ( window.steal ) {\n\t\t\t\tsteal.type(info.suffix + \" view js\", function( options, success, error ) {\n\t\t\t\t\tvar type = $view.types[\".\" + options.type],\n\t\t\t\t\t\tid = $view.toId(options.id+'');\n\n\t\t\t\t\toptions.text = type.script(id, options.text)\n\t\t\t\t\tsuccess();\n\t\t\t\t})\n\t\t\t};\n\t\t\t//!steal-pluginify-remove-end\n\t\t\t\n\t\t\t$view[info.suffix] = function(id, text){\n\t\t\t\tif(!text) {\n\t\t\t\t\t// Return a nameless renderer\n\t\t\t\t\tvar renderer = function() {\n\t\t\t\t\t\treturn $view.frag(renderer.render.apply(this, arguments));\n\t\t\t\t\t}\n\t\t\t\t\trenderer.render = function() {\n\t\t\t\t\t\tvar renderer = info.renderer(null, id);\n\t\t\t\t\t\treturn renderer.apply(renderer, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn renderer;\n\t\t\t\t}\n\n\t\t\t\treturn $view.preload(id, info.renderer(id, text));\n\t\t\t}\n\t\t},\n\t\tregisterScript: function( type, id, src ) {\n\t\t\treturn \"can.view.preload('\" + id + \"',\" + $view.types[\".\" + type].script(id, src) + \");\";\n\t\t},\n\t\tpreload: function( id, renderer ) {\n\t\t\tvar def = $view.cached[id] = new can.Deferred().resolve(function( data, helpers ) {\n\t\t\t\treturn renderer.call(data, data, helpers);\n\t\t\t});\n\t\t\tfunction frag(){\n\t\t\t\treturn $view.frag(renderer.apply(this,arguments));\n\t\t\t}\n\t\t\t// expose the renderer for mustache\n\t\t\tfrag.render = renderer;\n\n\t\t\t// set cache references (otherwise preloaded recursive views won't recurse properly)\n\t\t\tdef.__view_id = id;\n\t\t\t$view.cachedRenderers[id] = renderer;\n\n\t\t\treturn frag;\n\t\t}\n\n\t});\n\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/compute',[\"can/util/library\", \"can/util/bind\", \"can/util/batch\"], function(can, bind) {\n\t\n\tvar names = [\"__reading\",\"__clearReading\",\"__setReading\"],\n\t\tsetup = function(observed){\n\t\t\tvar old = {};\n\t\t\tfor(var i =0; i < names.length; i++){\n\t\t\t\told[names[i]] = can[names[i]]\n\t\t\t}\n\t\t\tcan.__reading = function(obj, attr){\n\t\t\t\t// Add the observe and attr that was read\n\t\t\t\t// to `observed`\n\t\t\t\tobserved.push({\n\t\t\t\t\tobj: obj,\n\t\t\t\t\tattr: attr+\"\"\n\t\t\t\t});\n\t\t\t};\n\t\t\tcan.__clearReading = function(){\n\t\t\t\treturn observed.splice(0, observed.length);\n\t\t\t}\n\t\t\tcan.__setReading = function(o){\n\t\t\t\t[].splice.apply(observed, [0, observed.length].concat(o))\n\t\t\t}\n\t\t\treturn old;\n\t\t},\n\t\t// empty default function \n\t\tk = function(){};\n\t\t\n\t// returns the\n    // - observes and attr methods are called by func\n\t// - the value returned by func\n\t// ex: `{value: 100, observed: [{obs: o, attr: \"completed\"}]}`\n\tvar getValueAndObserved = function(func, self){\n\t\t\n\t\tvar observed = [],\n\t\t\told = setup(observed),\n\t\t\t// Call the \"wrapping\" function to get the value. `observed`\n\t\t\t// will have the observe/attribute pairs that were read.\n\t\t\tvalue = func.call(self);\n\n\t\t// Set back so we are no longer reading.\n\t\tcan.simpleExtend(can,old);\n\t\t\n\t\treturn {\n\t\t\tvalue : value,\n\t\t\tobserved : observed\n\t\t};\n\t},\n\t\t// Calls `callback(newVal, oldVal)` everytime an observed property\n\t\t// called within `getterSetter` is changed and creates a new result of `getterSetter`.\n\t\t// Also returns an object that can teardown all event handlers.\n\t\tcomputeBinder = function(getterSetter, context, callback, computeState){\n\t\t\t// track what we are observing\n\t\t\tvar observing = {},\n\t\t\t\t// a flag indicating if this observe/attr pair is already bound\n\t\t\t\tmatched = true,\n\t\t\t\t// the data to return \n\t\t\t\tdata = {\n\t\t\t\t\t// we will maintain the value while live-binding is taking place\n\t\t\t\t\tvalue : undefined,\n\t\t\t\t\t// a teardown method that stops listening\n\t\t\t\t\tteardown: function(){\n\t\t\t\t\t\tfor ( var name in observing ) {\n\t\t\t\t\t\t\tvar ob = observing[name];\n\t\t\t\t\t\t\tob.observe.obj.unbind(ob.observe.attr, onchanged);\n\t\t\t\t\t\t\tdelete observing[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tbatchNum;\n\t\t\t\n\t\t\t// when a property value is changed\n\t\t\tvar onchanged = function(ev){\n\t\t\t\t// If the compute is no longer bound (because the same change event led to an unbind)\n\t\t\t\t// then do not call getValueAndBind, or we will leak bindings.\n\t\t\t\tif ( computeState && !computeState.bound ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(ev.batchNum === undefined || ev.batchNum !== batchNum) {\n\t\t\t\t\t// store the old value\n\t\t\t\t\tvar oldValue = data.value,\n\t\t\t\t\t\t// get the new value\n\t\t\t\t\t\tnewvalue = getValueAndBind();\n\n\t\t\t\t\t// update the value reference (in case someone reads)\n\t\t\t\t\tdata.value = newvalue;\n\t\t\t\t\t// if a change happened\n\t\t\t\t\tif ( newvalue !== oldValue ) {\n\t\t\t\t\t\tcallback(newvalue, oldValue);\n\t\t\t\t\t}\n\t\t\t\t\tbatchNum = batchNum = ev.batchNum;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\t// gets the value returned by `getterSetter` and also binds to any attributes\n\t\t\t// read by the call\n\t\t\tvar getValueAndBind = function(){\n\t\t\t\tvar info = getValueAndObserved( getterSetter, context ),\n\t\t\t\t\tnewObserveSet = info.observed;\n\t\t\t\t\n\t\t\t\tvar value = info.value,\n\t\t\t\t\tob;\n\t\t\t\t\tmatched = !matched;\n\t\t\t\t\n\t\t\t\t// go through every attribute read by this observe\n\t\t\t\tfor ( var i = 0, len = newObserveSet.length; i < len; i++ ) {\n\t\t\t\t\tob = newObserveSet[i];\n\t\t\t\t\t// if the observe/attribute pair is being observed\n\t\t\t\t\tif(observing[ob.obj._cid+\"|\"+ob.attr]){\n\t\t\t\t\t\t// mark at as observed\n\t\t\t\t\t\tobserving[ob.obj._cid+\"|\"+ob.attr].matched = matched;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise, set the observe/attribute on oldObserved, marking it as being observed\n\t\t\t\t\t\tobserving[ob.obj._cid+\"|\"+ob.attr] = {\n\t\t\t\t\t\t\tmatched: matched,\n\t\t\t\t\t\t\tobserve: ob\n\t\t\t\t\t\t};\n\t\t\t\t\t\tob.obj.bind(ob.attr, onchanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Iterate through oldObserved, looking for observe/attributes\n\t\t\t\t// that are no longer being bound and unbind them\n\t\t\t\tfor ( var name in observing ) {\n\t\t\t\t\tvar ob = observing[name];\n\t\t\t\t\tif(ob.matched !== matched){\n\t\t\t\t\t\tob.observe.obj.unbind(ob.observe.attr, onchanged);\n\t\t\t\t\t\tdelete observing[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\t\t// set the initial value\n\t\t\tdata.value = getValueAndBind();\n\n\t\t\tdata.isListening = ! can.isEmptyObject(observing);\n\t\t\treturn data;\n\t\t}\n\t\n\t// if no one is listening ... we can not calculate every time\n\n\tcan.compute = function(getterSetter, context, eventName){\n\t\tif(getterSetter && getterSetter.isComputed){\n\t\t\treturn getterSetter;\n\t\t}\n\t\t// stores the result of computeBinder\n\t\tvar computedData,\n\t\t\t// how many listeners to this this compute\n\t\t\tbindings = 0,\n\t\t\t// the computed object\n\t\t\tcomputed,\n\t\t\t// an object that keeps track if the computed is bound\n\t\t\t// onchanged needs to know this. It's possible a change happens and results in\n\t\t\t// something that unbinds the compute, it needs to not to try to recalculate who it\n\t\t\t// is listening to\n\t\t\tcomputeState = { \n\t\t\t\tbound: false,\n\t\t\t\t// true if this compute is calculated from other computes and observes\n\t\t\t\thasDependencies: false\n\t\t\t},\n\t\t\t// The following functions are overwritten depending on how compute() is called\n\t\t\t// a method to setup listening\n\t\t\ton = k,\n\t\t\t// a method to teardown listening\n\t\t\toff = k,\n\t\t\t// the current cached value (only valid if bound = true)\n\t\t\tvalue,\n\t\t\t// how to read the value\n\t\t\tget = function(){\n\t\t\t\treturn value\n\t\t\t},\n\t\t\t// sets the value\n\t\t\tset = function(newVal){\n\t\t\t\tvalue = newVal;\n\t\t\t},\n\t\t\t// this compute can be a dependency of other computes\n\t\t\tcanReadForChangeEvent = true,\n\t\t\t// save for clone\n\t\t\targs = can.makeArray(arguments),\n\t\t\tupdater= function(newValue, oldValue){\n\t\t\t\tvalue = newValue;\n\t\t\t\t// might need a way to look up new and oldVal\n\t\t\t\tcan.batch.trigger(computed, \"change\",[newValue, oldValue])\n\t\t\t},\n\t\t\t// the form of the arguments\n\t\t\tform;\n\n\t\tcomputed = function(newVal){\n\t\t\t// setting ...\n\t\t\tif(arguments.length){\n\t\t\t\t// save a reference to the old value\n\t\t\t\tvar old = value;\n\n\t\t\t\t// setter may return a value if \n\t\t\t\t// setter is for a value maintained exclusively by this compute\n\t\t\t\tvar setVal = set.call(context,newVal, old);\n\n\t\t\t\t// if this has dependencies return the current value\n\t\t\t\tif(computed.hasDependencies){\n\t\t\t\t\treturn get.call(context);\n\t\t\t\t}\n\n\t\t\t\tif(setVal === undefined) {\n\t\t\t\t\t// it's possible, like with the DOM, setting does not\n\t\t\t\t\t// fire a change event, so we must read\n\t\t\t\t\tvalue = get.call(context);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = setVal;\n\t\t\t\t}\n\t\t\t\t// fire the change\n\t\t\t\tif( old !== value){\n\t\t\t\t\tcan.batch.trigger(computed, \"change\",[value, old] );\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\t// Another compute wants to bind to this compute\n\t\t\t\tif( can.__reading && canReadForChangeEvent ) {\n\t\t\t\t\t// Tell the compute to listen to change on this computed\n\t\t\t\t\tcan.__reading(computed,'change');\n\t\t\t\t\t// We are going to bind on this compute.\n\t\t\t\t\t// If we are not bound, we should bind so that\n\t\t\t\t\t// we don't have to re-read to get the value of this compute.\n\t\t\t\t\t!computeState.bound && can.compute.temporarilyBind(computed)\n\t\t\t\t}\n\t\t\t\t// if we are bound, use the cached value\n\t\t\t\tif( computeState.bound ) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn get.call(context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(typeof getterSetter === \"function\"){\n\t\t\tset = getterSetter;\n\t\t\tget = getterSetter;\n\t\t\tcanReadForChangeEvent = eventName === false ? false : true;\n\t\t\tcomputed.hasDependencies = false;\n\t\t\ton = function(update){\n\t\t\t\tcomputedData = computeBinder(getterSetter, context || this, update, computeState);\n\t\t\t\tcomputed.hasDependencies = computedData.isListening\n\t\t\t\tvalue = computedData.value;\n\t\t\t}\n\t\t\toff = function(){\n\t\t\t\tcomputedData && computedData.teardown();\n\t\t\t}\n\t\t} else if(context) {\n\t\t\t\n\t\t\tif(typeof context == \"string\"){\n\t\t\t\t// `can.compute(obj, \"propertyName\", [eventName])`\n\t\t\t\t\n\t\t\t\tvar propertyName = context,\n\t\t\t\t\tisObserve = getterSetter instanceof can.Map;\n\t\t\t\tif(isObserve){\n\t\t\t\t\tcomputed.hasDependencies = true;\n\t\t\t\t}\n\t\t\t\tget = function(){\n\t\t\t\t\tif(isObserve){\n\t\t\t\t\t\treturn getterSetter.attr(propertyName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn getterSetter[propertyName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset = function(newValue){\n\t\t\t\t\tif(isObserve){\n\t\t\t\t\t\tgetterSetter.attr(propertyName, newValue)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetterSetter[propertyName] = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar handler;\n\t\t\t\ton = function(update){\n\t\t\t\t\thandler = function(){\n\t\t\t\t\t\tupdate(get(), value)\n\t\t\t\t\t};\n\t\t\t\t\tcan.bind.call(getterSetter, eventName || propertyName,handler)\n\t\t\t\t\t\n\t\t\t\t\t// use getValueAndObserved because\n\t\t\t\t\t// we should not be indicating that some parent\n\t\t\t\t\t// reads this property if it happens to be binding on it\n\t\t\t\t\tvalue = getValueAndObserved(get).value\n\t\t\t\t}\n\t\t\t\toff = function(){\n\t\t\t\t\tcan.unbind.call(getterSetter, eventName || propertyName,handler)\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// `can.compute(initialValue, setter)`\n\t\t\t\tif(typeof context === \"function\"){\n\t\t\t\t\tvalue = getterSetter;\n\t\t\t\t\tset = context;\n\t\t\t\t\tcontext = eventName;\n\t\t\t\t\tform = \"setter\";\n\t\t\t\t} else {\n\t\t\t\t\t// `can.compute(initialValue,{get:, set:, on:, off:})`\n\t\t\t\t\tvalue = getterSetter;\n\t\t\t\t\tvar options = context;\n\t\t\t\t\tget = options.get || get;\n\t\t\t\t\tset = options.set ||set;\n\t\t\t\t\ton = options.on || on;\n\t\t\t\t\toff = options.off || off;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t\n\n\t\t} else {\n\t\t\t// `can.compute(5)`\n\t\t\tvalue = getterSetter;\n\t\t}\n\t\t\n\t\t\n\t\tcan.cid(computed,\"compute\")\n\n\n\t\treturn can.simpleExtend(computed,{\n\t\t\t/**\n\t\t\t * @property {Boolean} can.computed.isComputed compute.isComputed\n\t\t\t * @parent can.compute\n\t\t\t * Whether the value of the compute has been computed yet.\n\t\t\t */\n\t\t\tisComputed: true,\n\t\t\t_bindsetup: function(){\n\t\t\t\tcomputeState.bound = true;\n\t\t\t\t// setup live-binding\n\t\t\t\t// while binding, this does not count as a read\n\t\t\t\tvar oldReading = can.__reading;\n\t\t\t\tdelete can.__reading;\n\t\t\t\ton.call(this, updater);\n\t\t\t\tcan.__reading = oldReading;\n\t\t\t},\n\t\t\t_bindteardown: function(){\n\t\t\t\toff.call(this,updater)\n\t\t\t\tcomputeState.bound = false;\n\t\t\t},\n\t\t\t/**\n\t\t\t * @function can.computed.bind compute.bind\n\t\t\t * @parent can.compute\n\t\t\t * @description Bind an event handler to a compute.\n\t\t\t * @signature `compute.bind(eventType, handler)`\n\t\t\t * @param {String} eventType The event to bind this handler to.\n\t\t\t * The only event type that computes emit is _change_.\n\t\t\t * @param {function({Object},{*},{*})} handler The handler to call when the event happens.\n\t\t\t * The handler should have three parameters:\n\t\t\t *\n\t\t\t * - _event_ is the event object.\n\t\t\t * - _newVal_ is the newly-computed value of the compute.\n\t\t\t * - _oldVal_ is the value of the compute before it changed.\n\t\t\t *\n\t\t\t * `bind` lets you listen to a compute to know when it changes. It works just like\n\t\t\t * can.Map's `[can.Map.prototype.bind bind]`:\n\t\t\t @codestart\n\t\t\t * var tally = can.compute(0);\n\t\t\t * tally.bind('change', function(ev, newVal, oldVal) {\n\t\t\t *     console.log('The tally is now at ' + newVal + '.');\n\t\t\t * });\n\t\t\t *\n\t\t\t * tally(tally() + 5); // The log reads:\n\t\t\t *                     // 'The tally is now at 5.'\n\t\t\t * @codeend\n\t\t\t */\n\t\t\tbind: can.bindAndSetup,\n\t\t\t/**\n\t\t\t * @function computed.unbind compute.unbind\n\t\t\t * @parent can.compute\n\t\t\t * @description Unbind an event handler from a compute.\n\t\t\t * @signature `compute.unbind(eventType[, handler])`\n\t\t\t * @param {String} eventType The type of event to unbind.\n\t\t\t * The only event type available for computes is _change_.\n\t\t\t * @param {function} [handler] If given, the handler to unbind.\n\t\t\t * If _handler_ is not supplied, all handlers bound to _eventType_\n\t\t\t * will be removed.\n\t\t\t */\n\t\t\tunbind: can.unbindAndTeardown,\n\t\t\tclone: function(context){\n\t\t\t\tif(context){\n\t\t\t\t\tif(form == \"setter\"){\n\t\t\t\t\t\targs[2] = context\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs[1] = context\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn can.compute.apply(can,args);\n\t\t\t}\n\t\t});\n\t};\n\t\n\t// a list of temporarily bound computes\n\tvar computes,\n\t\tunbindComputes = function(){\n\t\t\tfor( var i =0, len = computes.length; i < len; i++ ) {\n\t\t\t\tcomputes[i].unbind(\"change\",k)\n\t\t\t}\n\t\t\tcomputes = null;\n\t\t}\n\t\n\t// Binds computes for a moment to retain their value and prevent caching\n\tcan.compute.temporarilyBind = function(compute){\n\t\tcompute.bind(\"change\",k)\n\t\tif(!computes){\n\t\t\tcomputes = [];\n\t\t\tsetTimeout(unbindComputes,10)\n\t\t} \n\t\tcomputes.push(compute)\n\t};\n\t\n\tcan.compute.binder = computeBinder;\n\tcan.compute.truthy = function(compute){\n\t\treturn can.compute(function(){\n\t\t\tvar res = compute();\n\t\t\tif(typeof res === \"function\"){\n\t\t\t\tres = res()\n\t\t\t}\n\t\t\treturn !!res;\n\t\t})\n\t}\n\treturn can.compute;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/scope',[\"can/util/library\", \"can/construct\", \"can/map\", \"can/list\", \"can/view\", \"can/compute\"], function(can){\n\t\n\t\n\t\n\tvar isObserve = function(obj) {\n\t\treturn obj instanceof can.Map || (obj && obj.__get);\n\t},\n\t\tgetProp = function(obj, prop){\n\t\t\tvar val = obj[prop];\n\t\n\t\t\tif(typeof val !== \"function\" && obj.__get) {\n\t\t\t\treturn obj.__get(prop);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t},\n\t\tescapeReg = /(\\\\)?\\./g,\n\t\tescapeDotReg = /\\\\\\./g,\n\t\tgetNames = function(attr){\n\t\t\tvar names = [], last = 0;\n\t\t\tattr.replace(escapeReg, function($0, $1, index) {\n\t\t\t\tif (!$1) {\n\t\t\t\t\tnames.push(attr.slice(last, index).replace(escapeDotReg,'.'));\n\t\t\t\t\tlast = index + $0.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\tnames.push(attr.slice(last).replace(escapeDotReg,'.'));\n\t\t\treturn names;\n\t\t}\n\t\n\n\t/**\n\t * @add can.view.Scope\n\t */\n\tvar Scope = can.Construct.extend(\n\t\t\n\t/**\n\t * @static\n\t */\t\n\t{\n\t\t// reads properties from a parent.  A much more complex version of getObject.\n\t\t/**\n\t\t * @function can.view.Scope.read read\n\t\t * @parent can.view.Scope.static\n\t\t * \n\t\t * @signature `Scope.read(parent, reads, options)`\n\t\t * \n\t\t * Read properties from an object.\n\t\t * \n\t\t * @param {*} parent A parent object to read properties from.\n\t\t * @param {Array<String>} reads An array of properties to read.\n\t\t * @param {can.view.Scope.readOptions} options Configures\n\t\t * how to read properties and values and register callbacks\n\t\t * \n\t\t * @return {{value: *, parent: *}} Returns an object that\n\t\t * provides the value and parent object.\n\t\t * \n\t\t * @option {*} value The value found by reading `reads` properties.  If \n\t\t * no value was found, value will be undefined.\n\t\t * \n\t\t * @option {*} parent The most immediate parent object of the value specified by `key`.\n\t\t * \n\t\t * @body\n\t\t *  \n\t\t * \n\t\t */\n\t\tread: function(parent, reads, options){\n\t\t\toptions = options || {};\n\t\t\t// `cur` is the current value.\n\t\t\tvar cur = parent,\n\t\t\t\ttype,\n\t\t\t\t// `prev` is the object we are reading from.\n\t\t\t\tprev,\n\t\t\t\t// `foundObs` did we find an observable.\n\t\t\t\tfoundObs;\n\t\t\tfor( var i = 0, readLength = reads.length ; i < readLength; i++ ) {\n\t\t\t\t// Update what we are reading from.\n\t\t\t\tprev = cur;\n\t\t\t\t// Read from the compute. We can't read a property yet.\n\t\t\t\tif( prev && prev.isComputed ) {\n\t\t\t\t\toptions.foundObservable && options.foundObservable(prev, i)\n\t\t\t\t\tprev = prev()\n\t\t\t\t}\n\t\t\t\t// Look to read a property from something.\n\t\t\t\tif( isObserve(prev) ) {\n\t\t\t\t\t!foundObs && options.foundObservable && options.foundObservable(prev, i);\n\t\t\t\t\tfoundObs = 1;\n\t\t\t\t\t// is it a method on the prototype?\n\t\t\t\t\tif(typeof prev[reads[i]] === \"function\" && prev.constructor.prototype[reads[i]] === prev[reads[i]] ){\n\t\t\t\t\t\t// call that method\n\t\t\t\t\t\tif(options.returnObserveMethods){\n\t\t\t\t\t\t\tcur = cur[reads[i]]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcur = prev[ reads[i] ].apply(prev, options.args ||[])\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use attr to get that value\n\t\t\t\t\t\tcur = cur.attr( reads[i] );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t// just do the dot operator\n\t\t\t\t\tcur = prev[reads[i]]\n\t\t\t\t}\n\t\t\t\t// If it's a compute, get the compute's value\n\t\t\t\t// unless we are at the end of the \n\t\t\t\tif( cur && cur.isComputed && (!options.isArgument && i < readLength - 1) ) {\n\t\t\t\t\t!foundObs && options.foundObservable && options.foundObservable(prev, i+1)\n\t\t\t\t\tcur = cur()\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttype = typeof cur;\n\t\t\t\t// if there are properties left to read, and we don't have an object, early exit\n\t\t\t\tif( i < reads.length -1 && ( cur == null || (type != \"function\" && type != \"object\" ) ) ) {\n\t\t\t\t\toptions.earlyExit && options.earlyExit(prev, i, cur);\n\t\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\t\treturn {value: undefined, parent: prev};\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if we don't have a value, exit early.\n\t\t\tif( cur === undefined ){\n\t\t\t\toptions.earlyExit && options.earlyExit(prev, i - 1)\n\t\t\t}\n\t\t\t// handle an ending function\n\t\t\tif(typeof cur === \"function\"){\n\t\t\t\tif( options.isArgument ) {\n\t\t\t\t\tif( ! cur.isComputed && options.proxyMethods !== false) {\n\t\t\t\t\t\tcur = can.proxy(cur, prev)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tcur.isComputed && !foundObs && options.foundObservable && options.foundObservable(cur, i)\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcur = cur.call(prev)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn {value: cur, parent: prev};\n\t\t}\n\t},\n\t/**\n\t * @prototype\n\t */\n\t{\n\t\tinit: function(context, parent){\n\t\t\tthis._context = context;\n\t\t\tthis._parent = parent;\n\t\t},\n\t\t/**\n\t\t * @function can.view.Scope.prototype.attr\n\t\t * \n\t\t * Reads a value from the current context or parent contexts.\n\t\t * \n\t\t * @param {can.Mustache.key} key A dot seperated path.  Use `\"\\.\"` if you have a \n\t\t * property name that includes a dot. \n\t\t * \n\t\t * @return {*} The found value or undefined if no value is found.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `scope.attr(key)` looks up a value in the current scope's \n\t\t * context, if a value is not found, parent scope's context\n\t\t * will be explored.\n\t\t * \n\t\t *     var list = [{name: \"Justin\"},{name: \"Brian\"}],\n\t\t *     \t   justin = list[0];\n\t\t *     \t\n\t\t *     var curScope = new can.view.Scope(list).add(justin);\n\t\t *     \n\t\t *     curScope.attr(\"name\") //-> \"Justin\"\n\t\t *     curScope.attr(\"length\") //-> 2\n\t\t */\n\t\tattr: function(key){\n\t\t\treturn this.read(key,{isArgument: true, returnObserveMethods:true, proxyMethods: false}).value\n\t\t},\n\t\t/**\n\t\t * @function can.view.Scope.prototype.add\n\t\t * \n\t\t * Creates a new scope with its parent set as the current scope.\n\t\t * \n\t\t * @param {*} context The context of the new scope object. \n\t\t * \n\t\t * @return {can.view.Scope}  A scope object.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `scope.add(context)` creates a new scope object that\n\t\t * first looks up values in context and then in the \n\t\t * parent `scope` object.\n\t\t * \n\t\t *     var list = [{name: \"Justin\"},{name: \"Brian\"}],\n\t\t *     \t   justin = list[0];\n\t\t *     \t\n\t\t *     var curScope = new can.view.Scope(list).add(justin);\n\t\t *     \n\t\t *     curScope.attr(\"name\") //-> \"Justin\"\n\t\t *     curScope.attr(\"length\") //-> 2\n\t\t */\n\t\tadd: function(context){\n\t\t\tif(context !== this._context){\n\t\t\t\treturn new this.constructor( context, this );\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.view.Scope.prototype.computeData\n\t\t * \n\t\t * @description Provides a compute that represents a \n\t\t * key's value and other information about where the value was found.\n\t\t * \n\t\t *\n\t\t * @param {can.Mustache.key} key A dot seperated path.  Use `\"\\.\"` if you have a \n\t\t * property name that includes a dot. \n\t\t * \n\t\t * @param {can.view.Scope.readOptions} [options] Options that configure how the `key` gets read.\n\t\t * \n\t\t * @return {{}} An object with the following values:\n\t\t * \n\t\t * @option {can.compute} compute A compute that returns the \n\t\t * value of `key` looked up in the scope's context or parent context. This compute can\n\t\t * also be written to, which will set the observable attribute or compute value at the \n\t\t * location represented by the key.\n\t\t * \n\t\t * @option {can.view.Scope} scope The scope the key was found within. The key might have\n\t\t * been found in a parent scope.\n\t\t * \n\t\t * @option {*} initialData The initial value at the key's location.\n\t\t * \n\t\t * @body\n\t\t *  \n\t\t * ## Use\n\t\t * \n\t\t * `scope.computeData(key, options)` is used heavily by [can.Mustache] to get the value of \n\t\t * a [can.Mustache.key key] value in a template. Configure how it reads values in the\n\t\t * scope and what values it returns with the [can.view.Scope.readOptions options] argument.\n\t\t * \n\t\t *     var context = new Map({\n\t\t *       name: {first: \"Curtis\"}  \n\t\t *     })\n\t\t *     var scope = new can.view.Scope(context)\n\t\t *     var computeData = scope.computeData(\"name.first\");\n\t\t * \n\t\t *     computeData.scope === scope //-> true\n\t\t *     computeData.initialValue    //-> \"Curtis\"\n\t\t *     computeData.compute()       //-> \"Curtis\"\n\t\t * \n\t\t * The `compute` value is writable.  For example:\n\t\t * \n\t\t *     computeData.compute(\"Andy\")\n\t\t *     context.attr(\"name.first\") //-> \"Andy\"\n\t\t * \n\t\t */\n\t\tcomputeData: function(key, options ){\n\t\t\toptions = options || {args: []};\n\t\t\tvar self = this,\n\t\t\t\trootObserve,\n\t\t\t\trootReads,\n\t\t\t\tcomputeData = {\n\t\t\t\t\tcompute: can.compute(function(newVal){\n\t\t\t\t\t\tif(arguments.length){\n\t\t\t\t\t\t\t// check that there's just a compute with nothing from it ...\n\t\t\t\t\t\t\tif(rootObserve.isComputed && !rootReads.length){\n\t\t\t\t\t\t\t\trootObserve(newVal)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar last = rootReads.length-1;\n\t\t\t\t\t\t\t\tScope.read(rootObserve,rootReads.slice(0, last)).value.attr(rootReads[last], newVal)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif( rootObserve ) {\n\t\t\t\t\t\t\t\treturn Scope.read(rootObserve, rootReads,  options).value\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// otherwise, go get the value\n\t\t\t\t\t\t\tvar data = self.read(key, options);\n\t\t\t\t\t\t\trootObserve = data.rootObserve;\n\t\t\t\t\t\t\trootReads = data.reads;\n\t\t\t\t\t\t\tcomputeData.scope = data.scope;\n\t\t\t\t\t\t\tcomputeData.initialValue = data.value;\n\t\t\t\t\t\t\treturn data.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\treturn computeData\n\t\t\t\n\t\t},\n\t\t/**\n\t\t * @hide\n\t\t * @function can.view.Scope.prototype.read read\n\t\t * \n\t\t * Read a key value from the scope and provide useful information\n\t\t * about what was found along the way.\n\t\t * \n\t\t * @param {can.Mustache.key} attr A dot seperated path.  Use `\"\\.\"` if you have a property name that includes a dot. \n\t\t * @param {can.view.Scope.readOptions} options that configure how this gets read.\n\t\t * \n\t\t * @return {{}} \n\t\t * \n\t\t * @option {Object} parent the value's immediate parent\n\t\t * \n\t\t * @option {can.Map|can.compute} rootObserve the first observable to read from.\n\t\t * \n\t\t * @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.\n\t\t * \n\t\t * @option {*} value the found value\n\t\t */\n\t\tread : function(attr, options){\n\t\t\t\n\t\t\t// check if we should be running this on a parent.\n\t\t\tif( attr.substr(0,3) === \"../\" ) {\n\t\t\t\treturn this._parent.read( attr.substr(3), options )\n\t\t\t} else if(attr == \"..\"){\n\t\t\t\treturn {value: this._parent._context}\n\t\t\t} else if(attr == \".\" || attr == \"this\"){\n\t\t\t\treturn {value: this._context};\n\t\t\t}\n\t\t\t\n\t\t\t// Split the name up.\n\t\t\tvar names = attr.indexOf('\\\\.') == -1 \n\t\t\t\t// Reference doesn't contain escaped periods\n\t\t\t\t? attr.split('.')\n\t\t\t\t// Reference contains escaped periods (`a.b\\c.foo` == `a[\"b.c\"].foo)\n\t\t\t\t: getNames(attr),\n\t\t\t\tnamesLength = names.length,\n\t\t\t\tj,\n\t\t\t\t// The current context (a scope is just data and a parent scope).\n\t\t\t\tcontext,\n\t\t\t\t// The current scope.\n\t\t\t\tscope = this,\n\t\t\t\t// While we are looking for a value, we track the most likely place this value will be found.  \n\t\t\t\t// This is so if there is no me.name.first, we setup a listener on me.name.\n\t\t\t\t// The most likely canidate is the one with the most \"read matches\" \"lowest\" in the\n\t\t\t\t// context chain.\n\t\t\t\t// By \"read matches\", we mean the most number of values along the key.\n\t\t\t\t// By \"lowest\" in the context chain, we mean the closest to the current context.\n\t\t\t\t// We track the starting position of the likely place with `defaultObserve`.\n\t\t\t\tdefaultObserve,\n\t\t\t\t// Tracks how to read from the defaultObserve.\n\t\t\t\tdefaultReads = [],\n\t\t\t\t// Tracks the highest found number of \"read matches\".\n\t\t\t\tdefaultPropertyDepth = -1,\n\t\t\t\t// `scope.read` is designed to be called within a compute, but\n\t\t\t\t// for performance reasons only listens to observables within one context.\n\t\t\t\t// This is to say, if you have me.name in the current context, but me.name.first and\n\t\t\t\t// we are looking for me.name.first, we don't setup bindings on me.name and me.name.first.\n\t\t\t\t// To make this happen, we clear readings if they do not find a value.  But,\n\t\t\t\t// if that path turns out to be the default read, we need to restore them.  This\n\t\t\t\t// variable remembers those reads so they can be restored.\n\t\t\t\tdefaultComputeReadings,\n\t\t\t\t// Tracks the default's scope.\n\t\t\t\tdefaultScope,\n\t\t\t\t// Tracks the first found observe.\n\t\t\t\tcurrentObserve,\n\t\t\t\t// Tracks the reads to get the value for a scope.\n\t\t\t\tcurrentReads;\n\t\t\t\t\n\t\t\t// While there is a scope/context to look in.\n\t\t\twhile(scope){\n\t\t\t\t\n\t\t\t\t// get the context\n\t\t\t\tcontext = scope._context;\n\n\t\t\t\tif (context != null) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// Lets try this context\n\t\t\t\t\tvar data = Scope.read(context, names, can.simpleExtend({\n\t\t\t\t\t\t// Called when an observable is found.\n\t\t\t\t\t\tfoundObservable: function(observe, nameIndex){\n\t\t\t\t\t\t\t// Save the current observe.\n\t\t\t\t\t\t\tcurrentObserve = observe;\n\t\t\t\t\t\t\tcurrentReads = names.slice(nameIndex);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Called when we were unable to find a value.\n\t\t\t\t\t\tearlyExit: function(parentValue, nameIndex){\n\t\t\t\t\t\t\t// If this has more matching values,\n\t\t\t\t\t\t\tif(nameIndex > defaultPropertyDepth) {\n\t\t\t\t\t\t\t\t// save the state.\n\t\t\t\t\t\t\t\tdefaultObserve = currentObserve;\n\t\t\t\t\t\t\t\tdefaultReads = currentReads;\n\t\t\t\t\t\t\t\tdefaultPropertyDepth = nameIndex;\n\t\t\t\t\t\t\t\tdefaultScope = scope;\n\t\t\t\t\t\t\t\t// Clear and save readings so next attempt does not use these readings\n\t\t\t\t\t\t\t\tdefaultComputeReadings = can.__clearReading && can.__clearReading();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}, options));\n\t\t\t\t\t\n\t\t\t\t\t// Found a matched reference.\n\t\t\t\t\tif (data.value !== undefined ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\trootObserve: currentObserve,\n\t\t\t\t\t\t\tvalue: data.value,\n\t\t\t\t\t\t\treads: currentReads\n\t\t\t\t\t\t}; \n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\t// Prevent prior readings.\n\t\t\t\tcan.__clearReading && can.__clearReading();\n\t\t\t\t// Move up to the next scope.\n\t\t\t\tscope = scope._parent;\n\t\t\t}\n\t\t\t// If there was a likely observe.\n\t\t\tif( defaultObserve ) {\n\t\t\t\t// Restore reading for previous compute\n\t\t\t\tcan.__setReading && can.__setReading(defaultComputeReadings)\n\t\t\t\treturn {\n\t\t\t\t\tscope: defaultScope,\n\t\t\t\t\trootObserve: defaultObserve,\n\t\t\t\t\treads: defaultReads,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we found nothing and no observable\n\t\t\t\treturn {\n\t\t\t\t\tnames: names,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t}\n\t});\n\tcan.view.Scope = Scope;\n\treturn Scope;\n\t\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/elements',[],function(){\n\t/**\n\t * @property {Object} can.view.elements\n\t * @parent can.view\n\t * \n\t * Provides helper methods for and information about the behavior\n\t * of DOM elements.  \n\t */\n\tvar elements = {\n\t\ttagToContentPropMap: {\n\t\t\toption: \"textContent\" in document.createElement(\"option\") ? \"textContent\" : \"innerText\",\n\t\t\ttextarea: \"value\"\n\t\t},\n\t\t/**\n\t\t * @property {Object.<String,(String|Boolean|function)>} can.view.elements.attrMap \n\t\t * @parent can.view.elements\n\t\t * \n\t\t * \n\t\t * A mapping of\n\t\t * special attributes to their JS property. For example:\n\t\t * \n\t\t *     \"class\" : \"className\"\n\t\t * \n\t\t * means get or set `element.className`. And: \n\t\t * \n\t\t *      \"checked\" : true\n\t\t * \n\t\t * means set `element.checked = true`.\n\t\t *     \n\t\t * \n\t\t * If the attribute name is not found, it's assumed to use\n\t\t * `element.getAttribute` and `element.setAttribute`.\n\t\t */\n\t\tattrMap: {\n\t\t\t\"class\" : \"className\",\n\t\t\t\"value\": \"value\",\n\t\t\t\"innerText\" : \"innerText\",\n\t\t\t\"textContent\" : \"textContent\",\n\t\t\t\"checked\": true,\n\t\t\t\"disabled\": true,\n\t\t\t\"readonly\": true,\n\t\t\t\"required\": true,\n\t\t\tsrc: function(el, val){\n\t\t\t\tif(val == null || val == \"\"){\n\t\t\t\t\tel.removeAttribute(\"src\")\n\t\t\t\t} else {\n\t\t\t\t\tel.setAttribute(\"src\",val)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// matches the attrName of a regexp\n\t\tattrReg: /([^\\s]+)[\\s]*=[\\s]*/,\n\t\t// elements whos default value we should set\n\t\tdefaultValue : [\"input\",\"textarea\"],\n\t\t// a map of parent element to child elements\n\t\t/**\n\t\t * @property {Object.<String,String>} can.view.elements.tagMap \n\t\t * @parent can.view.elements\n\t\t * \n\t\t * A mapping of parent node names to child node names that can be inserted within\n\t\t * the parent node name.  For example: `table: \"tbody\"` means that\n\t\t * if you want a placeholder element within a `table`, a `tbody` will be\n\t\t * created.\n\t\t */\n\t\ttagMap : {\n\t\t\t\"\": \"span\", \n\t\t\ttable: \"tbody\", \n\t\t\ttr: \"td\",\n\t\t\tol: \"li\", \n\t\t\tul: \"li\", \n\t\t\ttbody: \"tr\",\n\t\t\tthead: \"tr\",\n\t\t\ttfoot: \"tr\",\n\t\t\tselect: \"option\",\n\t\t\toptgroup: \"option\"\n\t\t},\n\t\t// a tag's parent element\n\t\treverseTagMap: {\n\t\t\ttr:\"tbody\",\n\t\t\toption:\"select\",\n\t\t\ttd:\"tr\",\n\t\t\tth:\"tr\",\n\t\t\tli: \"ul\"\n\t\t},\n\t\t// Used to determine the parentNode if el is directly within a documentFragment\n\t\tgetParentNode: function(el, defaultParentNode){\n\t\t\treturn defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;\n\t\t},\n\t\t// Set an attribute on an element\n\t\tsetAttr: function (el, attrName, val) {\n\t\t\tvar tagName = el.nodeName.toString().toLowerCase(),\n\t\t\t\tprop = elements.attrMap[attrName];\n\t\t\t// if this is a special property\n\t\t\tif(typeof prop === \"function\"){\n\t\t\t\tprop(el, val)\n\t\t\t} else if(prop === true) {\n\t\t\t\tel[attrName]  = true;\n\t\t\t} else if (prop) {\n\t\t\t\t// set the value as true / false\n\t\t\t\tel[prop] = val;\n\t\t\t\tif( prop === \"value\" && can.inArray(tagName, elements.defaultValue) >= 0 ) {\n\t\t\t\t\tel.defaultValue = val;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.setAttribute(attrName, val);\n\t\t\t}\n\t\t},\n\t\t// Gets the value of an attribute.\n\t\tgetAttr: function(el, attrName){\n\t\t\t// Default to a blank string for IE7/8\n\t\t\treturn (elements.attrMap[attrName] && el[elements.attrMap[attrName]] ?\n\t\t\t\tel[elements.attrMap[attrName]]:\n\t\t\t\tel.getAttribute(attrName)) || '';\n\t\t},\n\t\t// Removes the attribute.\n\t\tremoveAttr: function(el, attrName){\n\t\t\tvar setter = elements.attrMap[attrName];\n\t\t\tif(typeof prop === \"function\"){\n\t\t\t\tprop(el, undefined)\n\t\t\t} if( setter === true ) {\n\t\t\t\tel[attrName] = false;\n\t\t\t} else if(typeof setter === \"string\"){\n\t\t\t\tel[setter] = \"\";\n\t\t\t} else {\n\t\t\t\tel.removeAttribute(attrName);\n\t\t\t}\n\t\t},\n\t\t// Gets a \"pretty\" value for something\n\t\tcontentText: function(text){\n\t\t\tif ( typeof text == 'string' ) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\t// If has no value, return an empty string.\n\t\t\tif ( !text && text !== 0 ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn \"\" + text;\n\t\t},\n\t\t/**\n\t\t * @function can.view.elements.after \n\t\t * @parent can.view.elements\n\t\t * \n\t\t * Inserts newFrag after oldElements.\n\t\t * \n\t\t * @param {Array.<HTMLElement>} oldElements\n\t\t * @param {DocumentFragment} newFrag\n\t\t */\n\t\tafter: function(oldElements, newFrag){\n\t\t\tvar last = oldElements[oldElements.length - 1];\n\t\t\t\t\t\n\t\t\t// Insert it in the `document` or `documentFragment`\n\t\t\tif( last.nextSibling ){\n\t\t\t\tcan.insertBefore(last.parentNode, newFrag, last.nextSibling)\n\t\t\t} else {\n\t\t\t\tcan.appendChild(last.parentNode, newFrag);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.view.elements.replace \n\t\t * @parent can.view.elements\n\t\t * \n\t\t * Replaces `oldElements` with `newFrag`\n\t\t * \n\t\t * @param {Array.<HTMLElement>} oldElements\n\t\t * @param {DocumentFragment} newFrag\n\t\t */\n\t\treplace: function(oldElements,newFrag){\n\t\t\telements.after(oldElements,newFrag);\n\t\t\tcan.remove( can.$(oldElements) );\n\t\t}\n\t};\n\t// TODO: this doesn't seem to be doing anything\n\t// feature detect if setAttribute works with styles\n\t(function(){\n\t\t// feature detect if \n\t\tvar div = document.createElement('div')\n\t\tdiv.setAttribute(\"style\",\"width: 5px\")\n\t\tdiv.setAttribute(\"style\",\"width: 10px\");\n\t\t// make style use cssText\n\t\telements.attrMap.style = function(el, val){\n\t\t\tel.style.cssText = val || \"\"\n\t\t}\n\t})();\n\t\n\t\n\treturn elements;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/scanner',[\"can/view\", \"can/view/elements\"], function(can, elements){\n\n/**\n * Helper(s)\n */\nvar newLine = /(\\r|\\n)+/g,\n\t// Escapes characters starting with `\\`.\n\tclean = function( content ) {\n\t\treturn content\n\t\t\t.split('\\\\').join(\"\\\\\\\\\")\n\t\t\t.split(\"\\n\").join(\"\\\\n\")\n\t\t\t.split('\"').join('\\\\\"')\n\t\t\t.split(\"\\t\").join(\"\\\\t\");\n\t},\n\t// Returns a tagName to use as a temporary placeholder for live content\n\t// looks forward ... could be slow, but we only do it when necessary\n\tgetTag = function(tagName, tokens, i){\n\t\t// if a tagName is provided, use that\n\t\tif(tagName){\n\t\t\treturn tagName;  \n\t\t} else {\n\t\t\t// otherwise go searching for the next two tokens like \"<\",TAG\n\t\t\twhile(i < tokens.length){\n\t\t\t\tif(tokens[i] == \"<\" && elements.reverseTagMap[tokens[i+1]]){\n\t\t\t\t\treturn elements.reverseTagMap[tokens[i+1]];\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t},\n\tbracketNum = function(content){\n\t\treturn (--content.split(\"{\").length) - (--content.split(\"}\").length);\n\t},\n\tmyEval = function( script ) {\n\t\teval(script);\n\t},\n\tattrReg = /([^\\s]+)[\\s]*=[\\s]*$/,\n\t// Commands for caching.\n\tstartTxt = 'var ___v1ew = [];',\n\tfinishTxt = \"return ___v1ew.join('')\",\n\tput_cmd = \"___v1ew.push(\\n\",\n\tinsert_cmd = put_cmd,\n\t// Global controls (used by other functions to know where we are).\n\t// Are we inside a tag?\n\thtmlTag = null,\n\t// Are we within a quote within a tag?\n\tquote = null,\n\t// What was the text before the current quote? (used to get the `attr` name)\n\tbeforeQuote = null,\n\t// Whether a rescan is in progress\n\trescan = null,\n\tgetAttrName = function(){\n\t\tvar matches = beforeQuote.match(attrReg);\n\t\treturn matches && matches[1];\n\t},\n\t// Used to mark where the element is.\n\tstatus = function(){\n\t\t// `t` - `1`.\n\t\t// `h` - `0`.\n\t\t// `q` - String `beforeQuote`.\n\t\treturn quote ? \"'\"+getAttrName()+\"'\" : (htmlTag ? 1 : 0);\n\t},\n\t// returns the top of a stack\n\ttop = function(stack){\n\t\treturn stack[stack.length-1]\n\t},\n\t// characters that automatically mean a custom element\n\tautomaticCustomElementCharacters = /[-\\:]/,\n\tScanner;\n\n/**\n * @constructor can.view.Scanner\n * \n * can.view.Scanner is used to convert a template into a JavaScript function.  That\n * function is called to produce a rendered result as a string. Often\n * the rendered result will include data-view-id attributes on elements that\n * will be processed after the template is used to create a document fragment.\n * \n * \n * @param {{text: can.view.Scanner.text, tokens: Array<can.view.Scanner.token>, helpers: Array<can.view.Scanner.helpers>}}\n */\n//\n/**\n * @typedef {{0:String,}}\n */\n\ncan.view.Scanner = Scanner = function( options ) {\n\t// Set options on self\n\tcan.extend(this, {\n  \t\t/**\n  \t\t * @typedef {{start: String, escape: String, scope: String, options: String}}  can.view.Scanner.text\n  \t\t */\n\t\ttext: {},\n\t\ttokens: []\n\t}, options);\n\t// make sure it's an empty string if it's not\n\tthis.text.options = this.text.options || \"\"\n\t\n\t// Cache a token lookup\n\tthis.tokenReg = [];\n\tthis.tokenSimple = { \"<\": \"<\", \">\": \">\", '\"': '\"', \"'\": \"'\" };\n\tthis.tokenComplex = [];\n\tthis.tokenMap = {};\n\tfor (var i = 0, token; token = this.tokens[i]; i++) {\n\t\t/**\n\t\t * Token data structure (complex token and rescan function are optional):\n\t\t * [\n\t\t *\t\"token name\",\n\t\t *\t\"simple token or abbreviation\",\n\t\t *\t/complex token regexp/,\n\t\t *\tfunction(content) {\n\t\t *\t\t// Rescan Function\n\t\t *\t\treturn {\n\t\t *\t\t\tbefore: '\\n',\n\t\t *\t\t\tcontent: content.trim(),\n\t\t *\t\t\tafter: '\\n'\n\t\t *\t\t}\n\t\t * ]\n\t\t */\n\t\t\n\t\t// Save complex mappings (custom regexp)\n\t\tif (token[2]) {\n\t\t\tthis.tokenReg.push(token[2]);\n\t\t\tthis.tokenComplex.push({ abbr: token[1], re: new RegExp(token[2]), rescan: token[3] });\n\t\t}\n\t\t// Save simple mappings (string only, no regexp)\n\t\telse {\n\t\t\tthis.tokenReg.push(token[1]);\n\t\t\tthis.tokenSimple[token[1]] = token[0];\n\t\t}\n\t\tthis.tokenMap[token[0]] = token[1];\n\t}\n\t\n\t// Cache the token registry.\n\tthis.tokenReg = new RegExp(\"(\" + this.tokenReg.slice(0).concat([\"<\", \">\", '\"', \"'\"]).join(\"|\") + \")\",\"g\");\n};\n\nScanner.attributes = {};\nScanner.regExpAttributes = {};\n\nScanner.attribute = function(attribute, callback){\n\tif(typeof attribute == \"string\"){\n\t\tScanner.attributes[attribute] = callback;\n\t} else {\n\t\tScanner.regExpAttributes[attribute] = {\n\t\t\tmatch: attribute,\n\t\t\tcallback: callback\n\t\t};\n\t}\n\t\n}\nScanner.hookupAttributes = function(options, el){\n\tcan.each(options && options.attrs || [], function(attr){\n\t\toptions.attr = attr;\n\t\tif(Scanner.attributes[attr]) {\n\t\t\tScanner.attributes[attr](options,el);\n\t\t} else {\n\t\t\tcan.each(Scanner.regExpAttributes,function(attrMatcher){\n\t\t\t\tif(attrMatcher.match.test(attr)){\n\t\t\t\t\tattrMatcher.callback(options, el)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\t\n\t})\n}\nScanner.tag = function( tagName, callback){\n\t// if we have html5shive ... re-generate\n\tif(window.html5){\n\t\thtml5.elements += \" \"+tagName\n\t\thtml5.shivDocument();\n\t}\n\t\n\tScanner.tags[tagName.toLowerCase()] = callback;\n}\nScanner.tags = {};\n// This is called when there is a special tag\nScanner.hookupTag = function(hookupOptions){\n\t// we need to call any live hookups\n\t// so get that and return the hook\n\t// a better system will always be called with the same stuff\n\tvar hooks = can.view.getHooks();\n\treturn can.view.hook(function(el){\n\t\tcan.each(hooks, function(fn){\n\t\t\tfn(el);\n\t\t});\n\t\t\n\t\tvar tagName= hookupOptions.tagName,\n\t\t\thelperTagCallback = hookupOptions.options.read('helpers._tags.'+tagName,{isArgument: true, proxyMethods: false}).value,\n\t\t\ttagCallback = helperTagCallback || Scanner.tags[tagName];\n\t\t\t\n\t\t// If this was an element like <foo-bar> that doesn't have a component, just render its content\n\t\tvar scope = hookupOptions.scope,\n\t\t\tres = tagCallback ? tagCallback(el, hookupOptions) : scope;\n\t\t\t\n\t\t// If the tagCallback gave us something to render with, and there is content within that element\n\t\t// render it!\n\t\tif(res && hookupOptions.subtemplate){\n\t\t\t\n\t\t\tif(scope !== res){\n\t\t\t\tscope = scope.add(res)\n\t\t\t}\n\t\t\tvar frag = can.view.frag( hookupOptions.subtemplate(scope, hookupOptions.options) );\n\t\t\tcan.appendChild(el, frag);\n\t\t}\n\t\tcan.view.Scanner.hookupAttributes(hookupOptions, el);\n\t});\n\t\n}\n\n/**\n * Extend can.View to add scanner support.\n */\nScanner.prototype = {\n\t// a default that can be overwritten\n\thelpers: [],\n\n\tscan: function(source, name){\n\t\tvar tokens = [],\n\t\t\tlast = 0,\n\t\t\tsimple = this.tokenSimple,\n\t\t\tcomplex = this.tokenComplex;\n\t\t\n\t\tsource = source.replace(newLine, \"\\n\");\n\t\tif (this.transform) {\n\t\t\tsource = this.transform(source);\n\t\t}\n\t\tsource.replace(this.tokenReg, function(whole, part){\n\t\t\t// offset is the second to last argument\n\t\t\tvar offset = arguments[arguments.length-2];\n\t\t\t\n\t\t\t// if the next token starts after the last token ends\n\t\t\t// push what's in between\n\t\t\tif(offset > last){\n\t\t\t\ttokens.push( source.substring(last, offset) );\n\t\t\t}\n\t\t\t\n\t\t\t// push the simple token (if there is one)\n\t\t\tif (simple[whole]) {\n\t\t\t\ttokens.push(whole);\n\t\t\t}\n\t\t\t// otherwise lookup complex tokens\n\t\t\telse {\n\t\t\t\tfor (var i = 0, token; token = complex[i]; i++) {\n\t\t\t\t\tif (token.re.test(whole)) {\n\t\t\t\t\t\ttokens.push(token.abbr);\n\t\t\t\t\t\t// Push a rescan function if one exists\n\t\t\t\t\t\tif (token.rescan) {\n\t\t\t\t\t\t\ttokens.push(token.rescan(part));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update the position of the last part of the last token\n\t\t\tlast = offset+part.length;\n\t\t});\n\n\t\t// if there's something at the end, add it\n\t\tif(last < source.length){\n\t\t\ttokens.push(source.substr(last));\n\t\t}\n\t\t\n\t\tvar content = '',\n\t\t\tbuff = [startTxt + (this.text.start || '')],\n\t\t\t// Helper `function` for putting stuff in the view concat.\n\t\t\tput = function( content, bonus ) {\n\t\t\t\tbuff.push(put_cmd, '\"', clean(content), '\"'+(bonus||'')+');');\n\t\t\t},\n\t\t\t// A stack used to keep track of how we should end a bracket\n\t\t\t// `}`.  \n\t\t\t// Once we have a `<%= %>` with a `leftBracket`,\n\t\t\t// we store how the file should end here (either `))` or `;`).\n\t\t\tendStack =[],\n\t\t\t// The last token, used to remember which tag we are in.\n\t\t\tlastToken,\n\t\t\t// The corresponding magic tag.\n\t\t\tstartTag = null,\n\t\t\t// Was there a magic tag inside an html tag?\n\t\t\tmagicInTag = false,\n\t\t\t// was there a special state\n\t\t\tspecialStates = {\n\t\t\t\tattributeHookups: [],\n\t\t\t\t// a stack of tagHookups\n\t\t\t\ttagHookups: []\n\t\t\t},\n\t\t\t// The current tag name.\n\t\t\ttagName = '',\n\t\t\t// stack of tagNames\n\t\t\ttagNames = [],\n\t\t\t// Pop from tagNames?\n\t\t\tpopTagName = false,\n\t\t\t// Declared here.\n\t\t\tbracketCount,\n\t\t\t\n\t\t\t// in a special attr like src= or style=\n\t\t\tspecialAttribute = false,\n\t\t\t\n\t\t\ti = 0,\n\t\t\ttoken,\n\t\t\ttmap = this.tokenMap,\n\t\t\tattrName;\n\n\t\t// Reinitialize the tag state goodness.\n\t\thtmlTag = quote = beforeQuote = null;\n\n\t\tfor (; (token = tokens[i++]) !== undefined;) {\n\t\t\tif ( startTag === null ) {\n\t\t\t\tswitch ( token ) {\n\t\t\t\tcase tmap.left:\n\t\t\t\tcase tmap.escapeLeft:\n\t\t\t\tcase tmap.returnLeft:\n\t\t\t\t\tmagicInTag = htmlTag && 1;\n\t\t\t\tcase tmap.commentLeft:\n\t\t\t\t\t// A new line -- just add whatever content within a clean.  \n\t\t\t\t\t// Reset everything.\n\t\t\t\t\tstartTag = token;\n\t\t\t\t\tif ( content.length ) {\n\t\t\t\t\t\tput(content);\n\t\t\t\t\t}\n\t\t\t\t\tcontent = '';\n\t\t\t\t\tbreak;\n\t\t\t\tcase tmap.escapeFull:\n\t\t\t\t\t// This is a full line escape (a line that contains only whitespace and escaped logic)\n\t\t\t\t\t// Break it up into escape left and right\n\t\t\t\t\tmagicInTag = htmlTag && 1;\n\t\t\t\t\trescan = 1;\n\t\t\t\t\tstartTag = tmap.escapeLeft;\n\t\t\t\t\tif ( content.length ) {\n\t\t\t\t\t\tput(content);\n\t\t\t\t\t}\n\t\t\t\t\trescan = tokens[i++];\n\t\t\t\t\tcontent = rescan.content || rescan;\n\t\t\t\t\tif ( rescan.before ) {\n\t\t\t\t\t\tput(rescan.before);\n\t\t\t\t\t}\n\t\t\t\t\ttokens.splice(i, 0, tmap.right);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tmap.commentFull:\n\t\t\t\t\t// Ignore full line comments.\n\t\t\t\t\tbreak;\n\t\t\t\tcase tmap.templateLeft:\n\t\t\t\t\tcontent += tmap.left;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\t// Make sure we are not in a comment.\n\t\t\t\t\tif(tokens[i].indexOf(\"!--\") !== 0) {\n\t\t\t\t\t\thtmlTag = 1;\n\t\t\t\t\t\tmagicInTag = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcontent += token;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\thtmlTag = 0;\n\t\t\t\t\t// content.substr(-1) doesn't work in IE7/8\n\t\t\t\t\tvar emptyElement = (content.substr(content.length-1) == \"/\" || content.substr(content.length-2) == \"--\"),\n\t\t\t\t\t\tattrs = \"\";\n\t\t\t\t\t// if there was a magic tag\n\t\t\t\t\t// or it's an element that has text content between its tags, \n\t\t\t\t\t// but content is not other tags add a hookup\n\t\t\t\t\t// TODO: we should only add `can.EJS.pending()` if there's a magic tag \n\t\t\t\t\t// within the html tags.\n\t\t\t\t\tif(specialStates.attributeHookups.length) {\n\t\t\t\t\t\tattrs = \"attrs: ['\"+specialStates.attributeHookups.join(\"','\")+\"'], \";\n\t\t\t\t\t\tspecialStates.attributeHookups = [];\n\t\t\t\t\t}\n\t\t\t\t\t// this is the > of a special tag\n\t\t\t\t\tif(tagName === top(specialStates.tagHookups) ){\n\t\t\t\t\t\t// If it's a self closing tag (like <content/>) make sure we put the / at the end.\n\t\t\t\t\t\tif(emptyElement) {\n\t\t\t\t\t\t\tcontent = content.substr(0,content.length-1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Put the start of the end\n\t\t\t\t\t\tbuff.push(put_cmd, \n\t\t\t\t\t\t\t\t '\"', clean(content), '\"', \n\t\t\t\t\t\t\t\t \",can.view.Scanner.hookupTag({tagName:'\"+tagName+\"',\"+(attrs)+\"scope: \"+(this.text.scope || \"this\")+this.text.options)\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if it's a self closing tag (like <content/>) close and end the tag\n\t\t\t\t\t\tif(emptyElement) {\n\t\t\t\t\t\t\tbuff.push(\"}));\");\n\t\t\t\t\t\t\tcontent = \"/>\";\n\t\t\t\t\t\t\tspecialStates.tagHookups.pop()\n\t\t\t\t\t\t} \n\t\t\t\t\t\t// if it's an empty tag\t \n\t\t\t\t\t\telse if( tokens[i] === \"<\" &&  tokens[i+1] === \"/\"+tagName ){\n\t\t\t\t\t\t\tbuff.push(\"}));\");\n\t\t\t\t\t\t\tcontent = token;\n\t\t\t\t\t\t\tspecialStates.tagHookups.pop()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// it has content\n\t\t\t\t\t\t\tbuff.push(\",subtemplate: function(\"+this.text.argNames+\"){\\n\"+ startTxt+(this.text.start || '') );\n\t\t\t\t\t\t\tcontent = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if(magicInTag || (!popTagName && elements.tagToContentPropMap[ tagNames[tagNames.length -1] ] ) || attrs ){\n\t\t\t\t\t\t// make sure / of /> is on the right of pending\n\t\t\t\t\t\tvar pendingPart = \",can.view.pending({\"+attrs+\"scope: \"+(this.text.scope || \"this\")+this.text.options+\"}),\\\"\";\n\t\t\t\t\t\tif(emptyElement){\n\t\t\t\t\t\t\tput(content.substr(0,content.length-1),pendingPart+ \"/>\\\"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tput(content, pendingPart+\">\\\"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent = '';\n\t\t\t\t\t\tmagicInTag = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent += token;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// if it's a tag like <input/>\n\t\t\t\t\tif(emptyElement || popTagName){\n\t\t\t\t\t\t// remove the current tag in the stack\n\t\t\t\t\t\ttagNames.pop();\n\t\t\t\t\t\t// set the current tag to the previous parent\n\t\t\t\t\t\ttagName = tagNames[tagNames.length-1];\n\t\t\t\t\t\t// Don't pop next time\n\t\t\t\t\t\tpopTagName = false;\n\t\t\t\t\t}\n\t\t\t\t\tspecialStates.attributeHookups = [];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"'\":\n\t\t\t\tcase '\"':\n\t\t\t\t\t// If we are in an html tag, finding matching quotes.\n\t\t\t\t\tif(htmlTag){\n\t\t\t\t\t\t// We have a quote and it matches.\n\t\t\t\t\t\tif(quote && quote === token){\n\t\t\t\t\t\t\t// We are exiting the quote.\n\t\t\t\t\t\t\tquote = null;\n\t\t\t\t\t\t\t// Otherwise we are creating a quote.\n\t\t\t\t\t\t\t// TODO: does this handle `\\`?\n\t\t\t\t\t\t\tvar attr = getAttrName();\n\t\t\t\t\t\t\tif(Scanner.attributes[attr]){\n\t\t\t\t\t\t\t\tspecialStates.attributeHookups.push(attr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcan.each(Scanner.regExpAttributes,function(attrMatcher){\n\t\t\t\t\t\t\t\t\tif( attrMatcher.match.test(attr) ) {\n\t\t\t\t\t\t\t\t\t\tspecialStates.attributeHookups.push(attr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(specialAttribute) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontent += token;\n\t\t\t\t\t\t\t\tput(content);\n\t\t\t\t\t\t\t\tbuff.push(finishTxt, \"}));\\n\")\n\t\t\t\t\t\t\t\tcontent = \"\"\n\t\t\t\t\t\t\t\tspecialAttribute = false;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if(quote === null){\n\t\t\t\t\t\t\tquote = token;\n\t\t\t\t\t\t\tbeforeQuote = lastToken;\n\t\t\t\t\t\t\tattrName = getAttrName()\n\t\t\t\t\t\t\t// TODO: check if there's magic!!!!\n\t\t\t\t\t\t\tif( (tagName == \"img\" && attrName == \"src\") || attrName === \"style\" ) {\n\t\t\t\t\t\t\t\t// put content that was before the attr name, but don't include the src=\n\t\t\t\t\t\t\t\tput(content.replace(attrReg,\"\"));\n\t\t\t\t\t\t\t\tcontent = \"\";\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tspecialAttribute = true;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbuff.push(insert_cmd, \"can.view.txt(2,'\"+getTag(tagName,tokens, i)+\"',\" + status() + \",this,function(){\", startTxt);\n\t\t\t\t\t\t\t\tput(attrName+\"=\"+token);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t// Track the current tag\n\t\t\t\t\tif(lastToken === '<'){\n\t\t\t\t\t\t\n\t\t\t\t\t\ttagName = token.substr(0,3) === \"!--\" ?\n\t\t\t\t\t\t\t\"!--\" : token.split(/\\s/)[0];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar isClosingTag = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( tagName.indexOf(\"/\") === 0 ) {\n\t\t\t\t\t\t\tisClosingTag = true;\n\t\t\t\t\t\t\tvar cleanedTagName = tagName.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( isClosingTag ) { // </tag>\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// when we enter a new tag, pop the tag name stack\n\t\t\t\t\t\t\tif( top( tagNames ) === cleanedTagName ) {\n\t\t\t\t\t\t\t\t// set tagName to the last tagName\n\t\t\t\t\t\t\t\t// if there are no more tagNames, we'll rely on getTag.\n\t\t\t\t\t\t\t\ttagName = cleanedTagName;\n\t\t\t\t\t\t\t\tpopTagName = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if we are in a closing tag of a custom tag\n\t\t\t\t\t\t\tif( top( specialStates.tagHookups) == cleanedTagName ) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// remove the last < from the content\n\t\t\t\t\t\t\t\tput(content.substr(0, content.length-1));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// finish the \"section\"\n\t\t\t\t\t\t\t\tbuff.push(finishTxt+\"}}) );\" );\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// the < belongs to the outside\n\t\t\t\t\t\t\t\tcontent = \"><\"\n\t\t\t\t\t\t\t\tspecialStates.tagHookups.pop()\n\t\t\t\t\t\t\t} \n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif( tagName.lastIndexOf(\"/\") === tagName.length -1 ) {\n\t\t\t\t\t\t\t\ttagName = tagName.substr(0, tagName.length -1);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(tagName !== \"!--\" && ( Scanner.tags[tagName]  || automaticCustomElementCharacters.test(tagName) )){\n\t\t\t\t\t\t\t\t// if the content tag is inside something it doesn't belong ...\n\t\t\t\t\t\t\t\tif(tagName === \"content\" && elements.tagMap[top(tagNames)]){\n\t\t\t\t\t\t\t\t\t// convert it to an element that will work\n\t\t\t\t\t\t\t\t\ttoken = token.replace(\"content\",elements.tagMap[top(tagNames)])\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// we will hookup at the ending tag>\n\t\t\t\t\t\t\t\tspecialStates.tagHookups.push(tagName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttagNames.push(tagName);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcontent += token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We have a start tag.\n\t\t\t\tswitch ( token ) {\n\t\t\t\tcase tmap.right:\n\t\t\t\tcase tmap.returnRight:\n\t\t\t\t\tswitch ( startTag ) {\n\t\t\t\t\tcase tmap.left:\n\t\t\t\t\t\t// Get the number of `{ minus }`\n\t\t\t\t\t\tbracketCount = bracketNum(content);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// We are ending a block.\n\t\t\t\t\t\tif (bracketCount == 1) {\n\n\t\t\t\t\t\t\t// We are starting on.\n\t\t\t\t\t\t\tbuff.push(insert_cmd, \"can.view.txt(0,'\"+getTag(tagName,tokens, i)+\"',\" + status() + \",this,function(){\", startTxt, content);\n\n\t\t\t\t\t\t\tendStack.push({\n\t\t\t\t\t\t\t\tbefore: \"\",\n\t\t\t\t\t\t\t\tafter: finishTxt+\"}));\\n\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// How are we ending this statement?\n\t\t\t\t\t\t\tlast = // If the stack has value and we are ending a block...\n\t\t\t\t\t\t\t\tendStack.length && bracketCount == -1 ? // Use the last item in the block stack.\n\t\t\t\t\t\t\t\tendStack.pop() : // Or use the default ending.\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tafter: \";\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If we are ending a returning block, \n\t\t\t\t\t\t\t// add the finish text which returns the result of the\n\t\t\t\t\t\t\t// block.\n\t\t\t\t\t\t\tif (last.before) {\n\t\t\t\t\t\t\t\tbuff.push(last.before);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add the remaining content.\n\t\t\t\t\t\t\tbuff.push(content, \";\",last.after);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase tmap.escapeLeft:\n\t\t\t\t\tcase tmap.returnLeft:\n\t\t\t\t\t\t// We have an extra `{` -> `block`.\n\t\t\t\t\t\t// Get the number of `{ minus }`.\n\t\t\t\t\t\tbracketCount = bracketNum(content);\n\t\t\t\t\t\t// If we have more `{`, it means there is a block.\n\t\t\t\t\t\tif( bracketCount ){\n\t\t\t\t\t\t\t// When we return to the same # of `{` vs `}` end with a `doubleParent`.\n\t\t\t\t\t\t\tendStack.push({\n\t\t\t\t\t\t\t\tbefore : finishTxt,\n\t\t\t\t\t\t\t\tafter: \"}));\\n\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} \n\n\t\t\t\t\t\tvar escaped = startTag === tmap.escapeLeft ? 1 : 0,\n\t\t\t\t\t\t\tcommands = { \n\t\t\t\t\t\t\t\tinsert: insert_cmd, \n\t\t\t\t\t\t\t\ttagName: getTag(tagName, tokens, i), \n\t\t\t\t\t\t\t\tstatus: status(),\n\t\t\t\t\t\t\t\tspecialAttribute: specialAttribute\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor(var ii = 0; ii < this.helpers.length;ii++){\n\t\t\t\t\t\t\t// Match the helper based on helper\n\t\t\t\t\t\t\t// regex name value\n\t\t\t\t\t\t\tvar helper = this.helpers[ii];\n\t\t\t\t\t\t\tif(helper.name.test(content)){\n\t\t\t\t\t\t\t\tcontent = helper.fn(content, commands);\n\n\t\t\t\t\t\t\t\t// dont escape partials\n\t\t\t\t\t\t\t\tif(helper.name.source == /^>[\\s]*\\w*/.source){\n\t\t\t\t\t\t\t\t\tescaped = 0;\n\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Handle special cases\n\t\t\t\t\t\tif (typeof content == 'object') {\n\t\t\t\t\t\t\tif (content.raw) {\n\t\t\t\t\t\t\t\tbuff.push(content.raw);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (specialAttribute) {\n\t\t\t\t\t\t\tbuff.push(insert_cmd, content, ');');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If we have `<%== a(function(){ %>` then we want\n\t\t\t\t\t\t\t// `can.EJS.text(0,this, function(){ return a(function(){ var _v1ew = [];`.\n\t\t\t\t\t\t\tbuff.push(insert_cmd, \"can.view.txt(\\n\" + escaped + \",\\n'\"+tagName+\"',\\n\" + status() +\",\\nthis,\\nfunction(){ \" + (this.text.escape || '') + \"return \", content, \n\t\t\t\t\t\t\t\t// If we have a block.\n\t\t\t\t\t\t\t\tbracketCount ? \n\t\t\t\t\t\t\t\t// Start with startTxt `\"var _v1ew = [];\"`.\n\t\t\t\t\t\t\t\tstartTxt : \n\t\t\t\t\t\t\t\t// If not, add `doubleParent` to close push and text.\n\t\t\t\t\t\t\t\t\"}));\\n\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (rescan && rescan.after && rescan.after.length) {\n\t\t\t\t\t\t\tput(rescan.after.length);\n\t\t\t\t\t\t\trescan = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstartTag = null;\n\t\t\t\t\tcontent = '';\n\t\t\t\t\tbreak;\n\t\t\t\tcase tmap.templateLeft:\n\t\t\t\t\tcontent += tmap.left;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontent += token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastToken = token;\n\t\t}\n\t\t\n\t\t// Put it together...\n\t\tif ( content.length ) {\n\t\t\t// Should be `content.dump` in Ruby.\n\t\t\tput(content);\n\t\t}\n\t\tbuff.push(\";\");\n\t\tvar template = buff.join(''),\n\t\t\tout = {\n\t\t\t\tout: (this.text.outStart||\"\") + template + \" \"+finishTxt+(this.text.outEnd || \"\")\n\t\t\t};\n\t\t// Use `eval` instead of creating a function, because it is easier to debug.\n\t\tmyEval.call(out, 'this.fn = (function('+this.text.argNames+'){' + out.out + '});\\r\\n//@ sourceURL=' + name + \".js\");\n\n\t\treturn out;\n\t}\n};\n\ncan.view.Scanner.tag(\"content\",function(el, options){\n\treturn options.scope;\n})\n\nreturn Scanner;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/node_lists',[\"can/util/library\", \"can/view/elements\"], function(can){\n\n\n\t// In some browsers, text nodes can not take expando properties.\n\t// We test that here.\n\tvar canExpando = true;\n\ttry {\n\t\tdocument.createTextNode('')._ = 0;\n\t} catch (ex) {\n\t\tcanExpando = false;\n\t}\n\n\n\t// A mapping of element ids to nodeList id\n\tvar nodeMap = {},\n\t// A mapping of ids to text nodes\n\ttextNodeMap = {},\n\texpando = \"ejs_\"+Math.random(),\n\t_id=0,\n\tid = function(node){\n\t\tif(canExpando || node.nodeType !== 3) {\n\t\t\tif(node[expando]) {\n\t\t\t\treturn node[expando];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node[expando] = (node.nodeName ? \"element_\" : \"obj_\")+(++_id);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(var textNodeID in textNodeMap) {\n\t\t\t\tif(textNodeMap[textNodeID] === node) {\n\t\t\t\t\treturn textNodeID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttextNodeMap[\"text_\" + (++_id)] = node;\n\t\t\treturn \"text_\" + _id;\n\t\t}\n\t},\n\t\tsplice = [].splice;\n\n\t/**\n\t * @property {Object} can.view.nodeLists\n\t * @parent can.view.static\n\t * \n\t * Stores hierarchical node references.\n\t * \n\t * ## Use\n\t * \n\t * `can.view.nodeLists` is used to make sure \"directly nested\" live-binding\n\t * sections update content correctly.\n\t * \n\t * Consider a template like:\n\t * \n\t *     <div>\n\t *     {{#if items.length}}\n\t *        Items:\n\t *        {{#items}}\n\t *           <label></label>\n\t *        {{/items}}\n\t *     {{/if}}\n\t *     </div>\n\t * \n\t * \n\t * The `{{#if}}` and `{{#items}}` seconds are \"directly nested\" because\n\t * they share the same `<div>` parent element.\n\t * \n\t * If `{{#items}}` changes the DOM by adding more `<labels>`, \n\t * `{{#if}}` needs to know about the `<labels>` to remove them\n\t * if `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if \n\t * all items were removed.\n\t * \n\t * \n\t * To keep all live-bound sections knowing which elements they are managing,\n\t * all live-bound elments are [can.view.nodeLists.register registered] and\n\t * [can.view.nodeLists.update updated] when the change.\n\t * \n\t * For example, the above template, when rendered with data like:\n\t * \n\t *     data = new can.Map({\n\t *       items: [\"first\",\"second\"]\n\t *     })\n\t *     \n\t * This will first render the following content:\n\t * \n\t *     <div>\n\t *        <span data-view-id='5'/>\n\t *     </div>\n\t * \n\t * When the `5` [can.view.hookup hookup] callback is called, this will register the `<span>` like:\n\t * \n\t *     var ifsNodes = [<span 5>]\n\t *     nodeLists.register(ifsNodes);\n\t * \n\t * And then render `{{if}}`'s contents and update `ifsNodes` with it:\n\t * \n\t *     nodeLists.update( ifsNodes, [<\"\\nItems:\\n\">, <span data-view-id=\"6\">] );\n\t *      \n\t * Next, hookup `6` is called which will regsiter the `<span>` like:\n\t * \n\t *     var eachsNodes = [<span 6>];\n\t *     nodeLists.register(eachsNodes);\n\t * \n\t * And then it will render `{{#each}}`'s content and update `eachsNodes` with it:\n\t * \n\t *     nodeLists.update(eachsNodes, [<label>,<label>]);\n\t * \n\t * As `nodeLists` knows that `eachsNodes` is inside `ifsNodes`, it also updates\n\t * `ifsNodes`'s nodes to look like:\n\t * \n\t *     [<\"\\nItems:\\n\">,<label>,<label>]\n\t * \n\t * Now, if all items were removed, `{{#if}}` would be able to remove \n\t * all the `<label>` elements.\n\t * \n\t * When you regsiter a nodeList, you can also provide a callback to know when \n\t * that nodeList has been replaced by a parent nodeList.  This is\n\t * useful for tearing down live-binding.\n\t * \n\t * \n\t *  \n\t * \n\t * \n\t */\n\tvar nodeLists = {\n\t\tid: id,\n\n\t\t/**\n\t\t * @function can.view.nodeLists.update\n\t\t * @parent can.view.nodeLists\n\t\t * \n\t\t * Updates a nodeList with new items\n\t\t * \n\t\t * @param {Array.<HTMLElement>} nodeList A registered nodeList.\n\t\t * \n\t\t * @param {Array.<HTMLElement>} newNodes HTML nodes that should be placed in the nodeList.\n\t\t * \n\t\t */\n\t\tupdate: function(nodeList, newNodes){\n\t\t\t// Unregister all childNodes.\n\t\t\tcan.each(nodeList.childNodeLists, function(nodeList){\n\t\t\t\tnodeLists.unregister(nodeList)\n\t\t\t})\n\t\t\tnodeList.childNodeLists = [];\n\t\t\t\n\t\t\t// Remove old node pointers to this list.\n\t\t\tcan.each(nodeList, function(node){\n\t\t\t\tdelete nodeMap[id(node)];\n\t\t\t});\n\t\t\t\n\t\t\tvar newNodes = can.makeArray(newNodes);\n\t\t\t\n\t\t\t// indicate the new nodes belong to this list\n\t\t\tcan.each(newNodes, function(node){\n\t\t\t\tnodeMap[id(node)] = nodeList;\n\t\t\t});\n\n\t\t\t\n\t\t\tvar oldListLength = nodeList.length,\n\t\t\t\tfirstNode = nodeList[0];\n\t\t\t// Replace oldNodeLists's contents'\n\t\t\tsplice.apply( nodeList, [0, oldListLength ].concat(newNodes) );\n\t\t\t\n\t\t\t// update all parent nodes so they are able to replace the correct elements\n\t\t\tvar parentNodeList = nodeList;\n\t\t\twhile(parentNodeList = parentNodeList.parentNodeList) {\n\t\t\t\tsplice.apply(parentNodeList, [can.inArray(firstNode, parentNodeList), oldListLength ].concat(newNodes) );\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t},\n\t\t/**\n\t\t * @function can.view.nodeLists.register\n\t\t * @parent can.view.nodeLists\n\t\t * \n\t\t * Registers a nodeList.\n\t\t * \n\t\t * @param {Array.<HTMLElement>} nodeList An array of elements. This array will be kept live if child nodeLists\n\t\t * update themselves.\n\t\t * \n\t\t * @param {function} [unregistered] An optional callback that is called when the `nodeList` is \n\t\t * replaced due to a parentNode list being updated.\n\t\t * \n\t\t * @param {Array.<HTMLElement>} [parent] An optional parent nodeList.  If no parentNode list is found,\n\t\t * the first element in `nodeList`'s current nodeList will be used. \n\t\t * \n\t\t * @return {Array.<HTMLElement>} The `nodeList` passed to `register`.\n\t\t */\n\t\tregister: function(nodeList, unregistered, parent){\n\t\t\t\n\t\t\t// add an id to the nodeList\n\t\t\tnodeList.unregistered = unregistered, \n\t\t\t\n\t\t\tnodeList.childNodeLists = [];\n\t\t\t\n\t\t\tif(!parent) {\n\t\t\t\t// find the parent by looking up where this node is\n\t\t\t\tif(nodeList.length > 1) {\n\t\t\t\t\tthrow \"does not work\"\n\t\t\t\t}\n\t\t\t\tvar nodeId = id(nodeList[0]);\n\t\t\t\tparent =  nodeMap[nodeId];\n\t\t\t\t\n\t\t\t}\n\t\t\tnodeList.parentNodeList = parent;\n\t\t\tparent && parent.childNodeLists.push( nodeList );\n\t\t\treturn nodeList;\n\t\t},\n\t\t// removes node in all parent nodes and unregisters all childNodes\n\t\t/**\n\t\t * @function can.view.nodeLists.unregister\n\t\t * @parent can.view.nodeLists\n\t\t * \n\t\t * Unregister's a nodeList.  Call if the nodeList is no longer being \n\t\t * updated.  This will unregister all child nodeLists.\n\t\t * \n\t\t * \n\t\t * @param {Array.<HTMLElement>} nodeList The nodelist to unregister.\n\t\t */\n\t\tunregister: function(nodeList){\n\t\t\tif(!nodeList.isUnregistered) {\n\t\t\t\tnodeList.isUnregistered = true;\n\t\t\t\t// unregister all childNodeLists\n\t\t\t\tdelete nodeList.parentNodeList;\n\t\t\t\tcan.each(nodeList, function(node){\n\t\t\t\t\tvar nodeId = id(node);\n\t\t\t\t\tdelete nodeMap[nodeId]\n\t\t\t\t});\n\t\t\t\t// this can unbind which will call itself\n\t\t\t\tnodeList.unregistered && nodeList.unregistered();\n\t\t\t\tcan.each( nodeList.childNodeLists, function(nodeList){\n\t\t\t\t\tnodeLists.unregister(nodeList)\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tnodeMap: nodeMap,\n\t}\n\treturn nodeLists;\n\n\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/live',[\"can/util/library\", \"can/view/elements\", \"can/view\", \"can/view/node_lists\"], function(can, elements,view,nodeLists){\n\t// ## live.js\n\t// \n\t// The live module provides live binding for computes\n\t// and can.List.\n\t// \n\t// Currently, it's API is designed for `can/view/render`, but\n\t// it could easily be used for other purposes.\n\n\n\t// ### Helper methods\n\t// \n\t// #### setup\n\t// \n\t// `setup(HTMLElement, bind(data), unbind(data)) -> data`\n\t// \n\t// Calls bind right away, but will call unbind\n\t// if the element is \"destroyed\" (removed from the DOM).\n\tvar setupCount = 0;\n\tvar setup = function(el, bind, unbind){\n\t\t// Removing an element can call teardown which\n\t\t// unregister the nodeList which calls teardown\n\t\tvar tornDown = false,\n\t\t\tteardown = function(){\n\t\t\t\tif(!tornDown) {\n\t\t\t\t\ttornDown = true;\n\t\t\t\t\tunbind(data)\n\t\t\t\t\tcan.unbind.call(el,'removed', teardown);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tdata = {\n\t\t\t\t// returns true if no parent\n\t\t\t\tteardownCheck: function(parent){\n\t\t\t\t\treturn parent ? false : teardown();\n\t\t\t\t}\n\t\t\t}\n\n\t\tcan.bind.call(el,'removed', teardown);\n\t\tbind(data)\n\t\treturn data;\n\t},\n\t\t// #### listen\n\t\t// Calls setup, but presets bind and unbind to \n\t\t// operate on a compute\n\t\tlisten = function(el, compute, change){\n\t\t\treturn setup(el, function(){\n\t\t\t\tcompute.bind(\"change\", change);\n\t\t\t},function(data){\n\t\t\t\tcompute.unbind(\"change\", change);\n\t\t\t\tif(data.nodeList){\n\t\t\t\t\tnodeLists.unregister( data.nodeList );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t// #### getAttributeParts\n\t\t// Breaks up a string like foo='bar' into [\"foo\",\"'bar'\"\"]\n\t\tgetAttributeParts = function(newVal){\n\t\t\treturn (newVal|| \"\").replace(/['\"]/g, '').split('=')\n\t\t},\n\t\t\tsplice = [].splice;\n\n\t/**\n\t * @property {Object} can.view.live\n\t * @parent can.view.static\n\t * \n\t * Setup live-binding to a compute manually.\n\t * \n\t * @body\n\t * \n\t * ## Use\n\t * \n\t * `can.view.live` is an object with utlitiy methods for setting up \n\t * live-binding.  For example, to make an `<h2>`\n\t * \n\t *  \n\t * \n\t */\n\tvar live = {\n\t\t/**\n\t\t * @function can.view.live.list\n\t\t * @parent can.view.live\n\t\t * \n\t\t * Live binds a compute's [can.List] incrementally.  \n\t\t * \n\t\t *  \n\t\t * @param {HTMLElement} el An html element to replace with the live-section.\n\t\t * \n\t\t * @param {can.compute|can.List} list A [can.List] or [can.compute] whose value is a [can.List].\n\t\t * \n\t\t * @param {function(this:*,*,index):String} render(index, index) A function that when called with \n\t\t * the incremental item to render and the index of the item in the list. \n\t\t * \n\t\t * @param {Object} context The `this` the `render` function will be called with.\n\t\t * \n\t\t * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n\t\t * a documentFragment.\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `can.view.live.list` is used to setup incremental live-binding.\n\t\t * \n\t\t *     // a compute that change's it's list\n\t\t *     var todos = can.compute(function(){\n\t\t *       return new Todo.List({page: can.route.attr(\"page\")})\n\t\t *     })\n\t\t * \n\t\t *     var placeholder = document.createTextNode(\" \")\n\t\t *     $(\"ul#todos\").append(placeholder)\n\t\t * \n\t\t * \n\t\t * \n\t\t *     can.view.live.list(\n\t\t *       placeholder, \n\t\t *       todos, \n\t\t *       function(todo, index){\n\t\t *         return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n\t\t *       })\n\t\t * \n\t\t */\n\t\tlist: function(el, compute, render, context, parentNode){\n\t\t\t\n\t\t\t\n\t\t\t// A nodeList of all elements this live-list manages.\n\t\t\t// This is here so that if this live list is within another section\n\t\t\t// that section is able to remove the items in this list.\n\t\t\tvar masterNodeList = [el],\n\t\t\t\t// A mapping of the index of an item to an array\n\t\t\t\t// of elements that represent the item.\n\t\t\t\t// Each array is registered so child or parent\n\t\t\t\t// live structures can update the elements.\n\t\t\t\titemIndexToNodeListsMap = [],\n\t\t\t\t// A mapping of items to their indicies'\n\t\t\t\tindexMap = [],\n\t\t\t\t\n\t\t\t\t// Called when items are added to the list.\n\t\t\t\tadd = function(ev, items, index){\n\n\t\t\t\t\t// Collect new html and mappings\n\t\t\t\t\tvar frag = document.createDocumentFragment(),\n\t\t\t\t\t\tnewNodeLists = [],\n\t\t\t\t\t\tnewIndicies = [];\n\t\t\t\t\t\t\n\t\t\t\t\t// For each new item,\n\t\t\t\t\tcan.each(items, function(item, key){\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar itemIndex = can.compute(key + index),\n\t\t\t\t\t\t\t// get its string content\n\t\t\t\t\t\t\titemHTML = render.call(context, item, itemIndex),\n\t\t\t\t\t\t\t// and convert it into elements.\n\t\t\t\t\t\t\titemFrag = can.view.fragment(itemHTML)\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add those elements to the mappings.\n\t\t\t\t\t\tnewNodeLists.push( \n\t\t\t\t\t\t\t// Register those nodes with nodeLists.\n\t\t\t\t\t\t\tnodeLists.register( can.makeArray(itemFrag.childNodes), undefined, masterNodeList ) \n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Hookup the fragment (which sets up child live-bindings) and\n\t\t\t\t\t\t// add it to the collection of all added elements.\n\t\t\t\t\t\tfrag.appendChild( can.view.hookup(itemFrag)  );\n\t\t\t\t\t\tnewIndicies.push(itemIndex)\n\t\t\t\t\t})\n\n\t\t\t\t\t// Check if we are adding items at the end\n\t\t\t\t\tif( !itemIndexToNodeListsMap[index] ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\telements.after(\n\t\t\t\t\t\t\t// If we are adding items to an empty list\n\t\t\t\t\t\t\tindex == 0 ?\n\t\t\t\t\t\t\t\t// add those items after the placeholder text element.\n\t\t\t\t\t\t\t\t[text] :\n\t\t\t\t\t\t\t\t// otherwise, add them after the last element in the previous index.\n\t\t\t\t\t\t\t\titemIndexToNodeListsMap[index-1], frag)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add elements before the next index's first element.\n\t\t\t\t\t\tvar el = itemIndexToNodeListsMap[index][0];\n\t\t\t\t\t\tcan.insertBefore(el.parentNode, frag, el);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsplice.apply(itemIndexToNodeListsMap, [index, 0].concat(newNodeLists));\n\t\t\t\t\t\n\t\t\t\t\t// update indices after insert point\n\t\t\t\t\tsplice.apply(indexMap, [index, 0].concat(newIndicies));\n\t\t\t\t\tfor(var i = index+newIndicies.length, len = indexMap.length; i < len; i++){\n\t\t\t\t\t\tindexMap[i](i)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Called when items are removed or when the bindings are torn down.\n\t\t\t\tremove = function(ev, items, index, duringTeardown){\n\t\t\t\t\t\n\t\t\t\t\t// If this is because an element was removed, we should\n\t\t\t\t\t// check to make sure the live elements are still in the page.\n\t\t\t\t\t// If we did this during a teardown, it would cause an infinite loop.\n\t\t\t\t\tif(!duringTeardown && data.teardownCheck(text.parentNode)){\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar removedMappings = itemIndexToNodeListsMap.splice(index, items.length),\n\t\t\t\t\t\titemsToRemove = [];\n\n\t\t\t\t\tcan.each(removedMappings,function(nodeList){\n\t\t\t\t\t\t// add items that we will remove all at once\n\t\t\t\t\t\t[].push.apply(itemsToRemove, nodeList)\n\t\t\t\t\t\t// Update any parent lists to remove these items\n\t\t\t\t\t\tnodeLists.update(nodeList,[]);\n\t\t\t\t\t\t// unregister the list\n\t\t\t\t\t\tnodeLists.unregister(nodeList);\n\n\t\t\t\t\t});\n\t\t\t\t\t// update indices after remove point\n\t\t\t\t\tindexMap.splice(index, items.length)\n\t\t\t\t\tfor(var i = index, len = indexMap.length; i < len; i++){\n\t\t\t\t\t\tindexMap[i](i)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcan.remove( can.$(itemsToRemove) );\n\t\t\t\t},\n\t\t\t\tparentNode = elements.getParentNode(el, parentNode),\n\t\t\t\ttext = document.createTextNode(\"\"),\n\t\t\t\t// The current list.\n\t\t\t\tlist,\n\n\t\t\t\t// Called when the list is replaced with a new list or the binding is torn-down.\n\t\t\t\tteardownList = function(){\n\t\t\t\t\t// there might be no list right away, and the list might be a plain\n\t\t\t\t\t// array\n\t\t\t\t\tlist && list.unbind && list.unbind(\"add\", add).unbind(\"remove\", remove);\n\t\t\t\t\t// use remove to clean stuff up for us\n\t\t\t\t\tremove({},{length: itemIndexToNodeListsMap.length},0, true);\n\t\t\t\t},\n\t\t\t\t// Called when the list is replaced or setup.\n\t\t\t\tupdateList = function(ev, newList, oldList){\n\t\t\t\t\tteardownList();\n\t\t\t\t\t// make an empty list if the compute returns null or undefined\n\t\t\t\t\tlist = newList || [];\n\t\t\t\t\t// list might be a plain array\n\t\t\t\t\tlist.bind && list.bind(\"add\", add).bind(\"remove\", remove);\n\t\t\t\t\tadd({}, list, 0);\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Setup binding and teardown to add and remove events\n\t\t\tvar data = setup(parentNode, function(){\n\t\t\t\tcan.isFunction(compute) && compute.bind(\"change\",updateList)\n\t\t\t},function(){\n\t\t\t\tcan.isFunction(compute) && compute.unbind(\"change\",updateList)\n\t\t\t\tteardownList()\n\t\t\t});\n\t\t\t\n\t\t\tlive.replace(masterNodeList, text, data.teardownCheck)\n\t\t\t\n\t\t\t// run the list setup\n\t\t\tupdateList({},can.isFunction(compute) ? compute() : compute)\n\t\t\t\n\n\t\t},\n\t\t/**\n\t\t * @function can.view.live.html\n\t\t * @parent can.view.live\n\t\t * \n\t\t * Live binds a compute's value to a collection of elements.\n\t\t * \n\t\t *  \n\t\t * @param {HTMLElement} el An html element to replace with the live-section.\n\t\t * \n\t\t * @param {can.compute} compute A [can.compute] whose value is HTML.\n\t\t * \n\t\t * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n\t\t * a documentFragment.\n\t\t * \n\t\t * ## Use\n\t\t * \n\t\t * `can.view.live.html` is used to setup incremental live-binding.\n\t\t * \n\t\t *     // a compute that change's it's list\n\t\t *     var greeting = can.compute(function(){\n\t\t *       return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n\t\t *     });\n\t\t * \n\t\t *     var placeholder = document.createTextNode(\" \");\n\t\t *     $(\"#greeting\").append(placeholder);\n\t\t *     \n\t\t *     can.view.live.html( placeholder,  greeting );\n\t\t * \n\t\t */\n\t\thtml: function(el, compute, parentNode){\n\t\t\tvar parentNode = elements.getParentNode(el, parentNode),\n\t\t\t\tdata = listen(parentNode, compute, function(ev, newVal, oldVal){\n\t\t\t\t\t// TODO: remove teardownCheck in 2.1\n\t\t\t\t\tvar attached = nodes[0].parentNode;\n\t\t\t\t\t// update the nodes in the DOM with the new rendered value\n\t\t\t\t\tif( attached ) {\n\t\t\t\t\t\tmakeAndPut(newVal);\n\t\t\t\t\t}\n\t\t\t\t\tdata.teardownCheck(nodes[0].parentNode);\n\t\t\t\t});\n\t\t\t\n\t\t\tvar nodes = [el],\n\t\t\t\tmakeAndPut = function(val){\n\t\t\t\t\tvar frag = can.view.fragment( \"\"+val ),\n\t\t\t\t\t\toldNodes = can.makeArray(nodes);\n\t\t\t\t\t\n\t\t\t\t\t// We need to mark each node as belonging to the node list.\n\t\t\t\t\tnodeLists.update( nodes, frag.childNodes )\n\t\t\t\t\t\n\t\t\t\t\tfrag = can.view.hookup( frag, parentNode )\n\t\t\t\t\t\n\t\t\t\t\telements.replace(oldNodes, frag)\n\t\t\t\t};\n\t\t\t\n\t\t\tdata.nodeList = nodes;\n\t\t\t// register the span so nodeLists knows the parentNodeList\n\t\t\tnodeLists.register(nodes, data.teardownCheck)\n\t\t\tmakeAndPut(compute());\n\n\t\t},\n\t\t/**\n\t\t * @function can.view.live.replace\n\t\t * @parent can.view.live\n\t\t * \n\t\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t\t * correct.\n\t\t * \n\t\t * @param {Array.<HTMLElement>} nodes An array of elements.  There should typically be one element.\n\t\t * @param {String|HTMLElement|DocumentFragment} val The content that should replace \n\t\t * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n\t\t * \n\t\t * @param {function} [teardown] A callback if these elements are torn down.\n\t\t */\n\t\treplace: function(nodes, val, teardown){\n\t\t\tvar oldNodes = nodes.slice(0),\n\t\t\t\tfrag;\n\t\t\t\t\n\t\t\tnodeLists.register(nodes, teardown);\n\t\t\tif(typeof val === \"string\") {\n\t\t\t\tfrag = can.view.fragment( val )\n\t\t\t} else if(val.nodeType !== 11){\n\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\tfrag.appendChild(val)\n\t\t\t} else {\n\t\t\t\tfrag = val;\n\t\t\t}\n\t\n\t\t\t// We need to mark each node as belonging to the node list.\n\t\t\tnodeLists.update( nodes, frag.childNodes )\n\t\t\t\n\t\t\tif(typeof val === \"string\"){\n\t\t\t\t// if it was a string, check for hookups\n\t\t\t\tfrag = can.view.hookup( frag, nodes[0].parentNode );\n\t\t\t}\n\t\t\telements.replace(oldNodes, frag);\n\t\t\t\n\t\t\treturn nodes;\n\t\t},\n\t\t/**\n\t\t * @function can.view.live.text\n\t\t * @parent can.view.live\n\t\t * \n\t\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t\t * correct.\n\t\t */\n\t\ttext: function(el, compute, parentNode){\n\t\t\tvar parent = elements.getParentNode(el, parentNode);\n\n\t\t\t// setup listening right away so we don't have to re-calculate value\n\t\t\tvar data  = listen( parent, compute, function(ev, newVal, oldVal){\n\t\t\t\t// Sometimes this is 'unknown' in IE and will throw an exception if it is\n\t\t\t\tif ( typeof node.nodeValue != 'unknown' ) {\n\t\t\t\t\tnode.nodeValue = \"\"+newVal;\n\t\t\t\t}\n\t\t\t\t// TODO: remove in 2.1\n\t\t\t\tdata.teardownCheck(node.parentNode);\n\t\t\t}),\n\t\t\t\t// The text node that will be updated\n\t\t\t\tnode = document.createTextNode( compute() );\n\t\t\t\n\t\t\t// Replace the placeholder with the live node and do the nodeLists thing.\n\t\t\tlive.replace([el], node,  data.teardownCheck  );\n\t\t},\n\t\t/**\n\t\t * @function can.view.live.text\n\t\t * @parent can.view.live\n\t\t * \n\t\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t\t * correct.\n\t\t */\n\t\tattributes: function(el, compute, currentValue){\n\t\t\tvar setAttrs = function(newVal){\n\t\t\t\tvar parts = getAttributeParts(newVal),\n\t\t\t\t\tnewAttrName = parts.shift();\n\t\t\t\t\n\t\t\t\t// Remove if we have a change and used to have an `attrName`.\n\t\t\t\tif((newAttrName != attrName) && attrName){\n\t\t\t\t\telements.removeAttr(el,attrName);\n\t\t\t\t}\n\t\t\t\t// Set if we have a new `attrName`.\n\t\t\t\tif(newAttrName){\n\t\t\t\t\telements.setAttr(el, newAttrName, parts.join('='));\n\t\t\t\t\tattrName = newAttrName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlisten(el, compute, function(ev, newVal){\n\t\t\t\tsetAttrs(newVal)\n\t\t\t})\n\t\t\t// current value has been set\n\t\t\tif(arguments.length >= 3) {\n\t\t\t\tvar attrName = getAttributeParts(currentValue)[0]\n\t\t\t} else {\n\t\t\t\tsetAttrs(compute())\n\t\t\t}\n\t\t},\n\t\tattributePlaceholder: '__!!__',\n\t\tattributeReplace: /__!!__/g,\n\t\tattribute: function(el, attributeName, compute){\n\t\t\tlisten(el, compute, function(ev, newVal){\n\t\t\t\telements.setAttr( el, attributeName, hook.render() );\n\t\t\t})\n\n\t\t\tvar wrapped = can.$(el),\n\t\t\t\thooks;\n\t\t\t\n\t\t\t// Get the list of hookups or create one for this element.\n\t\t\t// Hooks is a map of attribute names to hookup `data`s.\n\t\t\t// Each hookup data has:\n\t\t\t// `render` - A `function` to render the value of the attribute.\n\t\t\t// `funcs` - A list of hookup `function`s on that attribute.\n\t\t\t// `batchNum` - The last event `batchNum`, used for performance.\n\t\t\thooks = can.data(wrapped,'hooks');\n\t\t\tif ( ! hooks ) {\n\t\t\t\tcan.data(wrapped, 'hooks', hooks = {});\n\t\t\t}\n\t\t\t\n\t\t\t// Get the attribute value.\n\t\t\tvar attr = elements.getAttr(el, attributeName ),\n\t\t\t\t// Split the attribute value by the template.\n\t\t\t\t// Only split out the first __!!__ so if we have multiple hookups in the same attribute, \n\t\t\t\t// they will be put in the right spot on first render\n\t\t\t\tparts = attr.split(live.attributePlaceholder),\n\t\t\t\tgoodParts = [],\n\t\t\t\thook;\n\t\t\t\tgoodParts.push(parts.shift(), \n\t\t\t\t\t\t\t   parts.join(live.attributePlaceholder));\n\n\t\t\t// If we already had a hookup for this attribute...\n\t\t\tif(hooks[attributeName]) {\n\t\t\t\t// Just add to that attribute's list of `function`s.\n\t\t\t\thooks[attributeName].computes.push(compute);\n\t\t\t} else {\n\t\t\t\t// Create the hookup data.\n\t\t\t\thooks[attributeName] = {\n\t\t\t\t\trender: function() {\n\t\t\t\t\t\tvar i =0,\n\t\t\t\t\t\t\t// attr doesn't have a value in IE\n\t\t\t\t\t\t\tnewAttr = attr\n\t\t\t\t\t\t\t\t? attr.replace(live.attributeReplace, function() {\n\t\t\t\t\t\t\t\t\t\treturn elements.contentText( hook.computes[i++]() );\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t: elements.contentText( hook.computes[i++]() );\n\t\t\t\t\t\treturn newAttr;\n\t\t\t\t\t},\n\t\t\t\t\tcomputes: [compute],\n\t\t\t\t\tbatchNum : undefined\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Save the hook for slightly faster performance.\n\t\t\thook = hooks[attributeName];\n\n\t\t\t// Insert the value in parts.\n\t\t\tgoodParts.splice(1,0,compute());\n\n\t\t\t// Set the attribute.\n\t\t\telements.setAttr(el, attributeName, goodParts.join(\"\") );\n\n\n\n\n\t\t},\n\t\tspecialAttribute: function(el, attributeName, compute){\n\t\t\t\n\t\t\tlisten(el, compute, function(ev, newVal){\n\t\t\t\telements.setAttr( el, attributeName, getValue( newVal ) );\n\t\t\t});\n\t\t\t\n\t\t\telements.setAttr(el, attributeName, getValue( compute() ) );\n\t\t}\n\t}\n\tvar newLine = /(\\r|\\n)+/g;\n\tvar getValue = function(val){\n\t\tval = val.replace(elements.attrReg,\"\").replace(newLine,\"\");\n\t\t// check if starts and ends with \" or '\n\t\treturn /^[\"'].*[\"']$/.test(val) ? val.substr(1, val.length-2) : val\n\t}\n\tcan.view.live = live;\n\tcan.view.nodeLists = nodeLists;\n\tcan.view.elements = elements;\n\treturn live;\n\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/render',[\"can/view\", \"can/view/elements\", \"can/view/live\", \"can/util/string\"], function(can, elements, live){\n\n/**\n * Helper(s)\n */\nvar pendingHookups = [],\n\ttagChildren = function(tagName) {\n\t\tvar newTag = elements.tagMap[tagName] || \"span\";\n\t\tif(newTag === \"span\") {\n\t\t\t//innerHTML in IE doesn't honor leading whitespace after empty elements\n\t\t\treturn \"@@!!@@\";\n\t\t}\t\n\t\treturn \"<\" + newTag + \">\" + tagChildren(newTag) + \"</\" + newTag + \">\";\n\t},\n\tcontentText = function( input, tag ) {\t\n\t\t\n\t\t// If it's a string, return.\n\t\tif ( typeof input == 'string' ) {\n\t\t\treturn input;\n\t\t}\n\t\t// If has no value, return an empty string.\n\t\tif ( !input && input !== 0 ) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// If it's an object, and it has a hookup method.\n\t\tvar hook = (input.hookup &&\n\n\t\t// Make a function call the hookup method.\n\t\tfunction( el, id ) {\n\t\t\tinput.hookup.call(input, el, id);\n\t\t}) ||\n\n\t\t// Or if it's a `function`, just use the input.\n\t\t(typeof input == 'function' && input);\n\n\t\t// Finally, if there is a `function` to hookup on some dom,\n\t\t// add it to pending hookups.\n\t\tif ( hook ) {\n\t\t\tif(tag){\n\t\t\t\treturn \"<\"+tag+\" \"+can.view.hook(hook)+\"></\"+tag+\">\"\n\t\t\t} else {\n\t\t\t\tpendingHookups.push(hook);\n\t\t\t}\n\t\t\t\n\t\t\treturn '';\n\t\t}\n\n\t\t// Finally, if all else is `false`, `toString()` it.\n\t\treturn \"\" + input;\n\t},\n\t// Returns escaped/sanatized content for anything other than a live-binding\n\tcontentEscape = function( txt , tag) {\n\t\treturn (typeof txt == 'string' || typeof txt == 'number') ?\n\t\t\tcan.esc( txt ) :\n\t\t\tcontentText(txt, tag);\n\t},\n\t// A flag to indicate if .txt was called within a live section within an element like the {{name}}\n\t// within `<div {{#person}}{{name}}{{/person}}/>`.\n\twithinTemplatedSectionWithinAnElement = false,\n\temptyHandler = function(){};\n\n\nvar current, lastHookups;\n\ncan.extend(can.view, {\n\tlive: live,\n\t// called in text to make a temporary \n\t// can.view.lists function that can be called with\n\t// the list to iterate over and the template\n\t// used to produce the content within the list\n\tsetupLists: function(){\n\n\t\tvar old = can.view.lists,\n\t\t\tdata;\n\n\t\tcan.view.lists = function(list, renderer){\n\t\t\tdata = {\n\t\t\t\tlist: list,\n\t\t\t\trenderer: renderer\n\t\t\t}\n\t\t\treturn Math.random()\n\t\t}\n\t\t// sets back to the old data\n\t\treturn function(){\n\t\t\tcan.view.lists = old;\n\t\t\treturn data;\n\t\t}\n\t},\n\tpending: function(data) {\n\t\t// TODO, make this only run for the right tagName\n\t\tvar hooks = can.view.getHooks();\n\t\treturn can.view.hook(function(el){\n\t\t\tcan.each(hooks, function(fn){\n\t\t\t\tfn(el);\n\t\t\t});\n\t\t\tcan.view.Scanner.hookupAttributes(data, el);\n\t\t});\n\t},\n\tgetHooks: function(){\n\t\tvar hooks = pendingHookups.slice(0);\n\t\tlastHookups = hooks;\n\t\tpendingHookups = [];\n\t\treturn hooks;\n\t},\n\tonlytxt: function(self, func){\n\t\treturn contentEscape(func.call(self))\n\t},\n\t/**\n\t * @function can.view.txt\n\t * @hide\n\t * \n\t * A helper function used to insert the \n\t * value of the contents of a magic tag into \n\t * a template's output. It detects if an observable value is\n\t * read and will setup live binding.\n\t * \n\t * @signature `can.view.txt(escape, tagName, status, self, func)`\n\t * \n\t * @param {Number} 1 if the content returned should be escaped, 0 if otherwise.\n\t * @param {String} tagName the name of the tag the magic tag is most immediately\n\t * within. Ex: `\"li\"`.\n\t * @param {String|Number} status A flag indicates which part of a tag the\n\t * magic tag is within. Status can be:\n\t * \n\t *  - _STRING_ - The name of the attribute the magic tag is within. Ex: `\"class\"`\n\t *  - `1` - The magic tag is within a tag like `<div <%= %>>`\n\t *  - `0` - The magic tag is outside (or between) tags like `<div><%= %></div>`\n\t * \n\t * @param {*} self The `this` of the current context template. `func` is called with\n\t * self as this.\n\t *   \n\t * @param {function} func The \"wrapping\" function. For \n\t * example:  `<%= task.attr('name') %>` becomes\n\t *   `(function(){return task.attr('name')})\n\t *\n\t */\n\ttxt: function(escape, tagName, status, self, func){\n\t\t// the temporary tag needed for any live setup\n\t\tvar tag = (elements.tagMap[tagName] || \"span\"),\n\t\t\t// should live-binding be setup\n\t\t\tsetupLiveBinding = false,\n\t\t\t// the compute's value\n\t\t\tvalue;\n\t\t\n\t\t\n\t\t// Are we currently within a live section within an element like the {{name}}\n\t\t// within `<div {{#person}}{{name}}{{/person}}/>`.\n\t\tif( withinTemplatedSectionWithinAnElement ) {\n\t\t\tvalue = func.call(self);\n\t\t} else {\n\t\t\t\n\t\t\t// If this magic tag is within an attribute or an html element,\n\t\t\t// set the flag to true so we avoid trying to live bind\n\t\t\t// anything that func might be setup.\n\t\t\t// TODO: the scanner should be able to set this up.\n\t\t\tif(typeof status === \"string\" || status === 1){\n\t\t\t\twithinTemplatedSectionWithinAnElement = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Sets up a listener so we know any can.view.lists called \n\t\t\t// when func is called\n\t\t\tvar listTeardown = can.view.setupLists(),\n\t\t\t\t// \n\t\t\t\tunbind = function(){\n\t\t\t\t\tcompute.unbind(\"change\",emptyHandler)\n\t\t\t\t};\n\t\t\t// Create a compute that calls func and looks for dependencies.\n\t\t\t// By passing `false`, this compute can not be a dependency of other \n\t\t\t// computes.  This is because live-bits are nested, but \n\t\t\t// handle their own updating. For example:\n\t\t\t//     {{#if items.length}}{{#items}}{{.}}{{/items}}{{/if}}\n\t\t\t// We do not want `{{#if items.length}}` changing the DOM if\n\t\t\t// `{{#items}}` text changes.\n\t\t\tvar compute = can.compute(func, self, false);\n\t\t\t\n\t\t\t// Bind to get and temporarily cache the value of the compute.\n\t\t\tcompute.bind(\"change\",emptyHandler);\n\t\t\t\n\t\t\t// Call the \"wrapping\" function and get the binding information\n\t\t\tvar\tlistData = listTeardown();\n\t\t\t\n\t\t\t// Get the value of the compute\n\t\t\tvalue = compute();\n\t\t\t\n\t\t\t// Let people know we are no longer within an element.\n\t\t\twithinTemplatedSectionWithinAnElement = false;\n\t\t\t\n\t\t\t// If we should setup live-binding.\n\t\t\tsetupLiveBinding = compute.hasDependencies;\n\t\t}\n\t\t\n\t\tif(listData){\n\t\t\tunbind && unbind();\n\t\t\treturn \"<\" +tag+can.view.hook(function(el, parentNode){\n\t\t\t\tlive.list(el, listData.list, listData.renderer, self, parentNode);\n\t\t\t})+\"></\" +tag+\">\";\n\t\t}\n\n\t\t// If we had no observes just return the value returned by func.\n\t\tif(!setupLiveBinding || typeof value === \"function\"){\n\t\t\tunbind && unbind();\n\t\t\treturn (  (escape || typeof status === 'string') && escape !== 2  ? contentEscape : contentText)(value, status === 0 && tag);\n\t\t}\n\n\n\t\t// the property (instead of innerHTML elements) to adjust. For\n\t\t// example options should use textContent\n\t\tvar contentProp = elements.tagToContentPropMap[tagName];\n\t\t\n\n\t\t// The magic tag is outside or between tags.\n\t\tif ( status === 0 && !contentProp ) {\n\t\t\t// Return an element tag with a hookup in place of the content\n\t\t\treturn \"<\" +tag+can.view.hook(\n\t\t\t// if value is an object, it's likely something returned by .safeString\n\t\t\tescape && typeof value != \"object\" ? \n\t\t\t\t// If we are escaping, replace the parentNode with \n\t\t\t\t// a text node who's value is `func`'s return value.\n\t\t\t\tfunction(el, parentNode){\n\t\t\t\t\tlive.text(el, compute, parentNode);\n\t\t\t\t\tunbind();\n\t\t\t\t} \n\t\t\t\t:\n\t\t\t\t// If we are not escaping, replace the parentNode with a\n\t\t\t\t// documentFragment created as with `func`'s return value.\n\t\t\t\tfunction( el, parentNode ) {\n\t\t\t\t\tlive.html(el, compute, parentNode);\n\t\t\t\t\tunbind();\n\t\t\t\t//children have to be properly nested HTML for buildFragment to work properly\n\t\t\t\t}) + \">\"+tagChildren(tag)+\"</\" +tag+\">\";\n\t\t// In a tag, but not in an attribute\n\t\t} else if( status === 1 ) { \n\t\t\t// remember the old attr name\n\t\t\tpendingHookups.push(function(el) {\n\t\t\t\tlive.attributes(el, compute, compute());\n\t\t\t\tunbind();\n\t\t\t});\n\t\t\t\n\t\t\treturn compute();\n\t\t} else if( escape === 2 ) { // In a special attribute like src or style\n\t\t\t\n\t\t\tvar attributeName = status;\n\t\t\tpendingHookups.push(function(el){\n\t\t\t\tlive.specialAttribute(el, attributeName, compute);\n\t\t\t\tunbind();\n\t\t\t})\n\t\t\treturn compute();\n\t\t} else { // In an attribute...\n\t\t\tvar attributeName = status === 0 ? contentProp : status;\n\t\t\t// if the magic tag is inside the element, like `<option><% TAG %></option>`,\n\t\t\t// we add this hookup to the last element (ex: `option`'s) hookups.\n\t\t\t// Otherwise, the magic tag is in an attribute, just add to the current element's\n\t\t\t// hookups.\n\t\t\t(status === 0  ? lastHookups : pendingHookups ).push(function(el){\n\t\t\t\tlive.attribute(el, attributeName, compute);\n\t\t\t\tunbind();\n\t\t\t});\n\t\t\treturn live.attributePlaceholder;\n\t\t}\n\t}\n});\n\nreturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/mustache',[\"can/util/library\", \"can/view/scope\", \"can/view\", \"can/view/scanner\", \"can/compute\", \"can/view/render\"], function( can ){\n\t\n\t// # mustache.js\n\t// `can.Mustache`: The Mustache templating engine.\n\t// \n\t// See the [Transformation](#section-29) section within *Scanning Helpers* for a detailed explanation \n\t// of the runtime render code design. The majority of the Mustache engine implementation \n\t// occurs within the *Transformation* scanning helper.\n\n\t// ## Initialization\n\t//\n\t// Define the view extension.\n\tcan.view.ext = \".mustache\";\n\n\t// ### Setup internal helper variables and functions.\n\t//\n\t// An alias for the context variable used for tracking a stack of contexts.\n\t// This is also used for passing to helper functions to maintain proper context.\n\tvar SCOPE = 'scope',\n\t\t// An alias for the variable used for the hash object that can be passed\n\t\t// to helpers via `options.hash`.\n\t\tHASH = '___h4sh',\n\t\t// An alias for the most used context stacking call.\n\t\tCONTEXT_OBJ = '{scope:' + SCOPE + ',options:options}',\n\t\t// argument names used to start the function (used by scanner and steal)\n\t\tARG_NAMES = SCOPE+\",options\",\n\t\t\n\t\t// matches arguments inside a {{ }}\n\t\targumentsRegExp = /((([^\\s]+?=)?('.*?'|\".*?\"))|.*?)\\s/g,\n\t\t\n\t\t// matches a literal number, string, null or regexp\n\t\tliteralNumberStringBooleanRegExp = /^(('.*?'|\".*?\"|[0-9]+\\.?[0-9]*|true|false|null|undefined)|((.+?)=(('.*?'|\".*?\"|[0-9]+\\.?[0-9]*|true|false)|(.+))))$/,\n\t\t\n\t\t// returns an object literal that we can use to look up a value in the current scope\n\t\tmakeLookupLiteral = function(type){\n\t\t\treturn '{get:\"'+type.replace(/\"/g,'\\\\\"')+'\"}'\n\t\t},\n\t\t// returns if the object is a lookup\n\t\tisLookup = function(obj){\n\t\t\treturn obj && typeof obj.get == \"string\"\n\t\t},\n\t\t\n\t\t/*\n\t\t * Checks whether an object is like a can.Map. This takes into\n\t\t * fact that can.route is can.Map like.\n\t\t * @param  {[can.Map]}  observable\n\t\t * @return {Boolean} returns if the object is observable like.\n\t\t */\n\t\tisObserveLike = function(obj) {\n\t\t\treturn obj instanceof can.Map || (obj && !!obj._get);\n\t\t},\n\t\t\n\t\t/*\n\t\t * Tries to determine if the object passed is an array.\n\t\t * @param  {Array}  obj The object to check.\n\t\t * @return {Boolean} returns if the object is an array.\n\t\t */\n\t\tisArrayLike = function(obj) {\n\t\t\treturn obj && obj.splice && typeof obj.length == 'number';\n\t\t},\n\t\t// used to make sure .fn and .inverse are always called with a Scope like object\n\t\tmakeConvertToScopes = function(orignal, scope, options){\n\t\t\treturn function(updatedScope, updatedOptions){\n\t\t\t\tif(updatedScope !== undefined && !(updatedScope instanceof  can.view.Scope)){\n\t\t\t\t\tupdatedScope = scope.add(updatedScope)\t\n\t\t\t\t}\n\t\t\t\tif(updatedOptions !== undefined && !(updatedOptions instanceof  OptionsScope)){\n\t\t\t\t\tupdatedOptions = options.add(updatedOptions)\n\t\t\t\t}\n\t\t\t\treturn orignal(updatedScope, updatedOptions || options)\n\t\t\t}\n\t\t};\n\t\t\n\t\t\n\t\t// ## Mustache\n\t\t/**\n\t\t * @hide\n\t\t * The Mustache templating engine.\n\t\t * @param {Object} options\tConfiguration options\n\t\t */\n\t\tMustache = function(options, helpers) {\n\t\t\t// Support calling Mustache without the constructor.\n\t\t\t// This returns a function that renders the template.\n\t\t\tif ( this.constructor != Mustache ) {\n\t\t\t\tvar mustache = new Mustache(options);\n\t\t\t\treturn function(data,options) {\n\t\t\t\t\t return mustache.render(data,options);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If we get a `function` directly, it probably is coming from\n\t\t\t// a `steal`-packaged view.\n\t\t\tif ( typeof options == \"function\" ) {\n\t\t\t\tthis.template = {\n\t\t\t\t\tfn: options\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set options on self.\n\t\t\tcan.extend(this, options);\n\t\t\tthis.template = this.scanner.scan(this.text, this.name);\n\t\t};\n\n\t/**\n\t * @add can.Mustache\n\t */\n\t// Put Mustache on the `can` object.\n\tcan.Mustache = window.Mustache = Mustache;\n\n\t/** \n\t * @prototype\n\t */\n\tMustache.prototype.\n\t/**\n\t * @function can.Mustache.prototype.render render\n\t * @parent can.Mustache.prototype\n\t * @signature `mustache.render( data [, helpers] )`\n\t * @param {Object} data Data to interpolate into the template.\n\t * @return {String} The template with interpolated data, in string form.\n\t * @hide\n\t * \n\t * @body\n\t * Renders an object with view helpers attached to the view.\n\t * \n\t *\t\t new Mustache({text: \"<%= message %>\"}).render({\n\t *\t\t\t message: \"foo\"\n\t *\t\t })\n\t */\n\trender = function( data, options ) {\n\t\tif(!(data instanceof can.view.Scope)){\n\t\t\tdata = new can.view.Scope(data || {});\n\t\t}\n\t\tif( ! (options instanceof OptionsScope) ){\n\t\t\toptions = new OptionsScope(options || {})\n\t\t}\n\t\toptions = options || {};\n\t\t\n\t\treturn this.template.fn.call(data, data, options);\n\t};\n\n\tcan.extend(Mustache.prototype, {\n\t\t// Share a singleton scanner for parsing templates.\n\t\tscanner: new can.view.Scanner({\n\t\t\t// A hash of strings for the scanner to inject at certain points.\n\t\t\ttext: {\n\t\t\t\t// This is the logic to inject at the beginning of a rendered template. \n\t\t\t\t// This includes initializing the `context` stack.\n\t\t\t\tstart: \"\",//\"var \"+SCOPE+\"= this instanceof can.view.Scope? this : new can.view.Scope(this);\\n\",\n\t\t\t\tscope: SCOPE,\n\t\t\t\toptions: \",options: options\",\n\t\t\t\targNames: ARG_NAMES\n\t\t\t},\n\t\t\t\n\t\t\t// An ordered token registry for the scanner.\n\t\t\t// This needs to be ordered by priority to prevent token parsing errors.\n\t\t\t// Each token follows the following structure:\n\t\t\t//\n\t\t\t//\t\t[\n\t\t\t//\t\t\t// Which key in the token map to match.\n\t\t\t//\t\t\t\"tokenMapName\",\n\t\t\t//\n\t\t\t//\t\t\t// A simple token to match, like \"{{\".\n\t\t\t//\t\t\t\"token\",\n\t\t\t//\n\t\t\t//\t\t\t// Optional. A complex (regexp) token to match that \n\t\t\t//\t\t\t// overrides the simple token.\n\t\t\t//\t\t\t\"[\\\\s\\\\t]*{{\",\n\t\t\t//\n\t\t\t//\t\t\t// Optional. A function that executes advanced \n\t\t\t//\t\t\t// manipulation of the matched content. This is \n\t\t\t//\t\t\t// rarely used.\n\t\t\t//\t\t\tfunction(content){   \n\t\t\t//\t\t\t\treturn content;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t]\n\t\t\ttokens: [\n\t\t\t\t/**\n\t\t\t\t * @function can.Mustache.tags.escaped {{key}}\n\t\t\t\t * \n\t\t\t\t * @description Insert the value of the [can.Mustache.key key] into the \n\t\t\t\t * output of the template.\n\t\t\t\t * \n\t\t\t\t * @parent can.Mustache.tags 0\n\t\t\t\t * \n\t\t\t\t * @signature `{{key}}`\n\t\t\t\t * \n\t\t\t\t * @param {can.Mustache.key} key A key that references one of the following:\n\t\t\t\t * \n\t\t\t\t *  - A [can.Mustache.registerHelper registered helper].\n\t\t\t\t *  - A value within the current or parent \n\t\t\t\t *    [can.Mustache.context context]. If the value is a function or [can.compute], the \n\t\t\t\t *    function's return value is used.\n\t\t\t\t * \n\t\t\t\t * @return {String|Function|*} \n\t\t\t\t * \n\t\t\t\t * After the key's value is found (and set to any function's return value), \n\t\t\t\t * it is passed to [can.view.txt] as the result of a call to its `func` \n\t\t\t\t * argument. There, if the value is a:\n\t\t\t\t * \n\t\t\t\t *  - `null` or `undefined` - an empty string is inserted into the rendered template result.\n\t\t\t\t *  - `String` or `Number` - the value is inserted into the rendered template result.\n\t\t\t\t *  - `Function` - A [can.view.hook hookup] attribute or element is inserted so this function\n\t\t\t\t *    will be called back with the DOM element after it is created.\n\t\t\t\t * \n\t\t\t\t * @body\n\t\t\t\t * \n\t\t\t\t * ## Use\n\t\t\t\t * \n\t\t\t\t * `{{key}}` insert data into the template. It most commonly references \n\t\t\t\t * values within the current [can.Mustache.context context]. For example:\n\t\t\t\t * \n\t\t\t\t * Rendering:\n\t\t\t\t * \n\t\t\t\t *     <h1>{{name}}</h1>\n\t\t\t\t * \n\t\t\t\t * With:\n\t\t\t\t * \n\t\t\t\t *     {name: \"Austin\"}\n\t\t\t\t * \n\t\t\t\t * Results in:\n\t\t\t\t * \n\t\t\t\t *     <h1>Austin</h1>\n\t\t\t\t * \n\t\t\t\t * If the key value is a String or Number, it is inserted into the template.  \n\t\t\t\t * If it is `null` or `undefined`, nothing is added to the template.\n\t\t\t\t * \n\t\t\t\t * \n\t\t\t\t * ## Nested Properties\n\t\t\t\t * \n\t\t\t\t * Mustache supports nested paths, making it possible to \n\t\t\t\t * look up properties nested deep inside the current context. For example:\n\t\t\t\t * \n\t\t\t\t * Rendering:\n\t\t\t\t * \n\t\t\t\t *     <h1>{{book.author}}</h1>\n\t\t\t\t * \n\t\t\t\t * With:\n\t\t\t\t * \n\t\t\t\t *     {\n\t\t\t\t *       book: {\n\t\t\t\t *         author: \"Ernest Hemingway\"\n\t\t\t\t *       }\n\t\t\t\t *     }\n\t\t\t\t * \n\t\t\t\t * Results in:\n\t\t\t\t * \n\t\t\t\t *     <h1>Ernest Hemingway</h1>\n\t\t\t\t * \n\t\t\t\t * ## Looking up values in parent contexts\n\t\t\t\t * \n\t\t\t\t * Sections and block helpers can create their own contexts. If a key's value\n\t\t\t\t * is not found in the current context, it will look up the key's value\n\t\t\t\t * in parent contexts. For example:\n\t\t\t\t * \n\t\t\t\t * Rendering:\n\t\t\t\t * \n\t\t\t\t *     {{#chapters}}\n\t\t\t\t *        <li>{{title}} - {{name}}</li>\n\t\t\t\t *     {{chapters}}\n\t\t\t\t * \n\t\t\t\t * With:\n\t\t\t\t * \n\t\t\t\t *     {\n\t\t\t\t *       title: \"The Book of Bitovi\"\t\n\t\t\t\t *       chapters: [{name: \"Breakdown\"}]\n\t\t\t\t *     }\n\t\t\t\t *   \n\t\t\t\t * Results in:\n\t\t\t\t * \n\t\t\t\t *     <li>The Book of Bitovi - Breakdown</li>\n\t\t\t\t * \n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t// Return unescaped\n\t\t\t\t[\"returnLeft\", \"{{{\", \"{{[{&]\"],\n\t\t\t\t// Full line comments\n\t\t\t\t[\"commentFull\", \"{{!}}\", \"^[\\\\s\\\\t]*{{!.+?}}\\\\n\"],\n\t\t\t\t/**\n\t\t\t\t * @function can.Mustache.tags.comment {{!key}}\n\t\t\t\t * \n\t\t\t\t * @parent can.Mustache.tags 7\n\t\t\t\t * \n\t\t\t\t * @description A comment that doesn't get inserted into the rendered result.\n\t\t\t\t * \n\t\t\t\t * @signature `{{!key}}`\n\t\t\t\t * \n\t\t\t\t * The comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n\t\t\t\t * \n\t\t\t\t * @param {can.Mustache.key} key Everything within this tag is completely ignored.\n\t\t\t\t * @return {String} \n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t// Inline comments\n\t\t\t\t[\"commentLeft\", \"{{!\", \"(\\\\n[\\\\s\\\\t]*{{!|{{!)\"],\n\t\t\t\t/**\n\t\t\t\t * @function can.Mustache.tags.unescaped {{{key}}}\n\t\t\t\t * \n\t\t\t\t * @parent can.Mustache.tags 1\n\t\t\t\t * \n\t\t\t\t * @description Insert the unescaped value of the [can.Mustache.key key] into the \n\t\t\t\t * output of the template.\n\t\t\t\t * \n\t\t\t\t * @signature `{{{key}}}`\n\t\t\t\t * \n\t\t\t\t * Behaves just like [can.Mustache.tags.escaped {{key}}] and [can.Mustache.helpers.helper {{helper}}] but does not\n\t\t\t\t * escape the result. \n\t\t\t\t * \n\t\t\t\t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t\t\t * context. If the value is a function or can.compute, the function's return value is used.\n\t\t\t\t * @return {String|Function|*} \n\t\t\t\t * \n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t//\n\t\t\t\t/**\n\t\t\t\t * @function can.Mustache.tags.unescaped2 {{&key}}\n\t\t\t\t * \n\t\t\t\t * @parent can.Mustache.tags 2\n\t\t\t\t * \n\t\t\t\t * @description Insert the unescaped value of the [can.Mustache.key key] into the \n\t\t\t\t * output of the template.\n\t\t\t\t * \n\t\t\t\t * @signature `{{&key}}`\n\t\t\t\t * \n\t\t\t\t * The `{{&key}}` tag is an alias for [can.Mustache.tags.unescaped {{{key}}}], behaving just \n\t\t\t\t * like [can.Mustache.tags.escaped {{key}}] and [can.Mustache.helpers.helper {{helper}}] but does not\n\t\t\t\t * escape the result. \n\t\t\t\t * \n\t\t\t\t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t\t\t * context. If the value is a function or can.compute, the function's return value is used.\n\t\t\t\t * @return {String|Function|*} \n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t// Full line escapes\n\t\t\t\t// This is used for detecting lines with only whitespace and an escaped tag\n\t\t\t\t[\"escapeFull\", \"{{}}\", \"(^[\\\\s\\\\t]*{{[#/^][^}]+?}}\\\\n|\\\\n[\\\\s\\\\t]*{{[#/^][^}]+?}}\\\\n|\\\\n[\\\\s\\\\t]*{{[#/^][^}]+?}}$)\", function(content) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tbefore: /^\\n.+?\\n$/.test(content) ? '\\n' : '',\n\t\t\t\t\t\tcontent: content.match(/\\{\\{(.+?)\\}\\}/)[1] || ''\n\t\t\t\t\t};\n\t\t\t\t}],\n\t\t\t\t// Return escaped\n\t\t\t\t[\"escapeLeft\", \"{{\"],\n\t\t\t\t// Close return unescaped\n\t\t\t\t[\"returnRight\", \"}}}\"],\n\t\t\t\t// Close tag\n\t\t\t\t[\"right\", \"}}\"]\n\t\t\t],\n\t\t\t\n\t\t\t// ## Scanning Helpers\n\t\t\t//\n\t\t\t// This is an array of helpers that transform content that is within escaped tags like `{{token}}`. These helpers are solely for the scanning phase; they are unrelated to Mustache/Handlebars helpers which execute at render time. Each helper has a definition like the following:\n\t\t\t//\n\t\t\t//\t\t{\n\t\t\t//\t\t\t// The content pattern to match in order to execute.\n\t\t\t//\t\t\t// Only the first matching helper is executed.\n\t\t\t//\t\t\tname: /pattern to match/,\n\t\t\t//\n\t\t\t//\t\t\t// The function to transform the content with.\n\t\t\t//\t\t\t// @param {String} content   The content to transform.\n\t\t\t//\t\t\t// @param {Object} cmd       Scanner helper data.\n\t\t\t//\t\t\t//                           {\n\t\t\t//\t\t\t//                             insert: \"insert command\",\n\t\t\t//\t\t\t//                             tagName: \"div\",\n\t\t\t//\t\t\t//                             status: 0\n\t\t\t//\t\t\t//                           }\n\t\t\t//\t\t\tfn: function(content, cmd) {\n\t\t\t//\t\t\t\treturn 'for text injection' || \n\t\t\t//\t\t\t\t\t{ raw: 'to bypass text injection' };\n\t\t\t//\t\t\t}\n\t\t\t//\t\t}\n\t\t\thelpers: [\n\t\t\t\t// ### Partials\n\t\t\t\t//\n\t\t\t\t// Partials begin with a greater than sign, like {{> box}}.\n\t\t\t\t// \n\t\t\t\t// Partials are rendered at runtime (as opposed to compile time), \n\t\t\t\t// so recursive partials are possible. Just avoid infinite loops.\n\t\t\t\t// \n\t\t\t\t// For example, this template and partial:\n\t\t\t\t// \n\t\t\t\t// \t\tbase.mustache:\n\t\t\t\t// \t\t\t<h2>Names</h2>\n\t\t\t\t// \t\t\t{{#names}}\n\t\t\t\t// \t\t\t\t{{> user}}\n\t\t\t\t// \t\t\t{{/names}}\n\t\t\t\t// \t\t\t\n\t\t\t\t// \t\tuser.mustache:\n\t\t\t\t// \t\t\t<strong>{{name}}</strong>\n\t\t\t\t{\n\t\t\t\t\tname: /^>[\\s]*\\w*/,\n\t\t\t\t\tfn:function(content, cmd){\n\t\t\t\t\t\t// Get the template name and call back into the render method,\n\t\t\t\t\t\t// passing the name and the current context.\n\t\t\t\t\t\tvar templateName = can.trim(content.replace(/^>\\s?/, '')).replace(/[\"|']/g, \"\");\n\t\t\t\t\t\treturn \"can.Mustache.renderPartial('\"+templateName+\"',\" + ARG_NAMES + \")\";\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// ### Data Hookup\n\t\t\t\t// \n\t\t\t\t// This will attach the data property of `this` to the element\n\t\t\t\t// its found on using the first argument as the data attribute\n\t\t\t\t// key.\n\t\t\t\t// \n\t\t\t\t// For example:\n\t\t\t\t// \t\n\t\t\t\t//\t\t<li id=\"nameli\" {{ data 'name' }}></li>\n\t\t\t\t// \n\t\t\t\t// then later you can access it like:\n\t\t\t\t// \n\t\t\t\t//\t\tcan.$('#nameli').data('name');\n\t\t\t\t/**\n\t\t\t\t * @function can.Mustache.helpers.data {{data name}}\n\t\t\t\t * @parent can.Mustache.htags 7\n\t\t\t\t * @signature `{{data name}}`\n\t\t\t\t * \n\t\t\t\t * Adds the current [can.Mustache.context context] to the\n\t\t\t\t * element's [can.data].\n\t\t\t\t * \n\t\t\t\t * @param {String} name The name of the data attribute to use for the\n\t\t\t\t * context.\n\t\t\t\t * \n\t\t\t\t * @body\n\t\t\t\t * \n\t\t\t\t * ## Use \n\t\t\t\t * \n\t\t\t\t * It is common for you to want some data in the template to be available\n\t\t\t\t * on an element.  `{{data name}}` allows you to save the \n\t\t\t\t * context so it can later be retrieved by [can.data] or \n\t\t\t\t * `$.fn.data`. For example,\n\t\t\t\t * \n\t\t\t\t * The template:\n\t\t\t\t * \n\t\t\t\t *     <ul>\n\t\t\t\t *       <li id=\"person\" {{data 'person'}}>{{name}}</li>\n\t\t\t\t *     </ul>\n\t\t\t\t * \n\t\t\t\t * Rendered with:\n\t\t\t\t * \n\t\t\t\t *     document.body.appendChild(\n\t\t\t\t *       can.view.mustache(template,{ person: { name: 'Austin' } });\n\t\t\t\t * \n\t\t\t\t * Retrieve the person data back with:\n\t\t\t\t * \n\t\t\t\t *     $(\"#person\").data(\"person\")\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tname: /^\\s*data\\s/,\n\t\t\t\t\tfn: function(content, cmd){\n\t\t\t\t\t\tvar attr = content.match(/[\"|'](.*)[\"|']/)[1];\n\t\t\t\t\t\t// return a function which calls `can.data` on the element\n\t\t\t\t\t\t// with the attribute name with the current context.\n\t\t\t\t\t\treturn \"can.proxy(function(__){\" +\n\t\t\t\t\t\t\t// \"var context = this[this.length-1];\" +\n\t\t\t\t\t\t\t// \"context = context.\" + STACKED + \" ? context[context.length-2] : context; console.warn(this, context);\" +\n\t\t\t\t\t\t\t\"can.data(can.$(__),'\" + attr + \"', this.attr('.')); }, \" + SCOPE + \")\";\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname:/\\s*\\(([\\$\\w]+)\\)\\s*->([^\\n]*)/,\n\t\t\t\t\tfn: function(content){\n\t\t\t\t\t\tvar quickFunc = /\\s*\\(([\\$\\w]+)\\)\\s*->([^\\n]*)/,\n\t\t\t\t\t\t\tparts = content.match(quickFunc);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//find \n\t\t\t\t\t\treturn \"can.proxy(function(__){var \" + parts[1] + \"=can.$(__);with(\"+SCOPE+\".attr('.')){\" + parts[2] + \"}}, this);\";\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// ### Transformation (default)\n\t\t\t\t//\n\t\t\t\t// This transforms all content to its interpolated equivalent,\n\t\t\t\t// including calls to the corresponding helpers as applicable. \n\t\t\t\t// This outputs the render code for almost all cases.\n\t\t\t\t//\n\t\t\t\t// #### Definitions\n\t\t\t\t// \n\t\t\t\t// * `context` - This is the object that the current rendering context operates within. \n\t\t\t\t//\t\tEach nested template adds a new `context` to the context stack.\n\t\t\t\t// * `stack` - Mustache supports nested sections, \n\t\t\t\t//\t\teach of which add their own context to a stack of contexts.\n\t\t\t\t//\t\tWhenever a token gets interpolated, it will check for a match against the \n\t\t\t\t//\t\tlast context in the stack, then iterate through the rest of the stack checking for matches.\n\t\t\t\t//\t\tThe first match is the one that gets returned.\n\t\t\t\t// * `Mustache.txt` - This serializes a collection of logic, optionally contained within a section.\n\t\t\t\t//\t\tIf this is a simple interpolation, only the interpolation lookup will be passed.\n\t\t\t\t//\t\tIf this is a section, then an `options` object populated by the truthy (`options.fn`) and \n\t\t\t\t//\t\tfalsey (`options.inverse`) encapsulated functions will also be passed. This section handling \n\t\t\t\t//\t\texists to support the runtime context nesting that Mustache supports.\n\t\t\t\t// * `Mustache.get` - This resolves an interpolation reference given a stack of contexts.\n\t\t\t\t// * `options` - An object containing methods for executing the inner contents of sections or helpers.  \n\t\t\t\t//\t\t`options.fn` - Contains the inner template logic for a truthy section.  \n\t\t\t\t//\t\t`options.inverse` - Contains the inner template logic for a falsey section.  \n\t\t\t\t//\t\t`options.hash` - Contains the merged hash object argument for custom helpers.\n\t\t\t\t//\n\t\t\t\t// #### Design\n\t\t\t\t//\n\t\t\t\t// This covers the design of the render code that the transformation helper generates.\n\t\t\t\t//\n\t\t\t\t// ##### Pseudocode\n\t\t\t\t// \n\t\t\t\t// A detailed explanation is provided in the following sections, but here is some brief pseudocode\n\t\t\t\t// that gives a high level overview of what the generated render code does (with a template similar to  \n\t\t\t\t// `\"{{#a}}{{b.c.d.e.name}}{{/a}}\" == \"Phil\"`).\n\t\t\t\t//\n\t\t\t\t// *Initialize the render code.*\n\t\t\t\t// \n\t\t\t\t// \t\tview = []\n\t\t\t\t// \t\tcontext = []\n\t\t\t\t// \t\tstack = fn { context.concat([this]) }\n\t\t\t\t// \t\t\n\t\t\t\t// *Render the root section.*\n\t\t\t\t//\n\t\t\t\t// \t\tview.push( \"string\" )\n\t\t\t\t// \t\tview.push( can.view.txt(\n\t\t\t\t//\n\t\t\t\t// *Render the nested section with `can.Mustache.txt`.*\n\t\t\t\t//\n\t\t\t\t// \t\t\ttxt( \n\t\t\t\t//\n\t\t\t\t// *Add the current context to the stack.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\tstack(), \n\t\t\t\t//\n\t\t\t\t// *Flag this for truthy section mode.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\"#\",\n\t\t\t\t//\n\t\t\t\t// *Interpolate and check the `a` variable for truthyness using the stack with `can.Mustache.get`.*\n\t\t\t\t// \n\t\t\t\t// \t\t\t\tget( \"a\", stack() ),\n\t\t\t\t//\n\t\t\t\t// *Include the nested section's inner logic.\n\t\t\t\t// The stack argument is usually the parent section's copy of the stack, \n\t\t\t\t// but it can be an override context that was passed by a custom helper.\n\t\t\t\t// Sections can nest `0..n` times -- **NESTCEPTION**.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t{ fn: fn(stack) {\n\t\t\t\t//\n\t\t\t\t// *Render the nested section (everything between the `{{#a}}` and `{{/a}}` tokens).*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\tview = []\n\t\t\t\t// \t\t\t\t\tview.push( \"string\" )\n\t\t\t\t// \t\t\t\t\tview.push(\n\t\t\t\t//\n\t\t\t\t// *Add the current context to the stack.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\t\tstack(),\n\t\t\t\t//\n\t\t\t\t// *Flag this as interpolation-only mode.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\t\tnull,\n\t\t\t\t//\n\t\t\t\t// *Interpolate the `b.c.d.e.name` variable using the stack.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\t\tget( \"b.c.d.e.name\", stack() ),\n\t\t\t\t// \t\t\t\t\t)\n\t\t\t\t// \t\t\t\t\tview.push( \"string\" )\n\t\t\t\t//\n\t\t\t\t// *Return the result for the nested section.*\n\t\t\t\t//\n\t\t\t\t// \t\t\t\t\treturn view.join()\n\t\t\t\t// \t\t\t\t}}\n\t\t\t\t// \t\t\t)\n\t\t\t\t// \t\t))\n\t\t\t\t// \t\tview.push( \"string\" )\n\t\t\t\t//\n\t\t\t\t// *Return the result for the root section, which includes all nested sections.*\n\t\t\t\t//\n\t\t\t\t// \t\treturn view.join()\n\t\t\t\t//\n\t\t\t\t// ##### Initialization\n\t\t\t\t//\n\t\t\t\t// Each rendered template is started with the following initialization code:\n\t\t\t\t//\n\t\t\t\t// \t\tvar ___v1ew = [];\n\t\t\t\t// \t\tvar ___c0nt3xt = [];\n\t\t\t\t// \t\t___c0nt3xt.__sc0pe = true;\n\t\t\t\t// \t\tvar __sc0pe = function(context, self) {\n\t\t\t\t// \t\t\tvar s;\n\t\t\t\t// \t\t\tif (arguments.length == 1 && context) {\n\t\t\t\t// \t\t\t\ts = !context.__sc0pe ? [context] : context;\n\t\t\t\t// \t\t\t} else {\n\t\t\t\t// \t\t\t\ts = context && context.__sc0pe \n\t\t\t\t//\t\t\t\t\t? context.concat([self]) \n\t\t\t\t//\t\t\t\t\t: __sc0pe(context).concat([self]);\n\t\t\t\t// \t\t\t}\n\t\t\t\t// \t\t\treturn (s.__sc0pe = true) && s;\n\t\t\t\t// \t\t};\n\t\t\t\t//\n\t\t\t\t// The `___v1ew` is the the array used to serialize the view.\n\t\t\t\t// The `___c0nt3xt` is a stacking array of contexts that slices and expands with each nested section.\n\t\t\t\t// The `__sc0pe` function is used to more easily update the context stack in certain situations.\n\t\t\t\t// Usually, the stack function simply adds a new context (`self`/`this`) to a context stack. \n\t\t\t\t// However, custom helpers will occasionally pass override contexts that need their own context stack.\n\t\t\t\t//\n\t\t\t\t// ##### Sections\n\t\t\t\t//\n\t\t\t\t// Each section, `{{#section}} content {{/section}}`, within a Mustache template generates a section \n\t\t\t\t// context in the resulting render code. The template itself is treated like a root section, with the \n\t\t\t\t// same execution logic as any others. Each section can have `0..n` nested sections within it.\n\t\t\t\t//\n\t\t\t\t// Here's an example of a template without any descendent sections.  \n\t\t\t\t// Given the template: `\"{{a.b.c.d.e.name}}\" == \"Phil\"`  \n\t\t\t\t// Would output the following render code:\n\t\t\t\t//\n\t\t\t\t//\t\t___v1ew.push(\"\\\"\");\n\t\t\t\t//\t\t___v1ew.push(can.view.txt(1, '', 0, this, function() {\n\t\t\t\t// \t\t\treturn can.Mustache.txt(__sc0pe(___c0nt3xt, this), null, \n\t\t\t\t//\t\t\t\tcan.Mustache.get(\"a.b.c.d.e.name\", \n\t\t\t\t//\t\t\t\t\t__sc0pe(___c0nt3xt, this))\n\t\t\t\t//\t\t\t);\n\t\t\t\t//\t\t}));\n\t\t\t\t//\t\t___v1ew.push(\"\\\" == \\\"Phil\\\"\");\n\t\t\t\t//\n\t\t\t\t// The simple strings will get appended to the view. Any interpolated references (like `{{a.b.c.d.e.name}}`) \n\t\t\t\t// will be pushed onto the view via `can.view.txt` in order to support live binding.\n\t\t\t\t// The function passed to `can.view.txt` will call `can.Mustache.txt`, which serializes the object data by doing \n\t\t\t\t// a context lookup with `can.Mustache.get`.\n\t\t\t\t//\n\t\t\t\t// `can.Mustache.txt`'s first argument is a copy of the context stack with the local context `this` added to it.\n\t\t\t\t// This stack will grow larger as sections nest.\n\t\t\t\t//\n\t\t\t\t// The second argument is for the section type. This will be `\"#\"` for truthy sections, `\"^\"` for falsey, \n\t\t\t\t// or `null` if it is an interpolation instead of a section.\n\t\t\t\t//\n\t\t\t\t// The third argument is the interpolated value retrieved with `can.Mustache.get`, which will perform the \n\t\t\t\t// context lookup and return the approriate string or object.\n\t\t\t\t//\n\t\t\t\t// Any additional arguments, if they exist, are used for passing arguments to custom helpers.\n\t\t\t\t//\n\t\t\t\t// For nested sections, the last argument is an `options` object that contains the nested section's logic.\n\t\t\t\t//\n\t\t\t\t// Here's an example of a template with a single nested section.  \n\t\t\t\t// Given the template: `\"{{#a}}{{b.c.d.e.name}}{{/a}}\" == \"Phil\"`  \n\t\t\t\t// Would output the following render code:\n\t\t\t\t//\n\t\t\t\t//\t\t___v1ew.push(\"\\\"\");\n\t\t\t\t// \t\t___v1ew.push(can.view.txt(0, '', 0, this, function() {\n\t\t\t\t// \t\t\treturn can.Mustache.txt(__sc0pe(___c0nt3xt, this), \"#\", \n\t\t\t\t//\t\t\t\tcan.Mustache.get(\"a\", __sc0pe(___c0nt3xt, this)), \n\t\t\t\t//\t\t\t\t\t[{\n\t\t\t\t// \t\t\t\t\t_: function() {\n\t\t\t\t// \t\t\t\t\t\treturn ___v1ew.join(\"\");\n\t\t\t\t// \t\t\t\t\t}\n\t\t\t\t// \t\t\t\t}, {\n\t\t\t\t// \t\t\t\t\tfn: function(___c0nt3xt) {\n\t\t\t\t// \t\t\t\t\t\tvar ___v1ew = [];\n\t\t\t\t// \t\t\t\t\t\t___v1ew.push(can.view.txt(1, '', 0, this, \n\t\t\t\t//\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t//  \t\t\t\t\t\t\t\treturn can.Mustache.txt(\n\t\t\t\t// \t\t\t\t\t\t\t\t\t__sc0pe(___c0nt3xt, this), \n\t\t\t\t// \t\t\t\t\t\t\t\t\tnull, \n\t\t\t\t// \t\t\t\t\t\t\t\t\tcan.Mustache.get(\"b.c.d.e.name\", \n\t\t\t\t// \t\t\t\t\t\t\t\t\t\t__sc0pe(___c0nt3xt, this))\n\t\t\t\t// \t\t\t\t\t\t\t\t);\n\t\t\t\t// \t\t\t\t\t\t\t}\n\t\t\t\t// \t\t\t\t\t\t));\n\t\t\t\t// \t\t\t\t\t\treturn ___v1ew.join(\"\");\n\t\t\t\t// \t\t\t\t\t}\n\t\t\t\t// \t\t\t\t}]\n\t\t\t\t//\t\t\t)\n\t\t\t\t// \t\t}));\n\t\t\t\t//\t\t___v1ew.push(\"\\\" == \\\"Phil\\\"\");\n\t\t\t\t//\n\t\t\t\t// This is specified as a truthy section via the `\"#\"` argument. The last argument includes an array of helper methods used with `options`.\n\t\t\t\t// These act similarly to custom helpers: `options.fn` will be called for truthy sections, `options.inverse` will be called for falsey sections.\n\t\t\t\t// The `options._` function only exists as a dummy function to make generating the section nesting easier (a section may have a `fn`, `inverse`,\n\t\t\t\t// or both, but there isn't any way to determine that at compilation time).\n\t\t\t\t// \n\t\t\t\t// Within the `fn` function is the section's render context, which in this case will render anything between the `{{#a}}` and `{{/a}}` tokens.\n\t\t\t\t// This function has `___c0nt3xt` as an argument because custom helpers can pass their own override contexts. For any case where custom helpers\n\t\t\t\t// aren't used, `___c0nt3xt` will be equivalent to the `__sc0pe(___c0nt3xt, this)` stack created by its parent section. The `inverse` function\n\t\t\t\t// works similarly, except that it is added when `{{^a}}` and `{{else}}` are used. `var ___v1ew = []` is specified in `fn` and `inverse` to \n\t\t\t\t// ensure that live binding in nested sections works properly.\n\t\t\t\t//\n\t\t\t\t// All of these nested sections will combine to return a compiled string that functions similar to EJS in its uses of `can.view.txt`.\n\t\t\t\t//\n\t\t\t\t// #### Implementation\n\t\t\t\t{\n\t\t\t\t\tname: /^.*$/,\n\t\t\t\t\tfn: function(content, cmd) {\n\t\t\t\t\t\tvar mode = false,\n\t\t\t\t\t\t\tresult = [];\n\n\t\t\t\t\t\t// Trim the content so we don't have any trailing whitespace.\n\t\t\t\t\t\tcontent = can.trim(content);\n\n\t\t\t\t\t\t// Determine what the active mode is.\n\t\t\t\t\t\t// \n\t\t\t\t\t\t// * `#` - Truthy section\n\t\t\t\t\t\t// * `^` - Falsey section\n\t\t\t\t\t\t// * `/` - Close the prior section\n\t\t\t\t\t\t// * `else` - Inverted section (only exists within a truthy/falsey section)\n\t\t\t\t\t\tif (content.length && (mode = content.match(/^([#^/]|else$)/))) {\n\t\t\t\t\t\t\tmode = mode[0];\n\t\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @function can.Mustache.helpers.section {{#key}}\n\t\t\t\t\t\t\t\t * @parent can.Mustache.tags 3\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{#key}}BLOCK{{/key}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Render blocks of text one or more times, depending \n\t\t\t\t\t\t\t\t * on the value of the key in the current context.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t\t\t\t\t\t\t * [can.Mustache.context context]. If the value is a function or [can.compute], the \n\t\t\t\t\t\t\t\t * function's return value is used.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @return {String} \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Depending on the value's type, the following actions happen:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * - `Array` or [can.List] - the block is rendered for \n\t\t\t\t\t\t\t\t *   each item in the array. The [can.Mustache.context context] is set to \n\t\t\t\t\t\t\t\t *   the item within each block rendering.\n\t\t\t\t\t\t\t\t * - A `truthy` value - the block is rendered with the [can.Mustache.context context]\n\t\t\t\t\t\t\t\t *   set to the value.\n\t\t\t\t\t\t\t\t * - A `falsey` value - the block is not rendered.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The rendered result of the blocks, block or an empty string is returned.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @body\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Sections contain text blocks and evaluate whether to render it or not.  If\n\t\t\t\t\t\t\t\t * the object evaluates to an array it will iterate over it and render the block\n\t\t\t\t\t\t\t\t * for each item in the array.  There are four different types of sections.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Falseys or Empty Arrays\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\n\t\t\t\t\t\t\t\t * that a *falsey* value.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If the value is falsey, the section will **NOT** render the block.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \t{ \n\t\t\t\t\t\t\t\t * \t\tfriends: false\n\t\t\t\t\t\t\t\t * \t}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \t{{#friends}}\n\t\t\t\t\t\t\t\t * \t\tNever shown!\n\t\t\t\t\t\t\t\t * \t{{/friends}}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Arrays\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If the value is a non-empty array, sections will iterate over the \n\t\t\t\t\t\t\t\t * array of items, rendering the items in the block.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * For example, a list of friends will iterate\n\t\t\t\t\t\t\t\t * over each of those items within a section.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     { \n\t\t\t\t\t\t\t\t *         friends: [ \n\t\t\t\t\t\t\t\t *             { name: \"Austin\" }, \n\t\t\t\t\t\t\t\t *             { name: \"Justin\" } \n\t\t\t\t\t\t\t\t *         ] \n\t\t\t\t\t\t\t\t *     }\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <ul>\n\t\t\t\t\t\t\t\t *         {{#friends}}\n\t\t\t\t\t\t\t\t *             <li>{{name}}</li>\n\t\t\t\t\t\t\t\t *         {{/friends}}\n\t\t\t\t\t\t\t\t *     </ul>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * would render:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <ul>\n\t\t\t\t\t\t\t\t *         <li>Austin</li>\n\t\t\t\t\t\t\t\t *         <li>Justin</li>\n\t\t\t\t\t\t\t\t *     </ul>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Reminder: Sections will reset the current context to the value for which it is iterating.\n\t\t\t\t\t\t\t\t * See the [basics of contexts](#Basics) for more information.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Truthys\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * When the value is a non-falsey object but not a list, it is considered truthy and will be used \n\t\t\t\t\t\t\t\t * as the context for a single rendering of the block.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {\n\t\t\t\t\t\t\t\t *         friends: { name: \"Jon\" }\n\t\t\t\t\t\t\t\t *     }\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {{#friends}}\n\t\t\t\t\t\t\t\t *         Hi {{name}}\n\t\t\t\t\t\t\t\t *     {{/friends}}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * would render:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     Hi Jon!\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @function can.Mustache.helpers.helper {{helper args hashes}}\n\t\t\t\t\t\t\t\t * @parent can.Mustache.htags 0\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @description Calls a mustache helper function and inserts its return value into\n\t\t\t\t\t\t\t\t * the rendered template.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{helper [args...] [hashProperty=hashValue...]}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Calls a mustache helper function or a function. For example:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>{{madLib \"Lebron James\" verb 4 foo=\"bar\"}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {verb: \"swept\"}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Will call a `madLib` helper with the following arguements:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('madLib', \n\t\t\t\t\t\t\t\t *       function(subject, verb, number, options){\n\t\t\t\t\t\t\t\t *         // subject -> \"Lebron James\"\n\t\t\t\t\t\t\t\t *         // verb -> \"swept\"\n\t\t\t\t\t\t\t\t *         // number -> 4\n\t\t\t\t\t\t\t\t *         // options.hash.foo -> \"bar\"\n\t\t\t\t\t\t\t\t *     });\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]\n\t\t\t\t\t\t\t\t * that is either [can.Mustache.registerHelper registered] or found within the\n\t\t\t\t\t\t\t\t * current or parent [can.Mustache.context context].\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments\n\t\t\t\t\t\t\t\t * that get passed to the helper function as arguments. If the key's value is a:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *  - [can.Map] - A getter/setter [can.compute] is passed.\n\t\t\t\t\t\t\t\t *  - [can.compute] - The can.compute is passed.\n\t\t\t\t\t\t\t\t *  - `function` - The function's return value is passed.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {String} hashProperty\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * A property name that gets added to a [can.Mustache.helperOptions helper options]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} hashValue A value that gets \n\t\t\t\t\t\t\t\t * set as a property value of the [can.Mustache.helperOptions helper option argument]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @body\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Use\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The `{{helper}}` syntax is used to call out to Mustache [can.Mustache.helper helper functions] functions \n\t\t\t\t\t\t\t\t * that may contain more complex functionality. `helper` is a [can.Mustache.key key] that must match either:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *  - a [can.Mustache.registerHelper registered helper function], or\n\t\t\t\t\t\t\t\t *  - a function in the current or parent [can.Mustache.context contexts]\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The following example shows both cases.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The Template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>{{greeting}} {{user}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with data:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {\n\t\t\t\t\t\t\t\t *       user: function(){ return \"Justin\" }\n\t\t\t\t\t\t\t\t *     }\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * And a with a registered helper like:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('greeting', function(){\n\t\t\t\t\t\t\t\t *       return \"Hello\"\n\t\t\t\t\t\t\t\t *     });\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Results in:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>Hello Justin</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Arguments\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Arguments can be passed from the template to helper function by\n\t\t\t\t\t\t\t\t * listing space seperated strings, numbers or other [can.Mustache.key keys] after the\n\t\t\t\t\t\t\t\t * `helper` name.  For example:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>{{madLib \"Lebron James\" verb 4}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {verb: \"swept\"}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Will call a `madLib` helper with the following arguements:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('madLib', \n\t\t\t\t\t\t\t\t *       function(subject, verb, number, options){\n\t\t\t\t\t\t\t\t *         // subject -> \"Lebron James\"\n\t\t\t\t\t\t\t\t *         // verb -> \"swept\"\n\t\t\t\t\t\t\t\t *         // number -> 4\n\t\t\t\t\t\t\t\t *     });\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If an argument `key` value is a [can.Map] property, the Observe's \n\t\t\t\t\t\t\t\t * property is converted to a getter/setter [can.compute]. For example:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>What! My name is: {{mr user.name}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {user: new can.Map({name: \"Slim Shady\"})}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Needs the helper to check if name is a function or not:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('mr',function(name){\n\t\t\t\t\t\t\t\t *       return \"Mr. \"+ (typeof name === \"function\" ?\n\t\t\t\t\t\t\t\t *                       name():\n\t\t\t\t\t\t\t\t *                       name)\n\t\t\t\t\t\t\t\t *     })\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * This behavior enables two way binding helpers and is explained in more detail \n\t\t\t\t\t\t\t\t * on the [can.Mustache.helper helper functions] docs.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Hash\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If enumerated arguments isn't an appropriate way to configure the behavior\n\t\t\t\t\t\t\t\t * of a helper, it's possible to pass a hash of key-value pairs to the\n\t\t\t\t\t\t\t\t * [can.Mustache.helperOptions helper option argument]'s \n\t\t\t\t\t\t\t\t * hash object.  Properties and values are specified \n\t\t\t\t\t\t\t\t * as `hashProperty=hashValue`.  For example:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>My {{excuse who=pet how=\"shreded\"}}</p>\n\t\t\t\t\t\t\t\t * `\n\t\t\t\t\t\t\t\t * And the helper:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper(\"excuse\",function(options){\n\t\t\t\t\t\t\t\t *       return [\"My\",\n\t\t\t\t\t\t\t\t *         options.hash.who || \"dog\".\n\t\t\t\t\t\t\t\t *         options.hash.how || \"ate\",\n\t\t\t\t\t\t\t\t *         \"my\",\n\t\t\t\t\t\t\t\t *         options.hash.what || \"homework\"].join(\" \")\n\t\t\t\t\t\t\t\t *     })\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Render with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {pet: \"cat\"}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Results in:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>My cat shareded my homework</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Returning an element callback function\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * If a helper returns a function, that function is called back after\n\t\t\t\t\t\t\t\t * the template has been rendered into DOM elements. This can \n\t\t\t\t\t\t\t\t * be used to create mustache tags that have rich behavior. Read about it\n\t\t\t\t\t\t\t\t * on the [can.Mustache.helper helper function] page.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @function can.Mustache.helpers.sectionHelper {{#helper args hashes}}\n\t\t\t\t\t\t\t\t * @parent can.Mustache.htags 1\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Calls a mustache helper function with a block, and optional inverse \n\t\t\t\t\t\t\t\t * block.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Calls a mustache helper function or a function with a block to \n\t\t\t\t\t\t\t\t * render.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>{{countTo number}}{{num}}{{/countTo}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {number: 5}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Will call the `countTo` helper:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('madLib', \n\t\t\t\t\t\t\t\t *       function(number, options){\n\t\t\t\t\t\t\t\t * \t       var out = []\n\t\t\t\t\t\t\t\t *         for(var i =0; i < number; i++){\n\t\t\t\t\t\t\t\t *           out.push( options.fn({num: i+1}) )\n\t\t\t\t\t\t\t\t *         }\n\t\t\t\t\t\t\t\t *         return out.join(\" \")\n\t\t\t\t\t\t\t\t *     });\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Results in:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>1 2 3 4 5</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]\n\t\t\t\t\t\t\t\t * that is either [can.Mustache.registerHelper registered] or found within the\n\t\t\t\t\t\t\t\t * current or parent [can.Mustache.context context].\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments\n\t\t\t\t\t\t\t\t * that get passed to the helper function as arguments. If the key's value is a:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *  - [can.Map] - A getter/setter [can.compute] is passed.\n\t\t\t\t\t\t\t\t *  - [can.compute] - The can.compute is passed.\n\t\t\t\t\t\t\t\t *  - `function` - The function's return value is passed.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {String} hashProperty\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * A property name that gets added to a [can.Mustache.helperOptions helper options]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} hashValue A value that gets \n\t\t\t\t\t\t\t\t * set as a property value of the [can.Mustache.helperOptions helper option argument]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {mustache} BLOCK A mustache template that gets compiled and\n\t\t\t\t\t\t\t\t * passed to the helper function as the [can.Mustache.helperOptions options argument's] `fn`\n\t\t\t\t\t\t\t\t * property.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Calls a mustache helper function or a function with a `fn` and `inverse` block to\n\t\t\t\t\t\t\t\t * render.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>The bed is \n\t\t\t\t\t\t\t\t *        {{isJustRight firmness}}\n\t\t\t\t\t\t\t\t *           pefect!\n\t\t\t\t\t\t\t\t *        {{else}}\n\t\t\t\t\t\t\t\t *           uncomfortable.\n\t\t\t\t\t\t\t\t *        {{/justRight}}</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Rendered with:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {firmness: 45}\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Will call the `isJustRight` helper:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     can.Mustache.registerHelper('isJustRight', \n\t\t\t\t\t\t\t\t *       function(number, options){\n\t\t\t\t\t\t\t\t * \t       if(number > 50){\n\t\t\t\t\t\t\t\t *           return options.fn(this)  \n\t\t\t\t\t\t\t\t *         } else {\n\t\t\t\t\t\t\t\t *           return options.inverse(this)  \n\t\t\t\t\t\t\t\t *         }\n\t\t\t\t\t\t\t\t *         return out.join(\" \")\n\t\t\t\t\t\t\t\t *     });\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Results in:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <p>The bed is uncomfortable.</p>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} helper A key that finds a [can.Mustache.helper helper function]\n\t\t\t\t\t\t\t\t * that is either [can.Mustache.registerHelper registered] or found within the\n\t\t\t\t\t\t\t\t * current or parent [can.Mustache.context context].\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} [args] Space seperated arguments\n\t\t\t\t\t\t\t\t * that get passed to the helper function as arguments. If the key's value is a:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *  - [can.Map] - A getter/setter [can.compute] is passed.\n\t\t\t\t\t\t\t\t *  - [can.compute] - The can.compute is passed.\n\t\t\t\t\t\t\t\t *  - `function` - The function's return value is passed.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {String} hashProperty\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * A property name that gets added to a [can.Mustache.helperOptions helper options]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {...can.Mustache.key|String|Number} hashValue A value that gets \n\t\t\t\t\t\t\t\t * set as a property value of the [can.Mustache.helperOptions helper option argument]'s \n\t\t\t\t\t\t\t\t * hash object.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {mustache} BLOCK A mustache template that gets compiled and\n\t\t\t\t\t\t\t\t * passed to the helper function as the [can.Mustache.helperOptions options argument's] `fn`\n\t\t\t\t\t\t\t\t * property.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {mustache} INVERSE A mustache template that gets compiled and\n\t\t\t\t\t\t\t\t * passed to the helper function as the [can.Mustache.helperOptions options argument's] `inverse`\n\t\t\t\t\t\t\t\t * property.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @body\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Use\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Read the [use section of {{helper}}](can.Mustache.helpers.helper.html#section_Use) to better understand how:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *  - [Helper functions are found](can.Mustache.helpers.helper.html#section_Arguments)\n\t\t\t\t\t\t\t\t *  - [Arguments are passed to the helper](can.Mustache.helpers.helper.html#section_Arguments)\n\t\t\t\t\t\t\t\t *  - [Hash values are passed to the helper](can.Mustache.helpers.helper.html#section_Hash)\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Read how [helpers that return functions](can.Mustache.helper.html#section_Returninganelementcallbackfunction) can\n\t\t\t\t\t\t\t\t * be used for rich behavior like 2-way binding.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t// Open a new section.\n\t\t\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @function can.Mustache.helpers.inverse {{^key}}\n\t\t\t\t\t\t\t\t * @parent can.Mustache.tags 5\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{^key}}BLOCK{{/key}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Render blocks of text if the value of the key\n\t\t\t\t\t\t\t\t * is falsey.  An inverted section syntax is similar to regular \n\t\t\t\t\t\t\t\t * sections except it begins with a caret rather than a \n\t\t\t\t\t\t\t\t * pound. If the value referenced is falsey, the section will render.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t\t\t\t\t\t\t * [can.Mustache.context context]. If the value is a function or [can.compute], the \n\t\t\t\t\t\t\t\t * function's return value is used.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @return {String} \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Depending on the value's type, the following actions happen:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * - A `truthy` value - the block is not rendered.\n\t\t\t\t\t\t\t\t * - A `falsey` value - the block is rendered.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The rendered result of the block or an empty string is returned.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @body\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * ## Use\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Inverted sections match falsey values. An inverted section \n\t\t\t\t\t\t\t\t * syntax is similar to regular sections except it begins with a caret \n\t\t\t\t\t\t\t\t * rather than a pound. If the value referenced is falsey, the section \n\t\t\t\t\t\t\t\t * will render. For example:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * The template:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <ul>\n\t\t\t\t\t\t\t\t *         {{#friends}}\n\t\t\t\t\t\t\t\t *             </li>{{name}}</li>\n\t\t\t\t\t\t\t\t *         {{/friends}}\n\t\t\t\t\t\t\t\t *         {{^friends}}\n\t\t\t\t\t\t\t\t *             <li>No friends.</li>\n\t\t\t\t\t\t\t\t *         {{/friends}}\n\t\t\t\t\t\t\t\t *     </ul>\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * And data:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     {\n\t\t\t\t\t\t\t\t *         friends: []\n\t\t\t\t\t\t\t\t *     }\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Results in:\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t *     <ul>\n\t\t\t\t\t\t\t\t *         <li>No friends.</li>\n\t\t\t\t\t\t\t\t *     </ul>\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\t\t\tif(cmd.specialAttribute) {\n\t\t\t\t\t\t\t\t\t\tresult.push(cmd.insert + 'can.view.onlytxt(this,function(){ return ');\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tresult.push(cmd.insert + 'can.view.txt(0,\\'' + cmd.tagName + '\\',' + cmd.status + ',this,function(){ return ');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t// Close the prior section.\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @function can.Mustache.helpers.close {{/key}}\n\t\t\t\t\t\t\t\t * @parent can.Mustache.tags 4\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @signature `{{/key}}`\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * Ends a [can.Mustache.helpers.section {{#key}}] or [can.Mustache.helpers.sectionHelper {{#helper}}]\n\t\t\t\t\t\t\t\t * block.\n\t\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t\t * @param {can.Mustache.key} [key] A key that matches the opening key or helper name. It's also\n\t\t\t\t\t\t\t\t * possible to simply write `{{/}}` to end a block.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\treturn { raw: 'return ___v1ew.join(\"\");}}])}));' };\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Trim the mode off of the content.\n\t\t\t\t\t\t\tcontent = content.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// `else` helpers are special and should be skipped since they don't \n\t\t\t\t\t\t// have any logic aside from kicking off an `inverse` function.\n\t\t\t\t\t\tif (mode != 'else') {\n\t\t\t\t\t\t\tvar args = [],\n\t\t\t\t\t\t\t\ti = 0,\n\t\t\t\t\t\t\t\thashing = false,\n\t\t\t\t\t\t\t\targ, split, m;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Start the content render block.\n\t\t\t\t\t\t\tresult.push('can.Mustache.txt(\\n'+CONTEXT_OBJ+',\\n' + (mode ? '\"'+mode+'\"' : 'null') + ',');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Parse the helper arguments.\n\t\t\t\t\t\t\t// This needs uses this method instead of a split(/\\s/) so that \n\t\t\t\t\t\t\t// strings with spaces can be correctly parsed.\n\t\t\t\t\t\t\tvar args = [],\n\t\t\t\t\t\t\t\thashes = [];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(can.trim(content)+' ').replace(argumentsRegExp, function(whole, arg) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Check for special helper arguments (string/number/boolean/hashes).\n\t\t\t\t\t\t\t\tif (i && (m = arg.match(literalNumberStringBooleanRegExp))) {\n\t\t\t\t\t\t\t\t\t// Found a native type like string/number/boolean.\n\t\t\t\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\t\t\t\targs.push(m[0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Found a hash object.\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// Addd to the hash object.\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\thashes.push(m[4]+\":\"+(m[6] ? m[6] : makeLookupLiteral(m[5])))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Otherwise output a normal interpolation reference.\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\targs.push( makeLookupLiteral(arg) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tresult.push(args.join(\",\"));\n\t\t\t\t\t\t\tif( hashes.length ) {\n\t\t\t\t\t\t\t\tresult.push(\",{\"+HASH+\":{\"+hashes.join(\",\")+\"}}\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Create an option object for sections of code.\n\t\t\t\t\t\tmode && mode != 'else' && result.push(',[\\n\\n');\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\t// Truthy section\n\t\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\t\tresult.push('{fn:function(' + ARG_NAMES + '){var ___v1ew = [];');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// If/else section\n\t\t\t\t\t\t\t// Falsey section\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @function can.Mustache.helpers.else {{else}}\n\t\t\t\t\t\t\t * @parent can.Mustache.htags 3\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * @signature `{{#helper}}BLOCK{{else}}INVERSE{{/helper}}`\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t * Creates an `inverse` block for a [can.Mustache.helper helper function]'s \n\t\t\t\t\t\t\t * [can.Mustache.helperOptions options argument]'s `inverse` property.\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t * @param {can.Mustache} INVERSE a mustache template coverted to a\n\t\t\t\t\t\t\t * function and set as the [can.Mustache.helper helper function]'s \n\t\t\t\t\t\t\t * [can.Mustache.helperOptions options argument]'s `inverse` property.\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t * @body\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t * ## Use\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t * For more information on how `{{else}}` is used checkout:\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t *  - [can.Mustache.helpers.if {{if key}}]\n\t\t\t\t\t\t\t *  - [can.Mustache.helpers.sectionHelper {{#helper}}]\n\t\t\t\t\t\t\t * \n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tcase 'else':\n\t\t\t\t\t\t\t\tresult.push('return ___v1ew.join(\"\");}},\\n{inverse:function(' + ARG_NAMES + '){\\nvar ___v1ew = [];');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\t\tresult.push('{inverse:function(' + ARG_NAMES + '){\\nvar ___v1ew = [];');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Not a section, no mode\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tresult.push(')');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Return a raw result if there was a section, otherwise return the default string.\n\t\t\t\t\t\tresult = result.join('');\n\t\t\t\t\t\treturn mode ? { raw: result } : result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t})\n\t});\n\n\t// Add in default scanner helpers first.\n\t// We could probably do this differently if we didn't 'break' on every match.\n\tvar helpers = can.view.Scanner.prototype.helpers;\n\tfor (var i = 0; i < helpers.length; i++) {\n\t\tMustache.prototype.scanner.helpers.unshift(helpers[i]);\n\t};\n\n\t/**\n\t * @function can.Mustache.txt\n\t * @hide\n\t * \n\t * Evaluates the resulting string based on the context/name.\n\t *\n\t * @param {Object|Array} context\tThe context stack to be used with evaluation.\n\t * @param {String} mode\t\tThe mode to evaluate the section with: # for truthy, ^ for falsey\n\t * @param {String|Object} name\tThe string (or sometimes object) to pass to the given helper method.\n\t */\n\tMustache.txt = function(scopeAndOptions, mode, name) {\n\t\tvar scope = scopeAndOptions.scope,\n\t\t\toptions = scopeAndOptions.options,\n\t\t\targs = [],\n\t\t\thelperOptions = {\n\t\t\t\tfn: function() {},\n\t\t\t\tinverse: function() {}\n\t\t\t},\n\t\t\thash,\n\t\t\tcontext = scope.attr(\".\"),\n\t\t\tgetHelper = true; \n\t\t\n\t\t// convert lookup values to actual values in name, arguments, and hash\n\t\tfor(var i =3; i < arguments.length;i++){\n\t\t\tvar arg = arguments[i]\n\t\t\tif(mode && can.isArray( arg )){\n\t\t\t\t// merge into options\n\t\t\t\thelperOptions = can.extend.apply(can, [helperOptions].concat(arg))\n\t\t\t} else if(arg && arg[HASH]){\n\t\t\t\thash = arg[HASH];\n\t\t\t\t// get values on hash\n\t\t\t\tfor(var prop in hash){\n\t\t\t\t\tif(isLookup(hash[prop]) ){\n\t\t\t\t\t\thash[prop] = Mustache.get(hash[prop].get, scopeAndOptions)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(arg && isLookup(arg)){\n\t\t\t\targs.push( Mustache.get(arg.get, scopeAndOptions, false, true) );\n\t\t\t} else {\n\t\t\t\targs.push(arg)\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( isLookup(name) ){\n\t\t\tvar get = name.get;\n\t\t\tname = Mustache.get(name.get, scopeAndOptions, args.length , false);\n\t\t\t\n\t\t\t// Base whether or not we will get a helper on whether or not the original\n\t\t\t// name.get and Mustache.get resolve to the same thing. Saves us from running\n\t\t\t// into issues like {{text}} / {text: 'with'}\n\t\t\tgetHelper = (get === name);\n\t\t}\t\n\t\t\t\n\t\t// overwrite fn and inverse to always convert to scopes\n\t\thelperOptions.fn = makeConvertToScopes(helperOptions.fn, scope, options);\n\t\thelperOptions.inverse = makeConvertToScopes(helperOptions.inverse, scope, options)\n\n\t\t// Check for a registered helper or a helper-like function.\n\t\tif (helper = ( getHelper && (typeof name === \"string\" && Mustache.getHelper(name,options)  )|| (can.isFunction(name) && !name.isComputed && { fn: name }))) {\n\t\t\t// Add additional data to be used by helper functions\n\t\t\t\n\t\t\tcan.extend(helperOptions,{\n\t\t\t\tcontext: context,\n\t\t\t\tscope: scope,\n\t\t\t\tcontexts: scope,\n\t\t\t\thash: hash\n\t\t\t})\n\n\t\t\targs.push(helperOptions)\n\t\t\t// Call the helper.\n\t\t\treturn helper.fn.apply(context, args) || '';\n\t\t}\n\n\t\t\n\t\tif( can.isFunction(name)  ){\n\t\t\tif ( name.isComputed ) {\n\t\t\t\tname = name();\n\t\t\t} \n\t\t}\n\n\t\t// An array of arguments to check for truthyness when evaluating sections.\n\t\tvar validArgs = args.length ? args : [name],\n\t\t\t// Whether the arguments meet the condition of the section.\n\t\t\tvalid = true,\n\t\t\tresult = [],\n\t\t\ti, helper, argIsObserve, arg;\n\t\t// Validate the arguments based on the section mode.\n\t\tif (mode) {\n\t\t\tfor (i = 0; i < validArgs.length; i++) {\n\t\t\t\targ          = validArgs[i];\n\t\t\t\targIsObserve = typeof arg !== 'undefined' && isObserveLike(arg);\n\t\t\t\t// Array-like objects are falsey if their length = 0.\n\t\t\t\tif (isArrayLike(arg)) {\n\t\t\t\t\t// Use .attr to trigger binding on empty lists returned from function\n\t\t\t\t\tif(mode == '#'){\n\t\t\t\t\t\tvalid = valid && !!(argIsObserve ? arg.attr('length') : arg.length);\n\t\t\t\t\t} else if(mode == '^'){\n\t\t\t\t\t\tvalid = valid && !(argIsObserve ? arg.attr('length') : arg.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise just check if it is truthy or not.\n\t\t\t\telse {\n\t\t\t\t\tvalid = mode == '#' ? valid && !!arg\n\t\t\t\t\t\t: mode == '^' ? valid && !arg\n\t\t\t\t\t\t: valid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Otherwise interpolate like normal.\n\t\tif (valid) {\n\t\t\tswitch (mode) {\n\t\t\t\t// Truthy section.\n\t\t\t\tcase '#':\n\t\t\t\t\t// Iterate over arrays\n\t\t\t\t\tif (isArrayLike(name)) {\n\t\t\t\t\t\tvar isObserveList = isObserveLike(name);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add the reference to the list in the contexts.\n\t\t\t\t\t\tfor (i = 0; i < name.length; i++) {\n\t\t\t\t\t\t\tresult.push( helperOptions.fn(name[i]) );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Ensure that live update works on observable lists\n\t\t\t\t\t\t\tisObserveList && name.attr(''+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result.join('');\n\t\t\t\t\t}\n\t\t\t\t\t// Normal case.\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn helperOptions.fn(name || {}) || '';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t// Falsey section.\n\t\t\t\tcase '^':\n\t\t\t\t\treturn helperOptions.inverse(name || {}) || '';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Add + '' to convert things like numbers to strings.\n\t\t\t\t\t// This can cause issues if you are trying to\n\t\t\t\t\t// eval on the length but this is the more\n\t\t\t\t\t// common case.\n\t\t\t\t\treturn '' + (name != undefined ? name : '');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn '';\n\t};\n\t\n\t/**\n\t * @function can.Mustache.get\n\t * @hide\n\t *\n\t * Resolves a key for a given object (and then a context if that fails).\n\t *\tobj = this\n\t *\tcontext = { a: true }\n\t *\tref = 'a.b.c'\n\t *\t\t=> obj.a.b.c || context.a.b.c || ''\n\t *\n\t * This implements the following Mustache specs:\n\t * \tDeeply Nested Contexts\n\t *\tAll elements on the context stack should be accessible.\n\t *\t\t{{#bool}}B {{#bool}}C{{/bool}} D{{/bool}}\n\t *\t\t{ bool: true }\n\t *\t\t=> \"B C D\"\n\t * \tBasic Context Miss Interpolation\n\t * \tFailed context lookups should default to empty strings.\n\t *  \t{{cannot}}\n\t *\t\t=> \"\"\n\t * \tDotted Names - Broken Chains\n\t * \tAny falsey value prior to the last part of the name should yield ''.\n\t *\t\t{{a.b.c}}\n\t *\t\t{ a: { d: 1 } }\n\t *\t\t=> \"\"\n\t *\n\t * @param {can.Mustache.key} key      The reference to check for on the obj/context.\n\t * @param {Object} obj  \t\tThe object to use for checking for a reference.\n\t * @param {Object} context  The context to use for checking for a reference if it doesn't exist in the object.\n\t * @param {Boolean} [isHelper]  Whether the reference is seen as a helper.\n\t */\n\tMustache.get = function(key, scopeAndOptions, isHelper, isArgument) {\n\t\t\n\t\t// Cache a reference to the current context and options, we will use them a bunch.\n\t\tvar context = scopeAndOptions.scope.attr('.'),\n\t\t\toptions = scopeAndOptions.options || {};;\n\t\t\n\t\t// If key is called as a helper,\n\t\tif(isHelper){\n\t\t\t// try to find a registered helper.\n\t\t\tif(Mustache.getHelper(key, options)){\n\t\t\t\treturn key\n\t\t\t}\n\t\t\t// Support helper-like functions as anonymous helpers.\n\t\t\t// Check if there is a method directly in the \"top\" context.\n\t\t\tif(scopeAndOptions.scope && can.isFunction(context[key]) ){\n\t\t\t\treturn context[key];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Get a compute (and some helper data) that represents key's value in the current scope\n\t\tvar computeData = scopeAndOptions.scope.computeData(key, {isArgument:isArgument, args: [context, scopeAndOptions.scope]}),\n\t\t\tcompute = computeData.compute;\n\t\t\t\n\t\t// Bind on the compute to cache its value. We will unbind in a timeout later.\n\t\tcan.compute.temporarilyBind(compute);\n\t\t\n\t\t// computeData gives us an initial value\n\t\tvar initialValue = computeData.initialValue;\n\t\t\n\t\t// Use helper over the found value if the found value isn't in the current context\n\t\tif( (initialValue === undefined || computeData.scope != scopeAndOptions.scope) &&  Mustache.getHelper(key, options) ){\n\t\t\treturn key\n\t\t}\n\t\t\n\t\t\n\t\t// If there are no dependencies, just return the value.\n\t\tif( ! compute.hasDependencies ) {\n\t\t\treturn initialValue;\n\t\t} else {\n\t\t\treturn compute;\n\t\t}\n\t};\n\t\n\t/**\n\t * @hide\n\t *\n\t * Resolves an object to its truthy equivalent.\n\t *\n\t * @param {Object} value    The object to resolve.\n\t * @return {Object} The resolved object.\n\t */\n\tMustache.resolve = function(value) {\n\t\tif (isObserveLike(value) && isArrayLike(value) && value.attr('length')){\n\t\t\treturn value;\n\t\t} else if (can.isFunction(value)) {\n\t\t\treturn value();\n\t\t}\n\t\telse {\n\t\t\treturn value;\n\t\t}\n\t};\n\t\n\t/**\n\t * @static\n\t */\n\t\n\tvar OptionsScope = can.view.Scope.extend({\n\t\tinit: function(data, parent){\n\t\t\tif(!data.helpers && !data.partials){\n\t\t\t\tdata = {\n\t\t\t\t\thelpers: data\n\t\t\t\t}\n\t\t\t}\n\t\t\tcan.view.Scope.prototype.init.apply(this, arguments)\n\t\t}\n\t})\n\t\n\t\n\t// ## Helpers\n\t//\n\t// Helpers are functions that can be called from within a template.\n\t// These helpers differ from the scanner helpers in that they execute\n\t// at runtime instead of during compilation.\n\t//\n\t// Custom helpers can be added via `can.Mustache.registerHelper`,\n\t// but there are also some built-in helpers included by default.\n\t// Most of the built-in helpers are little more than aliases to actions \n\t// that the base version of Mustache simply implies based on the \n\t// passed in object.\n\t// \n\t// Built-in helpers:\n\t// \n\t// * `data` - `data` is a special helper that is implemented via scanning helpers. \n\t//\t\tIt hooks up the active element to the active data object: `<div {{data \"key\"}} />`\n\t// * `if` - Renders a truthy section: `{{#if var}} render {{/if}}`\n\t// * `unless` - Renders a falsey section: `{{#unless var}} render {{/unless}}`\n\t// * `each` - Renders an array: `{{#each array}} render {{this}} {{/each}}`\n\t// * `with` - Opens a context section: `{{#with var}} render {{/with}}`\n\tMustache._helpers = {};\n\t/**\n\t * @description Register a helper.\n\t * @function can.Mustache.registerHelper registerHelper\n\t * @signature `Mustache.registerHelper(name, helper)`\n\t * @param {String} name The name of the helper.\n\t * @param {can.Mustache.helper} helper The helper function.\n\t * \n\t * @body\n\t * Registers a helper with the Mustache system.\n\t * Pass the name of the helper followed by the\n\t * function to which Mustache should invoke.\n\t * These are run at runtime.\n\t */\n\tMustache.registerHelper = function(name, fn){\n\t\tthis._helpers[name]={ name: name, fn: fn };\n\t};\n\t\n\t/**\n\t * @hide\n\t * @function can.Mustache.getHelper getHelper\n\t * @description Retrieve a helper.\n\t * @signature `Mustache.getHelper(name)`\n\t * @param {String} name The name of the helper.\n\t * @return {Function|null} The helper, or `null` if\n\t * no helper by that name is found.\n\t *\n\t * @body \n\t * Returns a helper given the name.\n\t */\n\tMustache.getHelper = function(name,options) {\n\t\tvar helper = options.attr(\"helpers.\"+name)\n\t\treturn helper ? { fn: helper } : this._helpers[name];\t\n\t};\n\n\t/**\n\t * @function can.Mustache.static.render render\n\t * @hide\n\t * @parent can.Mustache.static\n\t * @signature `Mustache.render(partial, context)`\n\t * @param {Object} partial\n\t * @param {Object} context\n\t *\n\t * @body\n\t * `Mustache.render` is a helper method that calls\n\t * into `can.view.render` passing the partial \n\t * and the context object.  \n\t * \n\t * Its purpose is to determine if the partial object \n\t * being passed represents a template like:\n\t *\n\t * \t\tpartial === \"movember.mustache\"\n\t *\n\t * or if the partial is a variable name that represents\n\t * a partial on the context object such as:\n\t *\n\t * \t\tcontext[partial] === \"movember.mustache\"\n\t */\n\tMustache.render = function(partial, context, options){\n\t\t// Make sure the partial being passed in\n\t\t// isn't a variable like { partial: \"foo.mustache\" }\n\t\tif(!can.view.cached[partial] && context.attr('partial')){\n\t\t\tpartial = context.attr('partial');\n\t\t}\n\n\t\t// Call into `can.view.render` passing the\n\t\t// partial and context.\n\t\treturn can.view.render(partial, context/*, options*/);\n\t};\n\n\t/**\n   * @function can.Mustache.safeString\n   * @signature `can.Mustache.safeString(str)`\n   *\n   * @param {String} str A string you don't want to become escaped.\n   * @return {String} A string flagged by `can.Mustache` as safe, which will\n   * not become escaped, even if you use [can.Mustache.tags.unescaped](triple slash).\n   *\n   * @body\n   * If you write a helper that generates its own HTML, you will\n   * usually want to return a `can.Mustache.safeString.` In this case,\n   * you will want to manually escape parameters with `[can.esc].`\n   *\n   * @codestart\n   * can.Mustache.registerHelper('link', function(text, url) {\n   *   text = can.esc(text);\n   *   url  = can.esc(url);\n   *\n   *   var result = '&lt;a href=\"' + url + '\"&gt;' + text + '&lt;/a&gt;';\n   *   return can.Mustache.safeString(result);\n   * });\n   * @codeend\n   *\n   * Rendering:\n   * @codestart\n   * &lt;div&gt;{{link \"Google\", \"http://google.com\"}}&lt;/div&gt;\n   * @codeend\n   *\n   * Results in:\n   *\n   * @codestart\n   * &lt;div&gt;&lt;a href=\"http://google.com\"&gt;Google&lt;/a&gt;&lt;/div&gt;\n   * @codeend\n   *\n   * As an anchor tag whereas if we would have just returned the result rather than a\n   * `can.Mustache.safeString` our template would have rendered a div with the escaped anchor tag.\n   *\n   */\n  Mustache.safeString = function(str) {\n    return {\n      toString: function() {\n        return str;\n      }\n    }\n  };\n\n\tMustache.renderPartial = function(partialName,scope,options) {\n\t\tvar partial = options.attr(\"partials.\"+partialName)\n\t\tif(partial){\n\t\t\treturn partial.render ? partial.render(scope,options) :\n\t\t\t\t\tpartial(scope,options);\n\t\t} else {\n\t\t\treturn can.Mustache.render(partialName,scope,options);\n\t\t}\n\t};\n\n\t// The built-in Mustache helpers.\n\tcan.each({\n\t\t// Implements the `if` built-in helper.\n\t\t/**\n\t\t * @function can.Mustache.helpers.if {{#if key}}\n\t\t * @parent can.Mustache.htags 2\n\t\t * @signature `{{#if key}}BLOCK{{/if}}`\n\t \t * \n\t \t * Renders the `BLOCK` template within the current template.\n\t \t * \n\t \t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t \t * context. If the value is a function or can.compute, the function's return value is used.\n\t \t * \n\t \t * @param {can.Mustache} BLOCK A mustache template.\n\t \t * \n\t \t * @return {String} If the key's value is truthy, the `BLOCK` is rendered with the\n\t \t * current context and its value is returned; otherwise, an empty string.\n\t \t * \n\t \t * @body\n\t \t * \n\t \t * ## Use\n\t \t * \n\t\t * `{{#if key}}` provides explicit conditional truthy tests. For example,\n\t\t * \n\t\t * The template:\n\t\t * \n\t\t *     {{#if user.isFemale}}\n\t\t *       {{#if user.isMarried}}\n\t\t *         Mrs \n\t\t *       {{/if}}\n\t\t *       {{#if user.isSingle}}\n\t\t *         Miss \n\t\t *       {{/if}}\n\t\t *     {{/if}}\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     {user: {isFemale: true, isMarried: true}}\n\t\t *     \n\t\t * Results in:\n\t\t * \n\t\t *     Mrs\n\t\t * \n\t\t * If can be used with [can.Mustache.helpers.else {{else}}] too. For example,\n\t\t * \n\t\t *     {{#if user.isFemale}}\n\t\t *       {{#if user.isMarried}}\n\t\t *         Mrs \n\t\t *       {{else}}\n\t\t *         Miss \n\t\t *       {{/if}}\n\t\t *     {{/if}}\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     {user: {isFemale: true, isMarried: false}}\n\t\t *     \n\t\t * Results in:\n\t\t * \n\t\t *     Miss\n\t\t */\n\t\t'if': function(expr, options){\n\t\t\tvar value;\n\t\t\t// if it's a function, wrap its value in a compute\n\t\t\t// that will only change values from true to false\n\t\t\tif(can.isFunction(expr)){\n\t\t\t\tvalue = can.compute.truthy(expr)()\n\t\t\t} else {\n\t\t\t\tvalue = !!Mustache.resolve(expr)\n\t\t\t}\n\t\t\t\n\t\t\tif ( value ) {\n\t\t\t\treturn options.fn(options.contexts || this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn options.inverse(options.contexts || this);\n\t\t\t}\n\t\t},\n\t\t// Implements the `unless` built-in helper.\n\t\t/**\n\t\t * @function can.Mustache.helpers.unless {{#unless key}}\n\t\t * @parent can.Mustache.htags 4\n\t\t * \n\t \t * @signature `{{#unless key}}BLOCK{{/unless}}`\n\t \t * \n\t \t * Render the block of text if the key's value is falsey.\n\t \t * \n\t \t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t * context. If the value is a function or can.compute, the function's \n\t\t * return value is used.\n\t\t * \n\t \t * @param {can.Mustache} BLOCK A template that is rendered \n\t \t * if the `key`'s value is falsey.\n\t \t * \n\t \t * @body\n\t \t * \n\t\t * The `unless` helper evaluates the inverse of the value\n\t\t * of the key and renders the block between the helper and the slash.\n\t\t * \n\t\t *     {{#unless expr}}\n\t\t *       // unless\n\t\t *     {{/unless}}\n\t\t */\n\t\t'unless': function(expr, options){\n\t\t\tif (!Mustache.resolve(expr)) {\n\t\t\t\treturn options.fn(options.contexts || this);\n\t\t\t}\n\t\t},\n\t\t\n\t\t// Implements the `each` built-in helper.\n\t\t/**\n\t\t * @function can.Mustache.helpers.each {{#each key}}\n\t \t * @parent can.Mustache.htags 5\n\t \t * \n\t \t * @signature `{{#each key}}BLOCK{{/each}}`\n\t \t * \n\t \t * Render the block of text for each item in key's value.\n\t \t * \n\t \t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t * context. If the value is a function or can.compute, the function's \n\t\t * return value is used.\n\t\t * \n\t\t * If the value of the key is a [can.List], the resulting HTML is updated when the\n\t\t * list changes. When a change in the list happens, only the minimum amount of DOM\n\t\t * element changes occur.\n\t\t *\n\t\t * If the value of the key is a [can.Map], the resulting HTML is updated whenever\n\t\t * attributes are added or removed. When a change in the map happens, only \n\t\t * the minimum amount of DOM element changes occur.\n\t \t * \n\t \t * @param {can.Mustache} BLOCK A template that is rendered for each item in \n\t \t * the `key`'s value. The `BLOCK` is rendered with the context set to the item being rendered.\n\t \t * \n\t \t * @body\n\t \t * \n\t \t * ## Use\n\t \t * \n\t \t * Use the `each` helper to iterate over a array\n\t\t * of items and render the block between the helper and the slash. For example,\n\t\t * \n\t\t * The template:\n\t\t * \n\t\t *     <ul>\n\t\t *       {{#each friends}}\n\t\t *         <li>{{name}}</li>\n\t\t *       {{/each}}\n\t\t *     </ul>\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\t\t * \n\t\t * Renders:\n\t\t * \n\t\t *     <ul>\n\t\t *       <li>Austin</li>\n\t\t *       <li>Justin</li>\n\t\t *     </ul>\n\t\t *\n\t\t * ## Object iteration\n\t\t *\n\t\t * As of 2.1, you can now iterate over properties of objects and attributes with\n\t\t * the `each` helper. When iterating over [can.Map] it will only iterate over the\n\t\t * map's [keys](can.Map.keys.html) and none of the hidden properties of a can.Map. For example,\n\t\t * \n\t\t * The template:\n\t\t * \n\t\t *     <ul>\n\t\t *       {{#each person}}\n\t\t *         <li>{{.}}</li>\n\t\t *       {{/each}}\n\t\t *     </ul>\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     {person: {name: 'Josh', age: 27}}\n\t\t * \n\t\t * Renders:\n\t\t * \n\t\t *     <ul>\n\t\t *       <li>Josh</li>\n\t\t *       <li>27</li>\n\t\t *     </ul>\n\t\t */\n\t\t'each': function(expr, options) {\n\t\t\t// Check if this is a list or a compute that resolves to a list, and setup\n\t\t\t// the incremental live-binding \n\t\t\t\n\t\t\t\n\t\t\t// First, see what we are dealing with.  It's ok to read the compute\n\t\t\t// because can.view.text is only temporarily binding to what is going on here.\n\t\t\t// Calling can.view.lists prevents anything from listening on that compute.\n\t\t\tvar resolved = Mustache.resolve(expr);\n\t\t\t\n\t\t\tif(resolved instanceof can.List){\n\t\t\t\treturn can.view.lists && can.view.lists(expr, function(item, index) {\n\t\t\t\t\treturn options.fn( options.scope.add({\"@index\": index}).add(item) );\n\t\t\t\t});\n\t\t\t}\n\t\t\texpr = resolved;\n\t\t\t\n\t\t\tif (!!expr && isArrayLike(expr)) {\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var i = 0; i < expr.length; i++) {\n\t\t\t\t\tvar index = function() {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tresult.push(options.fn(options.scope.add({\"@index\": index}).add(expr[i])));\n\t\t\t\t}\n\t\t\t\treturn result.join('');\n\t\t\t}\n\t\t\telse if(isObserveLike(expr)) {\n\t\t\t\tvar result = [],\n\t\t\t\t\t// listen to keys changing so we can livebind lists of attributes.\n\t\t\t\t\tkeys = can.Map.keys(expr);\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tresult.push(options.fn(options.scope.add({\"@key\": key}).add(expr[key])));\n\t\t\t\t}\n\t\t\t\treturn result.join('');\n\t\t\t}\n\t\t\telse if(expr instanceof Object) {\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var key in expr) {\n\t\t\t\t\tresult.push(options.fn(options.scope.add({\"@key\": key}).add(expr[key])));\n\t\t\t\t}\n\t\t\t\treturn result.join('');\n\n\t\t\t}\n\t\t},\n\t\t// Implements the `with` built-in helper.\n\t\t/**\n\t\t * @function can.Mustache.helpers.with {{#with key}}\n\t\t * @parent can.Mustache.htags 6\n\t\t * \n\t\t * @signature `{{#with key}}BLOCK{{/with}}`\n\t\t * \n\t\t * Changes the context within a block.\n\t\t * \n\t\t * @param {can.Mustache.key} key A key that references a value within the current or parent \n\t\t * context. If the value is a function or can.compute, the function's \n\t\t * return value is used.\n\t\t * \n\t \t * @param {can.Mustache} BLOCK A template that is rendered \n\t \t * with the context of the `key`'s value.\n\t\t * \n\t\t * @body\n\t \t * \n\t\t * Mustache typically applies the context passed in the section \n\t\t * at compiled time.  However, if you want to override this \n\t\t * context you can use the `with` helper.\n\t\t * \n\t\t *     {{#with arr}}\n\t\t *       // with\n\t\t *     {{/with}}\n\t\t */\n\t\t'with': function(expr, options){\n\t\t\tvar ctx = expr;\n\t\t\texpr = Mustache.resolve(expr);\n\t\t\tif (!!expr) {\n\t\t\t\treturn options.fn(ctx);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can.Mustache.helpers.log {{log}}\n\t\t * @parent can.Mustache.htags 9\n\t\t * \n\t\t * @signature `{{#log [message]}}`\n\t\t * \n\t\t * Logs the context of the current block with an optional message.\n\t\t * \n\t\t * @param {*} message An optional message to log out in addition to the \n\t\t * current context. \n\t\t *\n\t\t */\n\t\t'log': function(expr, options) {\n\t\t\tif(console !== undefined) {\n\t\t\t\tif(!options) {\n\t\t\t\t\tconsole.log(expr.context);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(expr, options.context);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @function can.Mustache.helpers.elementCallback {{(el)->CODE}}\n\t\t *\n\t\t * @parent can.Mustache.htags 8\n\t\t *\n\t\t * @signature `{{(el) -> CODE}}`\n\t\t * \n\t\t * Executes an element callback with the inline code on the element.\n\t\t * \n\t\t * @param {String} code The inline code to execute on the element.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use \n\t\t * \n\t\t * It is common for you to want to execute some code on a given \n\t\t * DOM element. An example would be for initializing a jQuery plugin \n\t\t * on the new HTML.\n\t\t * \n\t\t * \t\t<div class=\"tabs\" {{(el) -> el.jquery_tabs()}}></div>\n\t\t * \n\t\t */\n\t\t//\n\t\t/**\n\t\t * @function can.Mustache.helpers.index {{@index}}\n\t\t *\n\t\t * @parent can.Mustache.htags 10\n\t\t *\n\t\t * @signature `{{@index [offset]}}`\n\t\t * \n\t\t * Insert the index of an Array or can.List we are iterating on with [#each](can.Mustache.helpers.each)\n\t\t * \n\t\t * @param {Number} offset The number to optionally offset the index by.\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use \n\t\t * \n\t\t * When iterating over and array or list of items, you might need to render the index\n\t\t * of the item. Use the `@index` directive to do so. For example,\n\t\t *\n\t\t * The template:\n\t\t * \n\t\t *     <ul>\n\t\t *       {{#each items}}\n\t\t *         <li> {{@index}} - {{.}} </li>\n\t\t *       {{/each}}\n\t\t *     </ul>\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     { items: ['Josh', 'Eli', 'David'] }\n\t\t * \n\t\t * Renders:\n\t\t * \n\t\t *     <ul>\n\t\t *       <li> 0 - Josh </li>\n\t\t *       <li> 1 - Eli </li>\n\t\t *       <li> 2 - David </li>\n\t\t *     </ul>\n\t\t * \n\t\t */\n\t\t //\n\t\t/**\n\t\t * @function can.Mustache.helpers.key {{@key}}\n\t\t *\n\t\t * @parent can.Mustache.htags 11\n\t\t *\n\t\t * @signature `{{@key}}`\n\t\t * \n\t\t * Insert the property name of an Object or attribute name of a can.Map that we iterate over with [#each](can.Mustache.helpers.each)\n\t\t * \n\t\t * @body\n\t\t * \n\t\t * ## Use \n\t\t * \n\t\t * Use `{{@key}}` to render the property or attribute name of an Object or can.Map, when iterating over it with [#each](can.Mustache.helpers.each). For example,\n\t\t * \n\t\t * The template:\n\t\t * \n\t\t *     <ul>\n\t\t *       {{#each person}}\n\t\t *         <li> {{@key}}: {{.}} </li>\n\t\t *       {{/each}}\n\t\t *     </ul>\n\t\t * \n\t\t * Rendered with:\n\t\t * \n\t\t *     { person: {name: 'Josh', age: 27, likes: 'Mustache, JavaScript, High Fives'} }\n\t\t * \n\t\t * Renders:\n\t\t * \n\t\t *     <ul>\n\t\t *       <li> name: Josh </li>\n\t\t *       <li> age: 27 </li>\n\t\t *       <li> likes: Mustache, JavaScript, High Fives </li>\n\t\t *     </ul>\n\t\t * \n\t\t */\n\t}, function(fn, name){\n\t\tMustache.registerHelper(name, fn);\n\t});\n\t\n\t// ## Registration\n\t//\n\t// Registers Mustache with can.view.\n\tcan.view.register({\n\t\tsuffix: \"mustache\",\n\n\t\tcontentType: \"x-mustache-template\",\n\n\t\t// Returns a `function` that renders the view.\n\t\tscript: function( id, src ) {\n\t\t\treturn \"can.Mustache(function(\"+ARG_NAMES+\") { \" + new Mustache({\n\t\t\t\ttext: src,\n\t\t\t\tname: id\n\t\t\t}).template.out + \" })\";\n\t\t},\n\n\t\trenderer: function( id, text ) {\n\t\t\treturn Mustache({\n\t\t\t\ttext: text,\n\t\t\t\tname: id\n\t\t\t});\n\t\t}\n\t});\n\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/observe',[\"can/util/library\", \"can/map\", \"can/list\", \"can/compute\"], function(can){\n\tcan.Observe = can.Map;\n\tcan.Observe.startBatch = can.batch.start;\n\tcan.Observe.stopBatch = can.batch.stop;\n\tcan.Observe.triggerBatch = can.batch.trigger;\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/view/bindings',[\"can/util/library\", \"can/view/mustache\", \"can/control\"], function(can){\n\t\n\t\n\t\n\t/**\n\t * @function can.view.bindings.can-value can-value\n\t * @parent can.view.bindings\n\t * \n\t * Sets up two way bindings in a template.\n\t * \n\t * @signature `can-value='KEY'`\n\t * \n\t * Binds the element's value or checked property to the value specified by \n\t * key. Example:\n\t * \n\t *     <input type='text' can-value='first.name'/>\n\t * \n\t * @param {can.Mustache.key} key A named value in the current scope.\n\t * \n\t * @body\n\t * \n\t * ## Use\n\t * \n\t * Add a `can-value=\"KEY\"` attribute to an input or select element and\n\t * the element's value will be cross-bound to an observable value specified by `KEY`.\n\t * \n\t * Depending on the element and the element's type, `can-value` takes on \n\t * different behaviors.  If an input element has a type\n\t * not listed here, the behavior is the same as the `text` type.\n\t * \n\t * ## input type=text\n\t * \n\t * Cross binds the input's string text value with the observable value.\n\t * \n\t * @demo can/view/bindings/hyperloop.html\n\t * \n\t * ## input type=checkbox\n\t * \n\t * Cross binds the checked property to a true or false value. An alternative\n\t * true and false value can be specified by setting `can-true-value` and\n\t * `can-false-value` attributes.\n\t * \n\t * @demo can/view/bindings/input-checkbox.html\n\t * \n\t * ## input type='radio'\n\t * \n\t * If the radio element is checked, sets the observable specified by `can-value` to match the value of \n\t * `value` attribute.  \n\t * \n\t * @demo can/view/bindings/input-radio.html\n\t * \n\t * ## select\n\t * \n\t * Cross binds the selected option value with an observable value.\n\t * \n\t * @demo can/view/bindings/select.html\n\t * \n\t */\n\tcan.view.Scanner.attribute(\"can-value\", function(data, el){\n\t\t\n\t\tvar attr = el.getAttribute(\"can-value\"),\n\t\t\tvalue = data.scope.computeData(attr,{args:[]}).compute;\n\t\t\n\t\tif(el.nodeName.toLowerCase() === \"input\"){\n\t\t\tif(el.type === \"checkbox\") {\n\t\t\t\tif( el.hasAttribute(\"can-true-value\") ) {\n\t\t\t\t\tvar trueValue = data.scope.compute( el.getAttribute(\"can-true-value\") )\n\t\t\t\t} else {\n\t\t\t\t\tvar trueValue = can.compute(true)\n\t\t\t\t}\n\t\t\t\tif( el.hasAttribute(\"can-false-value\") ) {\n\t\t\t\t\tvar falseValue = data.scope.compute( el.getAttribute(\"can-false-value\") )\n\t\t\t\t} else {\n\t\t\t\t\tvar falseValue = can.compute(false)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(el.type === \"checkbox\" || el.type === \"radio\") {\n\t\t\t\tnew Checked(el,{\n\t\t\t\t\tvalue: value,\n\t\t\t\t\ttrueValue: trueValue,\n\t\t\t\t\tfalseValue: falseValue\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnew Value(el,{value: value})\n\t});\n\t\n\tvar special = {\n\t\tenter: function(data, el, original){\n\t\t\treturn {\n\t\t\t\tevent: \"keyup\",\n\t\t\t\thandler: function(ev){\n\t\t\t\t\tif(ev.keyCode == 13) {\n\t\t\t\t\t\treturn original.call(this,ev)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @function can.view.bindings.can-EVENT can-EVENT\n\t * @parent can.view.bindings\n\t * \n\t * @signature `can-EVENT='KEY'`\n\t * \n\t * Specify a callback function to be called on a particular event.\n\t * \n\t * @param {String} EVENT A event name like `click` or `keyup`.  If you are\n\t * using jQuery, you can listen to jQuery special events too.\n\t * \n\t * @param {can.Mustache.key} key A named value in the current scope.  The value\n\t * should be a function.\n\t * \n\t * @body\n\t * \n\t * ## Use\n\t * \n\t * By adding `can-EVENT='KEY'` to an element, the function pointed to\n\t * by `KEY` is bound to the element's `EVENT` event. The function \n\t * is called back with:\n\t * \n\t *  - `context` - the context of the element\n\t *  - `element` - the element that was bound\n\t *  - `event` - the event that was triggered\n\t * \n\t * @demo can/view/bindings/can-event.html\n\t * \n\t */\n\tcan.view.Scanner.attribute(/can-[\\w\\.]+/,function(data, el){\n\t\t\n\t\tvar attributeName = data.attr,\n\t\t\tevent = data.attr.substr(\"can-\".length),\n\t\t\thandler = function(ev){\n\t\t\t\tvar attr = el.getAttribute(attributeName),\n\t\t\t\t\tscopeData = data.scope.read(attr,{returnObserveMethods: true, isArgument: true});\n\t\t\t\treturn scopeData.value.call(scopeData.parent,data.scope._context, can.$(this), ev )\n\t\t\t};\n\t\t\n\t\tif(special[event]){\n\t\t\tvar specialData = special[event](data, el, handler);\n\t\t\thandler = specialData.handler;\n\t\t\tevent = specialData.event;\n\t\t}\n\t\t\n\t\tcan.bind.call( el, event, handler);\n\t});\n\t\n\t\n\tvar Value = can.Control.extend({\n\t\tinit: function(){\n\t\t\tif(this.element[0].nodeName.toUpperCase() === \"SELECT\"){\n\t\t\t\t// need to wait until end of turn ...\n\t\t\t\tsetTimeout(can.proxy(this.set,this),1)\n\t\t\t} else {\n\t\t\t\tthis.set()\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\"{value} change\": \"set\",\n\t\tset: function(){\n\t\t\t//this may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired\n\t\t\tif(!this.element) return;\n\n\t\t\tvar val = this.options.value();\n\t\t\tthis.element[0].value = (typeof val === 'undefined' ? '' : val);\n\t\t},\n\t\t\"change\": function(){\n\t\t\t//this may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired\n\t\t\tif(!this.element) return;\n\t\t\t\n\t\t\tthis.options.value(this.element[0].value)\n\t\t}\n\t})\n\t\n\tvar Checked = can.Control.extend({\n\t\tinit: function(){\n\t\t\tthis.isCheckebox = (this.element[0].type.toLowerCase() == \"checkbox\");\n\t\t\tthis.check()\n\t\t},\n\t\t\"{value} change\": \"check\",\n\t\t\"{trueValue} change\": \"check\",\n\t\t\"{falseValue} change\": \"check\",\n\t\tcheck: function(){\n\t\t\tif(this.isCheckebox){\n\t\t\t\tvar value =  this.options.value(),\n\t\t\t\t\ttrueValue = this.options.trueValue() || true,\n\t\t\t\t\tfalseValue = this.options.falseValue() || false;\n\t\t\t\t\t\n\t\t\t\tthis.element[0].checked = ( value == trueValue )\n\t\t\t} else {\n\t\t\t\tif(this.options.value() === this.element[0].value){\n\t\t\t\t\tthis.element[0].checked = true //.prop(\"checked\", true)\n\t\t\t\t} else {\n\t\t\t\t\tthis.element[0].checked = false //.prop(\"checked\", false)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t},\n\t\t\"change\": function(){\n\t\t\t\n\t\t\tif(this.isCheckebox){\n\t\t\t\tthis.options.value( this.element[0].checked? this.options.trueValue() : this.options.falseValue() );\n\t\t\t} else {\n\t\t\t\tif(this.element[0].checked){\n\t\t\t\t\tthis.options.value( this.element[0].value );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t});\n\t\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/component',[\"can/util/library\", \"can/control\", \"can/observe\", \"can/view/mustache\", \"can/view/bindings\"], function(can){\n\t\n\tvar ignoreAttributesRegExp = /dataViewId|class|id/i\n\t/**\n\t * @add can.Component\n\t */\n\tvar Component = can.Component = can.Construct.extend(\n\t/**\n\t * @static\n\t */\n\t{\n\t\tsetup: function(){\n\t\t\tcan.Construct.setup.apply( this, arguments );\n\t\t\t\n\t\t\tif(can.Component){\n\t\t\t\tvar self = this;\n\t\t\t\tthis.Control = can.Control.extend({\n\t\t\t\t\t_lookup: function(options){\n\t\t\t\t\t\treturn [options.scope, options, window]\n\t\t\t\t\t}\n\t\t\t\t},can.extend({\n\t\t\t\t\tsetup: function(el, options){\n\t\t\t\t\t\tvar res = can.Control.prototype.setup.call(this, el, options)\n\t\t\t\t\t\tthis.scope = options.scope;\n\t\t\t\t\t\t// call on() whenever scope changes\n\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\tthis.on(this.scope,\"change\",function(){\n\t\t\t\t\t\t\tself.on();\n\t\t\t\t\t\t\tself.on(self.scope,\"change\",arguments.callee);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t},this.prototype.events));\n\t\t\t\t\n\t\t\t\tvar attributeScopeMappings = {};\n\t\t\t\t// go through scope and get attribute ones\n\t\t\t\tcan.each(this.prototype.scope, function(val, prop){\n\t\t\t\t\tif(val === \"@\") {\n\t\t\t\t\t\tattributeScopeMappings[prop] = prop;\n\t\t\t\t\t}\n\t\t\t\t}) \n\t\t\t\tthis.attributeScopeMappings = attributeScopeMappings;\n\t\t\t\t\n\t\t\t\t// If scope is an object,\n\t\t\t\tif(! this.prototype.scope || typeof this.prototype.scope === \"object\" ){\n\t\t\t\t\t// use that object as the prototype of an extened Map constructor function.\n\t\t\t\t\t// A new instance of that Map constructor function will be created and\n\t\t\t\t\t// set as this.scope.\n\t\t\t\t\tthis.Map = can.Map.extend( this.prototype.scope||{} );\n\t\t\t\t} \n\t\t\t\t// If scope is a can.Map constructor function, \n\t\t\t\telse if(this.prototype.scope.prototype instanceof can.Map) {\n\t\t\t\t\t// just use that.\n\t\t\t\t\tthis.Map = this.prototype.scope;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(this.prototype.template){\n\t\t\t\t\tif(typeof this.prototype.template == \"function\"){\n\t\t\t\t\t\tvar temp = this.prototype.template\n\t\t\t\t\t\tthis.renderer = function(){\n\t\t\t\t\t\t\treturn can.view.frag(temp.apply(null, arguments))\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.renderer =can.view.mustache( this.prototype.template );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcan.view.Scanner.tag(this.prototype.tag,function(el, options){\n\t\t\t\t\tnew self(el, options)\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t}\n\t},{\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\tsetup: function(el, hookupOptions){\n\t\t\t// Setup values passed to component\n\t\t\tvar initalScopeData = {},\n\t\t\t\tcomponent = this,\n\t\t\t\ttwoWayBindings = {},\n\t\t\t\t// what scope property is currently updating\n\t\t\t\tscopePropertyUpdating,\n\t\t\t\t// the object added to the scope\n\t\t\t\tcomponentScope;\n\t\t\t\n\t\t\t// scope prototype properties marked with an \"@\" are added here\n\t\t\tcan.each(this.constructor.attributeScopeMappings,function(val, prop){\n\t\t\t\tinitalScopeData[prop] = el.getAttribute(can.hyphenate(val));\n\t\t\t})\n\t\t\t\n\t\t\t// get the value in the scope for each attribute\n\t\t\t// the hookup should probably happen after?\n\t\t\tcan.each(can.makeArray(el.attributes), function(node, index){\n\t\t\t\t\n\t\t\t\tvar name = can.camelize(node.nodeName.toLowerCase()),\n\t\t\t\t\tvalue = node.value;\n\t\t\t\t// ignore attributes already in ScopeMappings\n\t\t\t\tif(component.constructor.attributeScopeMappings[name] || ignoreAttributesRegExp.test(name)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Cross-bind the value in the scope to this \n\t\t\t\t// component's scope\n\t\t\t\tvar computeData = hookupOptions.scope.computeData(value, {args: []}),\n\t\t\t\t\tcompute = computeData.compute;\n\t\t\t\t\n\t\t\t\t// bind on this, check it's value, if it has dependencies\n\t\t\t\tvar handler = function(ev, newVal){\n\t\t\t\t\tscopePropertyUpdating = name;\n\t\t\t\t\tcomponentScope.attr(name, newVal);\n\t\t\t\t\tscopePropertyUpdating = null;\n\t\t\t\t}\n\t\t\t\t// compute only returned if bindable\n\t\t\t\t\n\t\t\t\tcompute.bind(\"change\", handler);\n\t\t\t\t\n\t\t\t\t// set the value to be added to the scope\n\t\t\t\tinitalScopeData[name] = compute();\n\t\t\t\t\n\t\t\t\tif(!compute.hasDependencies) {\n\t\t\t\t\tcompute.unbind(\"change\", handler);\n\t\t\t\t} else {\n\t\t\t\t\t// make sure we unbind (there's faster ways of doing this)\n\t\t\t\t\tcan.bind.call(el,\"removed\",function(){\n\t\t\t\t\t\tcompute.unbind(\"change\", handler);\n\t\t\t\t\t})\n\t\t\t\t\t// setup two-way binding\n\t\t\t\t\ttwoWayBindings[name] = computeData\n\t\t\t\t}\n\t\t\t\t\n\t\t\t})\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(this.constructor.Map){\n\t\t\t\tcomponentScope = new this.constructor.Map(initalScopeData);\n\t\t\t} else if(this.scope instanceof can.Map) {\n\t\t\t\tcomponentScope = this.scope;\n\t\t\t} else if(can.isFunction(this.scope)){\n\n\t\t\t\tvar scopeResult = this.scope(initalScopeData, hookupOptions.scope, el);\n\t\t\t\t// if the function returns a can.Map, use that as the scope\n\t\t\t\tif(scopeResult instanceof can.Map){\n\t\t\t\t\tcomponentScope = scopeResult\n\t\t\t\t} else if( scopeResult.prototype instanceof can.Map ){\n\t\t\t\t\tcomponentScope = new scopeResult(initalScopeData);\n\t\t\t\t} else {\n\t\t\t\t\tcomponentScope = new ( can.Map.extend(scopeResult) )(initalScopeData);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tvar handlers = {};\n\t\t\t// setup reverse bindings\n\t\t\tcan.each(twoWayBindings, function(computeData, prop){\n\t\t\t\thandlers[prop] = function(ev, newVal){\n\t\t\t\t\t// check that this property is not being changed because\n\t\t\t\t\t// it's source value just changed\n\t\t\t\t\tif(scopePropertyUpdating !== prop){\n\t\t\t\t\t\tcomputeData.compute(newVal)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcomponentScope.bind(prop, handlers[prop])\n\t\t\t});\n\t\t\t// teardown reverse bindings when element is removed\n\t\t\tcan.bind.call(el,\"removed\",function(){\n\t\t\t\tcan.each(handlers, function(handler, prop){\n\t\t\t\t\tcomponentScope.unbind(prop, handlers[prop])\n\t\t\t\t})\n\t\t\t})\n\t\t\t\n\t\t\tthis.scope = componentScope;\n\t\t\tcan.data(can.$(el),\"scope\", this.scope)\n\t\t\t\n\t\t\t// create a real Scope object out of the scope property\n\t\t\tvar renderedScope = hookupOptions.scope.add( this.scope ),\n\t\t\t\n\t\t\t\t// setup helpers to callback with `this` as the component\n\t\t\t\thelpers = {};\n\n\t\t\tcan.each(this.helpers || {}, function(val, prop){\n\t\t\t\tif(can.isFunction(val)) {\n\t\t\t\t\thelpers[prop] = function(){\n\t\t\t\t\t\treturn val.apply(componentScope, arguments)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// create a control to listen to events\n\t\t\tthis._control = new this.constructor.Control(el, {scope: this.scope});\n\t\t\t\n\t\t\t\n\t\t\tvar self = this;\n\t\t\t\n\t\t\t// if this component has a template (that we've already converted to a renderer)\n\t\t\tif( this.constructor.renderer ) {\n\t\t\t\t// add content to tags\n\t\t\t\tif(!helpers._tags){\n\t\t\t\t\thelpers._tags = {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// we need be alerted to when a <content> element is rendered so we can put the original contents of the widget in its place\n\t\t\t\thelpers._tags.content = function(el, rendererOptions){\n\t\t\t\t\t// first check if there was content within the custom tag\n\t\t\t\t\t// otherwise, render what was within <content>, the default code\n\t\t\t\t\tvar subtemplate = hookupOptions.subtemplate || rendererOptions.subtemplate;\n\t\t\t\t\t\n\t\t\t\t\tif(subtemplate) {\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// rendererOptions.options is a scope of helpers where `<content>` was found, so\n\t\t\t\t\t\t// the right helpers should already be available.\n\t\t\t\t\t\t// However, _tags.content is going to point to this current content callback.  We need to \n\t\t\t\t\t\t// remove that so it will walk up the chain\n\t\t\t\t\t\t\n\t\t\t\t\t\tdelete helpers._tags.content;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcan.view.live.replace( [el], subtemplate(\n\t\t\t\t\t\t\t// This is the context of where `<content>` was found\n\t\t\t\t\t\t\t// which will have the the component's context\n\t\t\t\t\t\t\trendererOptions.scope, \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trendererOptions.options )  );\n\t\t\t\t\t\t\n\t\t\t\t\t\t// restore the content tag so it could potentially be used again (as in lists)\n\t\t\t\t\t\thelpers._tags.content = arguments.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// render the component's template\n\t\t\t\tvar frag = this.constructor.renderer( renderedScope, hookupOptions.options.add(helpers) );\n\t\t\t} else {\n\t\t\t\t// otherwise render the contents between the \n\t\t\t\tvar frag = can.view.frag( hookupOptions.subtemplate ? hookupOptions.subtemplate(renderedScope, hookupOptions.options.add(helpers)) : \"\");\n\t\t\t}\n\t\t\tcan.appendChild(el, frag);\n\t\t}\n\t})\n\t\n\tif(window.$ && $.fn){\n\t\t$.fn.scope = function(attr){\n\t\t\tif( attr ) {\n\t\t\t\treturn this.data(\"scope\").attr(attr)\n\t\t\t} else {\n\t\t\t\treturn this.data(\"scope\")\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tcan.scope = function(el, attr){\n\t\tvar el = can.$(el);\n\t\tif( attr ){\n\t\t\treturn can.data(el,\"scope\").attr(attr)\n\t\t} else {\n\t\t\treturn can.data(el, \"scope\")\n\t\t}\n\t}\n\t\n\treturn Component;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can',[\"can/util/library\", \"can/control/route\", \"can/model\", \"can/view/mustache\", \"can/component\"], function(can) {\n\treturn can;\n});",
    "\n/*!\n * CanJS - 2.0.4\n * http://canjs.us/\n * Copyright (c) 2013 Bitovi\n * Mon, 23 Dec 2013 19:49:14 GMT\n * Licensed MIT\n * Includes: CanJS default build\n * Download from: http://canjs.us/\n */\ndefine('can/route/pushstate',[\"can/util/library\", \"can/route\"], function(can) {\n    \"use strict\";\n\n    if(window.history && history.pushState) {\n\t\tcan.route.bindings.pushstate = {\n\t\t\t/**\n        \t * @property {String} can.route.pushstate.root\n        \t * @parent can.route.pushstate\n        \t * \n        \t * @description Configure the base url that will not be modified.\n        \t * \n        \t * @option {String} Represents the base url that pushstate will prepend to all \n        \t * routes.  `root` defaults to: `\"/\"`.\n        \t * \n        \t * @body\n        \t * \n        \t * ## Use\n        \t * \n        \t * By default, a route like:\n        \t * \n        \t *     can.route(\":type/:id\")\n        \t * \n        \t * Matches urls like:\n        \t * \n        \t *     http://domain.com/contact/5\n        \t * \n        \t * But sometimes, you only want to match pages within a certain directory.  For \n        \t * example, an application that is a filemanager.  You might want to \n        \t * specify root and routes like:\n        \t * \n        \t *     can.route.pushstate.root = \"/filemanager/\"\n        \t *     can.route(\"file-:fileId\");\n        \t *     can.route(\"folder-:fileId\")\n        \t * \n        \t * Which matches urls like:\n        \t * \n        \t *     http://domain.com/filemanager/file-34234\n        \t * \n        \t */\n        \troot: \"/\",\n        \tparamsMatcher: /^\\?(?:[^=]+=[^&]*&)*[^=]+=[^&]*/,\n\t        querySeparator: '?',\n\t        bind: function() {\n\t        \t// intercept routable links\n                can.delegate.call(can.$(document.documentElement),'a', 'click', anchorClickFix);\n                \n                // popstate only fires on back/forward.\n\t\t        // To detect when someone calls push/replaceState, we need to wrap each method.\n\t\t        can.each(['pushState','replaceState'],function(method) {\n\t\t            originalMethods[method] = window.history[method];\n\t\t            window.history[method] = function(state) {\n\t\t                var result = originalMethods[method].apply(window.history, arguments);\n\t\t                can.route.setState();\n\t\t                return result;\n\t\t            };\n\t\t        });\n\t\t        \n\t\t        // Bind to popstate for back/forward\n\t\t        can.bind.call(window, 'popstate', can.route.setState);\n            },\n\t        unbind: function(){\n        \t\tcan.undelegate.call(can.$(document.documentElement),'click', 'a', anchorClickFix);\n        \t\n            \tcan.each(['pushState','replaceState'],function(method) {\n\t\t            window.history[method] = originalMethods[method];\n\t\t        });\n            \tcan.unbind.call(window, 'popstate', can.route.setState);\n            },\n\t        matchingPartOfURL: function(){\n            \tvar root = cleanRoot(),\n            \t\tloc = (location.pathname + location.search),\n            \t\tindex = loc.indexOf(root);\n            \t\n            \treturn loc.substr(index+root.length);\n            },\n            setURL: function(path) {\n            \t// keep hash if not in path, but in \n            \tif( includeHash && path.indexOf(\"#\") == -1 && window.location.hash) {\n            \t\tpath += window.location.hash\n            \t}\n            \twindow.history.pushState(null, null, can.route._call(\"root\")+path);\n            }\n\t\t}\n\t\t\n\t\t\n        var anchorClickFix = function(e) {\n        \tif(!( e.isDefaultPrevented ? e.isDefaultPrevented() : e.defaultPrevented === true )) {\n                // YUI calls back events triggered with this as a wrapped object\n                var node = this._node || this;\n                // Fix for ie showing blank host, but blank host means current host.\n                var linksHost = node.host || window.location.host;\n                // if link is within the same domain\n                if( window.location.host == linksHost ) {\n                    var curParams = can.route.deparam(node.pathname+node.search);\n                    // if a route matches\n                    if(curParams.hasOwnProperty('route')) {\n                    \t// make it possible to have a link with a hash\n                    \tincludeHash = true;\n                    \t// update the data\n                    \twindow.history.pushState(null, null, node.href);\n                    \t// test if you can preventDefault\n                    \t// our tests can't call .click() b/c this\n                    \t// freezes phantom\n                    \te.preventDefault && e.preventDefault();\n                \t}\n                }\n        \t}\n\t\t},\n\t\t\tcleanRoot = function(){\n        \t\tvar domain = location.protocol+\"//\"+location.host,\n        \t\t\troot = can.route._call(\"root\"),\n        \t\t\tindex = root.indexOf( domain );\n        \t\tif( index == 0 ) {\n        \t\t\treturn can.route.root.substr(domain.length)\n        \t\t}\n        \t\treturn root\n\t        },\n\t        // a collection of methods on history that we are overwriting\n\t        originalMethods = {},\n\t        // used to tell setURL to include the hash because \n\t        // we clicked on a link\n\t        includeHash = false;\n\t        \n        can.route.defaultBinding = \"pushstate\";\n        \n    }\n\n\treturn can;\n});",
    "\ndefine('templates',[\"can/view/mustache\"], function(can) {\ncan.view.preload('components_app_app_mustache',can.Mustache(function(scope,options) { var ___v1ew = [];___v1ew.push(\n\"<h1>can-boilerplate</h1>\\n<main></main>\\n<footer>\\n\\tCreated in <time datetime=\\\"2013-12\\\">December 2013</time> by <a href=\\\"http://www.svachon.com/\\\">Steven Vachon</a>.\\n</footer>\");; return ___v1ew.join('') }));\n});",
    "\ndefine(\n'components/app/app',[\n\t\"can\",\n\t\n\t//\"components/app/url-helpers\",\n\t\n\t// Anything else\n],\nfunction()\n{\n\treturn can.Component.extend(\n\t{\n\t\ttag: \"app-container\",\n\t\ttemplate: can.view(\"components/app/app\"),\n\t\t\n\t\t\n\t\t\n\t\tinit: function(element, options)\n\t\t{\n\t\t\t/*can.route(\"\", {section:\"\"});\n\t\t\tcan.route(\":section/\");\n\t\t\tcan.route(\":section/:sub/\");\n\t\t\tcan.route(\"assets/\", false);\n\t\t\tcan.route.ready();*/\n\t\t},\n\t\t\n\t\t\n\t\t\n\t\tscope:\n\t\t{\n\t\t\t\n\t\t},\n\t\t\n\t\t\n\t\t\n\t\tevents:\n\t\t{\n\t\t\t/*\"{can.route} section\": function(route, event, newVal)\n\t\t\t{\n\t\t\t\tswitch (newVal)\n\t\t\t\t{\n\t\t\t\t\tcase \"\":\n\t\t\t\t\t{\n\t\t\t\t\t\tconsole.log(\"load home section\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"fake-page1\":\n\t\t\t\t\tcase \"fake-page2\":\n\t\t\t\t\t{\n\t\t\t\t\t\tconsole.log(\"load \"+newVal+\" section\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tconsole.log(\"load error 404 page\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t});\n});",
    "\nrequire.config(\n{\n\tpaths:\n\t{\n\t\t// Main Libraries\n\t\tcan:\t\"assets/js/amd/can\",\n\t\tjquery:\t\"assets/js/amd/jquery-2.0.3\"\n\t},\n\tshim:\n\t{\n\t\t// Non-AMD scripts\n\t\t//\"assets/js/jquery.plugin\":\t\t[\"jquery\"],\n\t}\n});\n\n\n\nrequire(\n[\n\t\"can\",\n\t//\"can/construct/proxy\",\n\t\"can/route/pushstate\",\n\t\n\t// non-amd scripts here\n\t\n\t\"templates\",\t// must be above any components/controls\n\t\n\t\"components/app/app\"\n],\nfunction()\n{\n\tclearTimeout(preloader);\n\tpreloader = null;\n\t\n\tcan.route.bindings.pushstate.root = $(\"#appRoot\").attr(\"value\");\n\t\n\t$(\".preloader\").replaceWith( can.view.mustache(\"<app-container/>\")() );\n});\n\ndefine(\"init\", function(){});\n"
  ]
}